
\section{Prediction in Simulink}


\subsection{Description}
This appendix shows the performance of the proposed prediction algorithm. It is not fine tuned in this version but allows for choice of settings corresponding to the need of a specific use case.  


\subsection{Diagram}
\begin{figure} [h]
	\centering
	\includegraphics[width=\textwidth]{../Journal/Code/SimulinkPrediction}
	\caption{Overview of simulation of the prediction algorithm.}
	\label{Fig:PredictionSimulink}
\end{figure}


\subsection{Implementation}

\subsubsection{variables}
A lot of variables, are declared in the simulation and they are not all described here. The ones described are only the tunable parameters, that should be set in the prediction problem that should be solved. 
\begin{lstlisting} [language=MATLAB]
N; 				%is the frame length used as memory in the prediction and the prediction order
overlap;		%is the overlap in the buffer "O"
prediction; 	%is how far the algorithm should predict "P"
fs; 			%is the sample frequency of the input signal 
w=hamming(N)	% could be replaced by other window functions
M;				% is equal to N in all cases
\end{lstlisting}
The following sections will show the code for the individual blocks. \\
The ACF estimation estimates the autocorrelation function using the equation...
\subsubsection{ACF Estimation}
\begin{lstlisting} [language=MATLAB]
function r = fcn(x,w,updateRate,N)
persistent temp;

if isempty(temp)
	temp=zeros(N);
end

for lag = 0:N
	for n = lag+1:N
		temp(lag+1,1+N-n) = (x(n)*w(1+N-n)*x(n-lag)*w(1+N-n+lag));
	end
end
r=sum(temp')';
end
\end{lstlisting}

\subsubsection{Lenvinson Durbin}
\begin{lstlisting} [language=MATLAB]
function a = LevinsonDurbin(r, M)

% r0     ACF at lag 0
% r      ACF from lag 1 to m+1. It's like a Coloumstyle input
% m      Prediction order
% a      LP coefficients
r0=r(1);
r=r(2:end);

% INITIALIZATION - What do we know when we start?
a = zeros(M+1,1);       % Define the coloumn we are calculating
a(1) = 1;               % The zero order prediction
E = r0;                 % Error at lag 0 is the r0 in the ACF
a(2) = -r(1) / r0;      % The first order prediction
k(1) = a(2);            % k values are reflection coefficients
q = r(1);               % The Q-Value


% RECURSION - Moving on from the basics
for i = 1:M-1
E = E + ( q * k(i) );                   
q = r(i+1);
q = q + sum( r( 1:i) .* a(i+1:-1:2) );
k(i+1) = -q / E;
tmp (1:i) = k(i+1) .* a(i+1:-1:2) ;
a( 2:i+1) = a( 2:i+1) + tmp(1:i)';
a(i+2) = k(i+1) ;
end
% Same output syntax as matlab
a = a';
\end{lstlisting}

\subsubsection{Recursive filter}
\begin{lstlisting} [language=MATLAB]
function xhat = fcn(x,a,prediction,N)
%#codegen
persistent xIn;     %buffer for input

if isempty(xIn)
	xIn=zeros(1,N+prediction);
end

% throw the oldest x away and keep indsert the newest one
xIn = [xIn(2:N) x zeros(1,prediction)]; 

for j = 1:prediction % predict "prediction" samples ahead. 
	xIn(1,N+j) = -a(2:end,1)'*fliplr(xIn(1,1+j:N-1+j))';
end
xhat = xIn(1,N+prediction);
end
\end{lstlisting}

\subsection{Prediction Gain}
Prediction gain PG is used to evaluate the performance of the predictor. PGis given as:
\begin{equation}
	PG=10 \cdot log_{10}(\frac{\sigma^2_{input_signal}}{\sigma^2_{error}})
\end{equation} 
A PG=0 means no prediction can be achieved. A higher PG means better prediction.

\subsection{Test setup.}
It is required to run the simulation with a lot of different parameters. Rather than going for a random trial and error approach a systematic variation approach was chosen. If a person should control the simulations manually a lot of time would be spent, waiting for the algorithm to run. Therefore an automated test setup was constructed. The automation consists of 4 parts. 
\begin{enumerate}
	\item The prediction simulink
	\item An initiation 
	\item Saving data
	\item A script controlling parameters 
\end{enumerate}  

Below an example of the 3 controlling scripts are shown. The  scripts should be modified to run the simulator using the desired combination of parameters.

\textbf{Init.m}\\
If a variable is not controlled in "RunSim.m" it should be set here. 
\begin{lstlisting} [language=MATLAB]
fs = 48000;
ts = 1/fs; 
% Predictor 
% N = 50; %Frame
% M = N;   %Coefficients
% overlap = 0; %updaterate
% prediction = 1; % How far should the prediction be
w = hamming(N); 
% w = rectwin(N);
%w = barnwell(N,0.98);
% w = fliplr(w);
\end{lstlisting}

\textbf{SaveData.m}\\
It is possible to modify the save function to store all variables, including the calculated audio. This however results in approximately 5 $M$B of data pr simulation.  
\begin{lstlisting} [language=MATLAB]
	PG=10*log10(var(Ref)/var(ErrorSig));
	
	fname = sprintf(['fs' num2str(fs ) '_N' num2str(N) '_O' num2str(overlap) ...              '_M' num2str(M) '_P' num2str((prediction)) '.mat']);
	
	save(fname,'fs','N','overlap','M','prediction','PG');
\end{lstlisting}

\textbf{RunSim.m}
\begin{lstlisting} [language=MATLAB]
	clear 
	prediction=10;
	
	for N=100:100:3000
		M=N;
		for overlap=0:100:N-100
			sim('Predictora.slx')
			disp(['overlap=' num2str(overlap) 'done'])
		end
		disp(['N=' num2str(N) ' done'])
	end
	
	disp('I am done')	
\end{lstlisting}


Afterwards the script "loadData.m" can be used to structure the saved .mat  files in a single matrix.\\
\textbf{LoadData.m}
\begin{lstlisting} [language=MATLAB]
	clear
	close all
	fs=48000;
	prediction=10;
	counter=0;
	
	for N=100:100:3000
	M=N;
		for overlap=0:100:N-100
			fname = sprintf(['fs' num2str(fs) '_N' num2str(N) '_O' num2str(overlap) '_M' num2str(M) '_P' num2str((prediction)) '.mat']);
			load(fname)
			counter=counter+1;
			result(counter,:)=[fs N overlap M prediction PG]; 
		end
	end
	
	disp('I am done')
\end{lstlisting}

\subsection{Non automated test - $f_s$}
When testing the predictor for different $f_s$ automated testing can not be used, as the audio file used by the predictor has to be changed to the version with the correct sample rate. \\ 
In the "Init.m" file $N$ should be equal to $\frac{f_s}{N}$, $O=0$ and $P=1$. The following steps should be taken for each $f_s$ under test.
\begin{itemize}
	\item Choose the correct audio file in Simulink. 
	\item Set the fs parameter in "Init.m". 
\end{itemize}
The results are stored in different files automatically, and are shown in \autoref{tb:fsPredictApp}.

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|c|c|}
	\hline
	$f_s$ {[}$k$Hz{]} & 8 & 16 & 24 & 48 & 96 & 192 \\ \hline 
	$N$ {[}samples{]} & 100 & 200 & 300 & 600 & 1200 & 2400 \\ \hline 
	PG {[}dB{]} & 13.5 & 15.950 & 14.7 & 20.8 & 35.0 & 43.8 \\ \hline
\end{tabular}
\caption{$PG$ as a function of $f_S$. Parameters for the simulation are $O=0$ and $P=1$.}
\label{tb:fsPredictApp}
\end{table}  
 
\subsection{Automated tests - $N$ \& $O$}
Firstly the performance with different prediction orders is measured. This is the frame length parameter ($N$). \\ 
Here the $P$ is set to 43. $N$ is varied from 0-3000 in steps of 100. Overlap, $O$ is set varied from 0 to N-100. The used window is the Hamming window. The results are plotted using the surf() function i Matlab, and the viewing angle is set to "from above" resulting in a 2D plot. It should be noted that the measured points are the crossings of the black lines and not the coloured squares. The mesh() plot could be used to avoid this, if a less readable plot could be accepted. 

\begin{figure}[H]
	\centering
	\tikzsetnextfilename{HammingNOP43App}	
	\input{figures/Articleillustrations/HammingNOP43.tex}
	\caption{$PG$ as a function of different $N$ and $O$ with $P=43$. $N$ and $O$ are in hundreds.}
	\label{fig:Predict43App}
\end{figure}

The same experiment is performed with $P=10$.
\begin{figure}[H]
	\centering
	\tikzsetnextfilename{HammingNOP10App}	
	\input{figures/Articleillustrations/HammingNOP10.tex}
	\caption{$PG$ as a function of different $N$ and $O$ with $P=10$. $N$ and $O$ are in hundreds.}
	\label{fig:Predict10App}
\end{figure}

Using $N=1200$ and $O=1100$ the performance of the predictor for different P is determined. 
\begin{figure}[H]
	\centering
	\tikzsetnextfilename{PvarApp}	
	\input{figures/Articleillustrations/Pvar.tex}
	\caption{$PG$ as a function of $P$. $N=1200$ and $O=1100$}
	\label{fig:PredictPApp}
\end{figure}

