
\section{FIR function in assembly}


\subsection{Description}
This function filters an input signal with a set of filter coefficients with a given length (order).

\subsection{Syntax} 
\begin{lstlisting}
	extern Int16 FIR(Int16 *x, Int16 *b, Int16 order, Int16 index);
\end{lstlisting}

\subsection{Diagram}
\begin{figure} [h]
	\centering
	\includegraphics[width=0.6\textwidth]{../Journal/Code/FIRfilter}
	\caption{Diagram of FIR filter}
	\label{Fig:FIR_filter}
\end{figure}


\subsection{Implementation}

\subsubsection{variables}
\begin{lstlisting}
	Int16 	*x 		//The input signal
	Int16	*b		//The filter coefficients
	Int16	order	//The order of the filter (length of x & b)
	Int16	index	//The index of the newest x sample
	Int16	return	//Returns the output of the filter (y(n))
\end{lstlisting}

\subsubsection{code}
\begin{lstlisting} [language={[x86masm]Assembler}]
	.global _FIR;

;------------------------------------------------------
;		void FIR(  	Int16 *x,	=> AR0
;			  		Int16 *b, 	=> AR1
;			   		Int16 N, 	=> T0
;			   		Int16 i)		=> T1



_FIR:	
MOV #0, AC0					; Clear AC1
MOV mmap(AR0),BSA01			; Set base Adress for buffer
MOV mmap(T0), BK03			; Set buffer size to filter order
MOV *(#T1),AR0				; Start from ith sample
bset AR0LC					; Set pointer as circular
SUB #1,T0					; Setup Repititions
MOV T0,CSR					; Setup Repititions
RPT CSR						; Repeat order times
MAC *AR0-,*AR1+,AC0 		; Do filter convolution
SFTL AC0, #-15				; Bit shift to fit Q15
MOV AC0,T0					; Output sample
RET
\end{lstlisting}

\subsection{Test}
A LP FIR Butterworth filter was designed using the following specifications:

\begin{itemize}
	\item $f_{cutoff} = 500$ Hz
	\item Order = 16
	\item Fs = 25 $k$Hz
\end{itemize}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.75\textwidth]{../Journal/Code/Test/ButterworthLPFIR500hz}
	\caption{Magnitude Response of filter generated by MATLAB\textsuperscript{\textregistered}'s 'fdatool'}
	\label{Fig:FIR_filterfdatool}
\end{figure}

And yielding the following magnitude response, as seen on \autoref{Fig:FIR_filterfdatool}.

\begin{lstlisting} [language={[x86masm]Assembler}, caption=The 17 double-precision 16-bit filter-coefficients generated by MATLAB\textsuperscript{\textregistered}'s 'fdatool'., label=Lst:fdafiltercoefs]
0.05495103040004,	0.05636924343443,	0.05762079784516,	0.05869629010148,
0.05958760141172,	0.06028797732014,	0.0607920940819,	0.06109611107473,
0.06119770866076,	0.06109611107473,	0.0607920940819,	0.06028797732014,
0.05958760141172,	0.05869629010148,	0.05762079784516,	0.05636924343443,
0.05495103040004
\end{lstlisting}


The output of this generated is Direct-Form with 17 filter-coefficients and is double-precision with floating point. However this is not implementable on the selected DSP as it operated in fixed-point. This is why to compare this generated filter and the implementation, the generated filter is then quantized into Q15 format. As seen from \autoref{Lst:fdafiltercoefs} to \autoref{Lst:fdafiltercoefsquantized}

\begin{lstlisting} [language={[x86masm]Assembler}, caption=The 17 Q15 filter-coefficients., label=Lst:fdafiltercoefsquantized]
0.0550,	0.0564,	0.0576,	0.0587,	0.0596,	0.0603,	0.0608,	0.0611,	0.0612,
0.0611,	0.0608,	0.0603,	0.0596,	0.0587,	0.0576,	0.0564,	0.0550
\end{lstlisting}

The Q15 coefficients are converted into hexadecimal values, in order to implement them on the DSP for testing, as seen in \autoref{Lst:fdafiltercoefsquantizedhex} 

\begin{lstlisting} [language={[x86masm]Assembler}, caption=The 17 Q15 filter-coefficients in hexadecimal., label=Lst:fdafiltercoefsquantizedhex]
0x709,	0x737,	0x760,	0x783,	0x7A1,	0x7B8,	0x7C8,	0x7D2,	0x7D5,
0x7D2,	0x7C8,	0x7B8,	0x7A1,	0x783,	0x760,	0x737,	0x709
\end{lstlisting}

\begin{figure} [H]
	\centering
	\includegraphics[width=0.75\textwidth]{../Journal/Code/Test/FVrealization}
	\caption{Magnitude Response of sinusoidal sweep filtered by the Q15-coefficients}
	\label{Fig:FIR_filterfvtool}
\end{figure}

FIGURES SHALL BE MADE PRETTY


