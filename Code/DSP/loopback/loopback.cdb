//! 
//# c55xx.cdb 4.80.158

object DARAM :: MEM {
    param iComment :: "Dual Access RAM for efficient data access"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 256
    param len :: 32512
    param iAllocHeap :: 0
    param iHeapSize :: 0
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object SARAM :: MEM {
    param iComment :: "SARAM split into blocks for instruction cycle efficiency"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 65536
    param len :: 65536
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object VECT :: MEM {
    param iComment :: "This object defines space for the DSP's interrupt vectors and can't be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "MEM"
    param iDelMsg :: "This object defines space for the DSP's interrupt vectors and can't be deleted"
    param base :: 128
    param len :: 128
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (if self.gNumOf > 0 {1} else {0})
    prop NoGen :: 0
    prop IsDirty :: ($a = self.gDirty, self.gDirty = 0, $a)
    prop dataSize :: 0
    prop error :: # ("Error: ", self.name, $1)
    prop warning :: ("Warning ...", self.name, $1)
    prop minBit :: ($a = 0, while (($1 & (1 << $a)) && $a < 32) {++$a}, $a)
    prop name :: ("<unnamed module>")
    prop numBit :: ($a = $b = 0, while ($a < 32) {if ($1 & (1 << $a)) {++$b} }, $b)
}

class ObjectMgr {
    isa Module
    prop CanCreate :: (if (self.gNumOf < self.maxObjs()) {self.localCanCreate()} else {self.warning("Maximum number of objects already created")})
    prop CanDelete :: (if (self.iDelMsg == "ok" || (self.iDelUser == self.gUser)) {if (self.iId >= 0 && self.iIsUsed) {self.localCanDelete()} else {self.warning("Object already deleted")}} else {self.warning(self.iDelMsg)})
    prop Create :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanCreate()) == "ok") {if (($a = self.localCreate()) == "ok") {if (self.iIsUsed == 0) {self.mkId(if $0 > 1 {$2} else {-1}), self.iIsUsed = 1, GlobalStatus.gDirty = 1, self.gDirty = 1} } } , (self.gUser = "USER"), $a)
    prop Delete :: ((self.gUser = (if $0 > 0 {$1} else {"USER"})), if (($a = self.CanDelete()) == "ok") {if (($a = self.localDelete()) == "ok") {self.rmId(self.iId), self.iIsUsed = 0, GlobalStatus.gDirty = 1, self.gDirty = 1} } , (self.gUser = "USER"), $a)
    prop GetSetOf :: (self.gSetOf)
    prop GetNumOf :: (self.gNumOf)
    prop GetObjId :: (self.iId)
    prop GetPriority :: (self.iId)
    prop SetPriority :: (self.iId = $1)
    prop IsConfObj :: (self.iIsUsed)
    prop localCanCreate :: ("ok")
    prop localCanDelete :: ("ok")
    prop localCreate :: ("ok")
    prop localDelete :: ("ok")
    prop localInit :: (0)
    prop isFinite :: (if self.maxObjs() <= GBL.DSPWORDSIZE {1} else {0})
    prop mkId :: (if (self.isFinite()) {if ($1 < 0) {self.iId = self.minBit(self.gSetOf)} else {self.iId = $1}, (self.gSetOf |= (1 << self.iId))} else {self.iId = 0}, ++self.gNumOf, self.iId)
    prop rmId :: (if (self.isFinite()) {self.gSetOf &= ~(1 << self.iId)} , --self.gNumOf)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop isDriver :: (0)
    prop SortChildHierView :: (1)
}

type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (100)
    prop GlobalPropertyPage :: ("{9D3AD931-847B-11d0-A621-0000C070F3E9}")
    prop Status :: (# self.SeedVersion, # self.MinStackSize, # self.SysDataSize)
    global GENLIB :: "bioscfg.dll" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generation Library"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global DATE :: "Thu Nov 14 11:55:13 2002" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global GCONFVERS :: "@(#)*** xdc-c23" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SysDataSize :: = ($a = 0, scan ($i; nil) {if ($i.dataSize() != nil) {$a = $a + $i.dataSize()} }, $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Estimated Data Size: %d"
        prop StatusField :: 1
        prop NoGen :: 1
    }
    global MinStackSize :: = ($a = ((2) + (((2) + (4) + (2) + (2)))), $a = $a + ((1) + (((2) + (4) + (2) + (2)))), $a = $a + (0), $b = 0, scan ($i; CLK) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((((5) + (2) + (12) + (14))) + (2) + (((2) + (4) + (2) + (2)))) * $b), $b = 0, scan ($i; HWI) {if ($i.IsConfObj()) {if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {$b++} } }, $a = $a + (((2) + (10) + (6)) * $b), $b = 0, scan ($i; SWI) {if ($i.IsConfObj()) {if ($i.priority > $b) {$b = $i.priority} } }, $a = $a + (((((2) + (10) + (6))) + (((((5) + (2) + (12) + (14))) + (2))) + (((6) + (((2) + (4) + (2) + (2)))))) * $b), $b = 0, scan ($i; PRD) {if ($i.IsConfObj()) {$b |= 1} }, $a = $a + (((2) + (((2) + (4) + (2) + (2)))) * $b), $a) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "Est. Min. Stack Size (MAUs): %d"
        prop StatusField :: 1
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ConfigWarnings :: = (if (self.MinStackSize > MEM.STACKSIZE) {"Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."} else {"None"}) { 
        prop Label :: "Warnings"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SeedVersion :: = "@(#)*** cuda-4.80.00.34" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

class EModule {
    isa Module
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (1)
    prop Vendor :: ("")
    prop Version :: ("")
}

class ModuleFolder {
    isa Module
    prop NoGen :: 1
}

type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (500)
    prop GlobalPropertyPage :: ("{B936FB91-52A5-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (501)
    prop GlobalPropertyPage :: ("{053C8F90-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (502)
    prop GlobalPropertyPage :: ("{053C8F91-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (503)
    prop GlobalPropertyPage :: ("{053C8F92-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (504)
    prop GlobalPropertyPage :: ("{053C8F93-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type CSL {
    isa ModuleFolder
    prop Label :: "Chip Support Library"
    prop GlobalIcon :: 156
    prop GlobalHelpTopic :: (1000)
    prop GlobalPropertyPage :: ("{053C8F94-52A6-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type PROJ {
    isa ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (201)
    prop GlobalHelpTopic :: (101)
    prop InstancePropertyPage :: ("{AC3C77D1-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D2-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ALIASALL :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate C Names for All Objects"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global IGNOREWARNING :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Ignore Warnings"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Include File Search Path"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global OBJDIR :: "." { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object file directory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTEXE :: "out" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Executable File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTLIB :: "lib" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Library File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTASM :: "asm" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Assembly Language Source File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global EXTOBJ :: "obj" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Object File Extension"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst projType :: "Executable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Executable,Library"
        prop Label :: "Target Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst projName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst useRpt :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RPT Instruction"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst minimizeSpace :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Optimize for Space over Time"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst tmx :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Avoid TMX Silicon Bugs"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    prop Label :: "Project File Manager"
    prop InstanceHelpTopic :: (BIOSHELP_PROJ_FILE_INSTANCE)
    prop GlobalHelpTopic :: (BIOSHELP_PROJ_FILE_GLOBAL)
    prop InstancePropertyPage :: ("{AC3C77D3-890B-11d0-A621-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{AC3C77D4-890B-11d0-A621-0000C070F3E9}")
    prop NoGen :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst elemType :: "C Source" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C Source,ASM Source,Library,Linker Command File"
        prop Label :: "Input File Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Input File Name"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "register,register+local,register+local+global,register+local+global+file"
        prop Label :: "Optimization Level"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst inline :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Inline Expansion"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst definitions :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Additional Definitions"
        prop Visible :: 0
        prop Writable :: if self.elemType == "C Source" {1} else {0}
        prop NoGen :: 1
    }
    inst iParent :: 0 { 
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 1
    prop GenLinkPrologue :: ("%10S\nSECTIONS {%4t\n.vers block(0x10000) (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%16S%4S%17S%5S%6S%12S%7S%15s\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _devLibSuffix, clkLibStr, _chipStr, _sioLibStr")
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
    prop GlobalHelpTopic :: (103)
    prop InstanceHelpTopic :: (103)
    prop InstancePropertyPage :: ("{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}")
    prop localInit :: (RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"))
    prop chipcall :: ("ok")
    prop IsConfMod :: 1
    prop L2Check :: (if (self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711) {self.PCC = "mapped", if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} } else {if (self.DSPSUBTYPE == 6400) {self.PCC = "mapped", if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} } else {if (self.C621XL2CONFIGURE == 1) {self.C621XL2CONFIGURE = 0} else {if (self.C641XL2CONFIGURE == 1) {self.C641XL2CONFIGURE = 0, self.L2CONFIGALLOC = 0} }}}, self.L2CacheSizeCheck())
    prop C621xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C621XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "SRAM") {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.L2MODEOPTS == "1-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0xc000, CACHE_L2.len = 0x4000} else {if (self.L2MODEOPTS == "2-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0x8000, CACHE_L2.len = 0x8000} else {if (self.L2MODEOPTS == "3-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0x4000, CACHE_L2.len = 0xc000} else {if (self.L2MODEOPTS == "4-way cache") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0x0000, CACHE_L2.len = 0x10000} }}}}}, $e)
    prop C641xL2CacheSizeCheck :: ($e = "ok", $a = CACHE_L2.base, $b = CACHE_L2.len, if (self.C641XL2CONFIGURE == 0) {CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (0k)") {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")} else {if (self.C641XL2MODEOPTS == "4-way cache (32k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0xf8000, CACHE_L2.len = 0x8000} else {if (self.C641XL2MODEOPTS == "4-way cache (64k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0xf0000, CACHE_L2.len = 0x10000} else {if (self.C641XL2MODEOPTS == "4-way cache (128k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0xe0000, CACHE_L2.len = 0x20000} else {if (self.C641XL2MODEOPTS == "4-way cache (256k)") {CACHE_L2.Create("MEM"), CACHE_L2.base = 0xc0000, CACHE_L2.len = 0x40000} }}}}}, $e)
    prop L2CacheSizeCheck :: ($e = "ok", scan ($i; MEM) {if ($i == CACHE_L2) {if (self.C621XL2CONFIGURE) {$e = self.C621xL2CacheSizeCheck()} else {if (self.C641XL2CONFIGURE) {$e = self.C641xL2CacheSizeCheck()} else {if ((self.DSPSUBTYPE == 6211 || self.DSPSUBTYPE == 6711)) {$e = self.C621xL2CacheSizeCheck()} else {if (self.DSPSUBTYPE == 6400) {$e = self.C641xL2CacheSizeCheck()} else {CACHE_L2.base = 0x0, CACHE_L2.len = 0x0, CACHE_L2.Delete("MEM")}}}}} }, $e)
    prop setCPUClock :: ($e = "ok", if ($1 != self.CPUCLOCK) {$a = self.CPUCLOCK, self.CPUCLOCK = $1, if (GBL.CALLBACKOBJ != nil) {$e = GBL.CALLBACKOBJ.call()} , if ($e != "ok") {self.CPUCLOCK = $a, GBL.CALLBACKOBJ.call()} } , if ($e == "ok") {"ok"} else {self.error($e)})
    prop setCSLNAME :: (if (self.MEMORYMODEL == "SMALL") {if self.CHIPTYPE == "5509" {"csl5509.lib"} else {if self.CHIPTYPE == "5510" {"csl5510.lib"} else {if self.CHIPTYPE == "5510PG1_0" {"csl5510PG1_0.lib"} else {if self.CHIPTYPE == "5510PG1_2" {"csl5510PG1_2.lib"} else {if self.CHIPTYPE == "5510PG2_0" {"csl5510PG2_0.lib"} else {if self.CHIPTYPE == "5510PG2_1" {"csl5510PG2_1.lib"} else {if self.CHIPTYPE == "5510PG2_2" {"csl5510PG2_2.lib"} else {"CSL not available"}}}}}}}} else {if self.CHIPTYPE == "5509" {"csl5509x.lib"} else {if self.CHIPTYPE == "5510" {"csl5510x.lib"} else {if self.CHIPTYPE == "5510PG1_0" {"csl5510PG1_0x.lib"} else {if self.CHIPTYPE == "5510PG1_2" {"csl5510PG1_2x.lib"} else {if self.CHIPTYPE == "5510PG2_0" {"csl5510PG2_0x.lib"} else {if self.CHIPTYPE == "5510PG2_1" {"csl5510PG2_1x.lib"} else {if self.CHIPTYPE == "5510PG2_2" {"csl5510PG2_2x.lib"} else {"CSL not available"}}}}}}}})
    prop cGenCPrologue :: ("\n#pragma CODE_SECTION(CSL_cfgInit,\".text:CSL_cfgInit\")\n")
    prop setBootFxn :: (if self.CPUREVISION == "1.2" {@_FXN_F_nop} else {if self.CPUREVISION == "2.0" {@_FXN_F_nop} else {@GBL_F_biosbootfxn}})
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (if (HST.RTDX == 1) {"lnkrtdx"} else {if (HST.DSM == 1) {"lnkdsm"} else {if (HST.EVM54 == 1) {"lnkevm54"} else {"lnknone"}}})
    prop _dsptype :: GBL.DSPTYPE
    prop _compilerModel :: if self.MEMORYMODEL == "SMALL" {""} else {"x"}
    prop _librarySuffix :: if self.MEMORYMODEL == "SMALL" {".a55"} else {".a55l"}
    prop _rtdxLibStr :: if RTDX.RTDXTYPE == "JTAG" {"-lrtdx%9S.lib %24t/* RTDX JTAG support */%0t\n"} else {"-lrtdxsim%9S.lib %24t/* RTDX SIM support */%0t\n"}
    prop _rtsLibStr :: if self.MEMORYMODEL == "SMALL" {"-lrts55.lib%24t/* C and C++ run-time library support */%0t\n"} else {"-lrts55x.lib%24t/* C and C++ run-time library support */%0t\n"}
    prop _devLibSuffix :: if self.MEMORYMODEL == "SMALL" {".a55"} else {".a55l"}
    prop clkLibStr :: if self.MEMORYMODEL == "SMALL" {if self.ENABLEINST == 1 {"-lclki.a55"} else {"-lclk.a55"}} else {if self.ENABLEINST == 1 {"-lclki.a55l"} else {"-lclk.a55l"}}
    prop _chipStr :: ""
    prop _biosLibStr :: if self.ENABLEINST {"-lbiosi%8S %24t/* DSP/BIOS support */%0t\n"} else {"-lbios%8S %24t/* DSP/BIOS support */%0t\n"}
    prop _sioLibStr :: if SIO.USEISSUERECLAIM == 1 {"-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n"} else {"-lsioboth%8S %24t/* supports both SIO models */%0t\n"}
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (if (MEM.LNKCMDFILE == "") {""} else {"-l%11S %24t/* User Specified Linker cmd file */%0t\n"})
    prop _cslLibStr :: (if self.SUPPORTCSL {if self.MEMORYMODEL == "SMALL" {"-lcsl%13S.lib\n"} else {"-lcsl%13Sx.lib\n"}} else {""})
    prop _chipType :: self.CHIPTYPE
    prop AllocType :: (if (self.SUPPORTCSL) {"1\0,    _cslAllocDesc, _cslmemSeg, _placement"} )
    prop _cslAllocDesc :: ("%8t .csldata: {%12t\n *(.csldata)%8t\n }")
    prop _cslmemSeg :: MEM.BSSSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PRODUCT :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop EnvField :: 1
    }
    global CALLBACKOBJ :: CLK { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c55xx" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CPUCLOCK :: 400.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MIPS :: 200.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = self.MIPS, $b = if (GBL.DSPTYPE == 62) {$1} else {$1 * 2}, $e = "ok", self.MIPS = $1, if (($e = self.setCPUClock($b)) != "ok") {self.MIPS = $a} , $e)
    }
    global OSTYPE :: "BIOS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPTYPE :: 55 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPSUBTYPE :: 55 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Type"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CHIPTYPE :: "5510PG2_2" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "5509,5510PG1_2,5510PG2_0,5510PG2_1,5510PG2_2,other"
        prop JSName :: "CHIPTYPE"
        prop Label :: "Chip Support Library (CSL)"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop Set :: (self.CHIPTYPE = $1, $e = "ok", if (GBL.CHIPCHAIN != nil) {$e = GBL.CHIPCHAIN.chipcall()} , $e)
    }
    global CSLNAME :: = self.setCSLNAME() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Chip Support Library Name"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DISPCALLCSLCFGINIT :: = self.CHIPTYPE != "other" { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: self.SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "TMS320C55XX" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MODIFYCLKMD :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Modify CLKMD"
        prop JSName :: "MODIFYCLKMD"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {0} else {if GBL.DSPSUBTYPE == 1510 {0} else {1}}
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 != self.MODIFYCLKMD) {self.MODIFYCLKMD = $1} , "ok")
    }
    global CPUREVISION :: "2.2" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2.2,2.1,2.0,1.2"
        prop Label :: "CPU Revision"
        prop JSName :: "CPUREVISION"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 != self.CPUREVISION) {GBL.CPUREVISION = $1, if (GBL.CPUREVISION == "1.2" || GBL.CPUREVISION == "2.0") {GBL.BIOS_BOOTFXN = @_FXN_F_nop} else {GBL.BIOS_BOOTFXN = @GBL_F_biosbootfxn}} , "ok")
    }
    global CLKMD :: 11472 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "CLKMD - (PLL) Clock Mode Register"
        prop JSName :: "CLKMD"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {0} else {if GBL.DSPSUBTYPE == 1510 {0} else {1}}
        prop Writable :: self.MODIFYCLKMD
        prop NoGen :: 0
    }
    global DSPARITHMETIC :: = (if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {"FLOAT"} else {"FIXED"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {32} else {16}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (if GBL.DSPTYPE == 62 {8} else {GBL.DSPWORDSIZE}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DATAPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {16} else {if (GBL.DSPTYPE == 55) {if (GBL.MEMORYMODEL == "SMALL") {16} else {23}} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE :: = (if (GBL.DSPTYPE == 62) {32} else {if (GBL.DSPTYPE == 54) {if (GBL.CALLMODEL == "near") {16} else {24}} else {if (GBL.DSPTYPE == 55) {24} else {if (GBL.DSPTYPE == 28) {22} else {0}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MEMORYMODEL :: "LARGE" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SMALL,LARGE"
        prop Label :: "Memory Model"
        prop JSName :: "MEMORYMODEL"
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 1
    }
    global AUTOINIT :: "ROM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {self.USERINITFXN = @_FXN_F_nop, self.USERINIT = $1} else {self.USERINIT = $1}, "ok")
    }
    global USERINITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: self.USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ENABLEINST :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEINST) {if ($1) {RTA_toHost.Create("HST"), RTA_fromHost.Create("HST"), RTA_dispatcher.Create("HST"), IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = self.OLDAUTOCALCULATE} else {RTA_toHost.Delete("HST"), RTA_fromHost.Delete("HST"), RTA_dispatcher.Delete("HST"), IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), self.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0}, self.ENABLEINST = $1} , "ok")
    }
    global CGENERATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LARGEMODEL :: = if self.MEMORYMODEL == "LARGE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global ENABLEICACHE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable I-Cache Programming"
        prop JSName :: "ENABLEICACHE"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 != self.ENABLEICACHE) {self.ENABLEICACHE = $1} , "ok")
    }
    global CACHETYPE :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Nogen :: 0
    }
    global ICACHE :: "2-Way Two RAMset" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2-Way no RAMset,2-Way One RAMset,2-Way Two RAMset"
        prop Label :: "I-cache configuration"
        prop JSName :: "ICACHE"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if self.ENABLEICACHE == 1 {1} else {0}
        prop NoGen :: 1
        prop Set :: (self.ICACHE = $1, if (self.ICACHE == "2-Way no RAMset") {self.CACHETYPE = 0, "ok"} else {if (self.ICACHE == "2-Way One RAMset") {self.CACHETYPE = 1, "ok"} else {self.CACHETYPE = 2, "ok"}})
    }
    global CACHEICRTAG1 :: 16252928 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG1 address (24bit address)"
        prop JSName :: "CACHEICRTAG1"
        prop Format :: "0x%06x"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if ((self.ICACHE != "2-Way no RAMset") && (self.ENABLEICACHE == 1)) {1} else {0}
        prop NoGen :: 0
    }
    global CACHEICRTAG2 :: 16257024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x20
        prop Label :: "ICRTAG2 address (24bit address)"
        prop JSName :: "CACHEICRTAG2"
        prop Format :: "0x%06x"
        prop Visible :: if GBL.DSPSUBTYPE == 5561 {1} else {0}
        prop Writable :: if ((self.ICACHE == "2-Way Two RAMset") && (self.ENABLEICACHE == 1)) {1} else {0}
        prop NoGen :: 0
    }
    global SUPPORTCSL :: = self.CHIPTYPE != "other" { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.TRCMASKVALUE = 0xDBEF} else {self.TRCMASKVALUE = 0x4000}, self.ENABLEALLTRC = $1, "ok")
    }
    global TRCMASKVALUE :: 56303 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT :: = self.DISPCALLCSLCFGINIT { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global BIOS_BOOTFXN :: @GBL_F_biosbootfxn { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "BIOS boot function"
        prop JSName :: "BIOS_BOOTFXN"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
}

type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (108)
    prop InstanceHelpTopic :: (208)
    prop InstancePropertyPage :: ("{3D658E70-05E7-11d0-BD44-0020AFEE33C8}")
    prop GlobalPropertyPage :: ("{3D658E71-05E7-11d0-BD44-0020AFEE33C8}")
    prop _cmd55stksz :: (MEM.STACKSIZE * 2)
    prop _cmd55systksz :: (MEM.SYSSTACKSIZE * 2)
    prop _cmd55origin :: (self.base * 2)
    prop _cmd55len :: (self.len * 2)
    prop _cmd55heapsize :: (self.iHeapSize * 2)
    prop _cmd55heaplen :: (self.iHeapSize * 2)
    prop GenLinkPrologue :: (if (GBL.DSPTYPE == 55) {"-stack 0x%1x\n-sysstack 0x%2x\n\nSECTIONS { .sysstack : block(0x10000) fill = 0xfeeb {%12t\nGBL_sysstackbeg = .;\n*(.sysstack)\nGBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n _HWI_SYSSTKBOTTOM =
(GBL_sysstackend+1);\n%8t} > %3s}%0t\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz, _sysstackSeg"} else {"-stack 0x%1x\nMEMORY {%4t\0, _stackSize"})
    prop _stackSize :: MEM.STACKSIZE
    prop _sysstackSize :: MEM.SYSSTACKSIZE
    prop _sysstackSeg :: MEM.SYSSTACKSEG
    prop AllocType :: (if (self.REUSE == 0 && self.USERCMD == 0) {"19\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 0 && self.USERCMD == 1) {"9\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysinitString,	_initSeg,	_sysinitPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {if (self.REUSE == 1 && self.USERCMD == 0) {"18\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_bssString,	_bssSeg,	_firstPlace, \
		_farString,	_farSeg,	_secondPlace, \
		_cinitString,	_cinitSeg,	_midPlace, \
		_pinitString,	_pinitSeg,	_midPlace, \
		_dataString,	_dataSeg,	_midPlace, \
		_constString,	_constSeg,	_midPlace, \
		_switchString,	_switchSeg,	_midPlace, \
		_cioString,	_cioSeg,	_midPlace, \
		_textString,	_textSeg,	_midPlace, \
		_frtString,	_frtSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"} else {"8\0,	_argsString,	_argsSeg,	_midPlace, \
		_sysdataString,	_sysdataSeg,	_thirdPlace, \
		_trcinitString,	_trcinitSeg,	_midPlace, \
		_gblinitString,	_gblinitSeg,	_midPlace, \
		_memObjString,	_memObjSeg,	_midPlace, \
		_sysregsString,	_regsSeg,	_midPlace, \
		_biosString,	_biosSeg,	_midPlace, \
		_stackString,	_stackSeg,	_midPlace"}}})
    prop _firstPlace :: 0
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace :: (0x7fffff / 2)
    prop _sysinitPlace :: (0x7fffff / 2)
    prop _argsString :: ("%8t .args: align = 0x4  fill=0 block(0x10000) {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString :: ("%8t .bss: block(0x10000)    {}")
    prop _farString :: ("%8t .far:     {}")
    prop _cinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CINITSEG == MEM.LOADCINITSEG) {"%8t .cinit: block(0x10000)    {}"} else {"%8t .cinit:   {} load > %1s, run\0, _loadcinitSeg"}} else {"%8t .cinit: block(0x10000)    {}"})
    prop _pinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.PINITSEG == MEM.LOADPINITSEG) {"%8t .pinit: block(0x10000)    {}"} else {"%8t .pinit:   {} load > %1s, run\0, _loadpinitSeg"}} else {"%8t .pinit: block(0x10000)    {}"})
    prop _trcinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {"%8t .trcdata:   {}"} else {"%8t .trcdata:   {} load > %1s, run\0, _loadtrcinitSeg"}} else {"%8t .trcdata:    {}"})
    prop _gblinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {"%8t .gblinit: block(0x10000)   {}"} else {"%8t .gblinit:   {} load > %1s, run\0, _loadgblinitSeg"}} else {"%8t .gblinit: block(0x10000)   {}"})
    prop _dataString :: ("%8t .data: block(0x10000)  {}")
    prop _constString :: (if (self.ENABLELOADSEG == 1) {if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {"%8t .const:   {}"} else {"%8t .const:   {} load > %1s, run\0, _loadconstSeg"}} else {"%8t .const:    {}"})
    prop _switchString :: (if (self.ENABLELOADSEG == 1) {if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {"%8t .switch:   {}"} else {"%8t .switch:   {} load > %1s, run\0, _loadswitchSeg"}} else {"%8t .switch:    {}"})
    prop _sysmemString :: ("%8t .sysmem:  {}")
    prop _cioString :: ("%8t .cio:     {}")
    prop _memObjString :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (if ((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {"%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"} else {"%8t .sysdata: block(0x10000) {}"})
    prop _sysinitString :: (if (self.ENABLELOADSEG == 1) {if (MEM.INITSEG == MEM.LOADINITSEG) {"%8t .sysinit:   {}"} else {"%8t .sysinit:   {} load > %1s, run\0, _loadinitSeg"}} else {"%8t .sysinit:    {}"})
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString :: (if (self.ENABLELOADSEG == 1) {if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {"%8t .text:    {}"} else {"%8t .text:    {} load > %1s, run\0, _loadtextSeg"}} else {"%8t .text:    {}"})
    prop _frtString :: ("%8t frt:    {}")
    prop _biosString :: (if (self.ENABLELOADSEG == 1) {if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {"%8t .bios:    {}"} else {"%8t .bios:    {} load > %1s, run\0, _loadbiosSeg"}} else {"%8t .bios:    {}"})
    prop _stackString :: (if (GBL.DSPTYPE == 62) {"%8t .stack: fill=0xc0ffee {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 4 & ~7;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"} else {if (GBL.DSPTYPE == 54) {"%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"} else {if (GBL.DSPTYPE == 55) {"%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n _HWI_STKTOP = (GBL_stackbeg);%8t\n }\0, _cmd55stksz"} else {"%8t .stack: fill=0xbeef {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"}}})
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: ("%0t}")
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _farSeg :: MEM.FARSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop AllocInst :: (if (self.iAllocHeap == 1) {"1\0, _instAllocDesc, _objMemSeg, _placement"} )
    prop _instAllocDesc :: (if self.INITSEG.iAllocHeap && self.REUSE && self.INITSEG == self {"%8t .%0r$heap: {%12t\n %0r$B = .;\n%12t\n _%0r_base = .;\n . += 0x%2x;\n *(.sysinit)\n %0r$L = . + 0x%3x - %0r$B;\n _%0r_length = . + 0x%3x - %0r$B;\n . += 0x%1x;%8t\n }\0, _cmd55heapsize, _sysinitgap, _cmd55heaplen"} else {"%8t .%0r$heap: {%12t\n %0r$B = .;\n _%0r_base = .;\n %0r$L = 0x%2x;\n _%0r_length = 0x%2x;\n . += 0x%1x;%8t\n }\0, _cmd55heapsize, _cmd55heaplen"})
    prop _objMemSeg :: self
    prop _placement :: 0x7fffff - 1
    prop _heapsize :: (self.iHeapSize)
    prop _heaplen :: (self.iHeapSize)
    prop _sysinitgap :: 2 * 1
    prop GenInstLink :: (if GBL.DSPTYPE == 62 {"%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"} else {if GBL.DSPTYPE == 55 {"%0r: %16torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len"} else {"PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"}})
    prop localInit :: ($d = "ok", scan ($i; MEM) {if ($i.space == "code" && $i.iAllocHeap == 1) {$d = self.error("Code memory cannot have a heap")} }, if (self.SEGZERO.iAllocHeap == 1) {self.SEGZERO.iReqHeapCount++} else {$d = self.error("Segment for DSP/BIOS objects must be a memory segment with a heap")}, if (self.MALLOCSEG.iAllocHeap == 1) {self.MALLOCSEG.iReqHeapCount++} else {$d = self.error("Segment for malloc()/free() must be a memory segment with a heap")}, $d)
    prop _page :: (self.page)
    prop _origin :: (self.base)
    prop _len :: (self.len)
    prop maxObjs :: (32767)
    prop codeMember :: (if GBL.DSPTYPE == 62 {(($1.space == "code") || ($1.space == "code/data"))} else {if GBL.DSPTYPE == 54 {($1.space == "code")} else {if GBL.DSPTYPE == 28 {($1.space == "code")} else {($1.space == "code/data")}}})
    prop dataMember :: (if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {if GBL.DSPTYPE == 28 {(($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"} else {(($1.space == "code/data") && ($1 != MEM_NULL))}}})
    prop dataNullMember :: (if GBL.DSPTYPE == 62 {$1.space == "data" || $1.space == "code/data"} else {if GBL.DSPTYPE == 54 {$1.space != "code" && $1.space != "io"} else {if GBL.DSPTYPE == 28 {$1.space != "code" && $1.space != "io"} else {$1.space == "code/data"}}})
    prop dataCodeMember :: (if GBL.DSPTYPE == 62 {($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL} else {if GBL.DSPTYPE == 54 {$1.space == "code" && $1 != MEM_NULL} else {if GBL.DSPTYPE == 28 {$1.space == "code" && $1 != MEM_NULL} else {$1.space == "code/data" && $1 != MEM_NULL}}})
    prop memWritable :: (self.iIsModifiable && self.iDelUser != "MEM")
    prop validate :: ($e = self.checkMemOverlap($1), if ($e == "ok") {$e = self.checkHeapSize($1)} , $e)
    prop checkHeapSize :: ($e = "ok", if (MEM.NOHEAPS == 0) {if ($1.iAllocHeap && $1 != MEM_NULL) {if ($1.iHeapSize > $1.len) {$e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")} } } , $e)
    prop checkMemOverlap :: ($e = "ok", if ($1 != MEM_NULL && $1.iIsUsed == 1) {if ($1.len == 0) {$a = $1.base} else {$a = ($1.base + $1.len - 1)}, scan ($j; MEM) {if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 && (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 55 || $1.space == $j.space)) {if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {$b = $j.base, if ($j.len == 0) {$c = $j.base} else {$c = ($j.base + $j.len - 1)}, if ($a >= $b && $1.base <= $c) {$e = ("MEM segment %s: overlaps with another segment or cache configuration."), break} } } }} , $e)
    prop checkHeapId :: ($e = "ok", scan ($i; MEM) {if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {$e = self.error("This identifier label is already in use"), break} }, $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 7 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap :: = ($a = 0, scan ($i; MEM) {if ($i != MEM_NULL) {$a += $i.iAllocHeap} }, $a) { 
        prop NoGen :: 0
    }
    global REUSE :: = (if self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1 {self.SAVEREUSE} else {0}) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reuse Startup Code Space"
        prop JSName :: "REUSECODESPACE"
        prop Visible :: 1
        prop Writable :: self.INITSEG.space != "code" && self.INITSEG.iAllocHeap == 1
        prop NoGen :: 1
        prop Set :: (self.SAVEREUSE = $1, "ok")
    }
    global SAVEREUSE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    global doCheckOverlap :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global MAPSELECT :: nil { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Map Mode"
        prop JSName :: "MAPMODE"
        prop Enum :: "Map 0,Map 1"
        prop Visible :: GBL.DSPTYPE == 62
        prop Writable :: BOARD_REMAPPABLE && GBL.DSPSUBTYPE != 6211 && GBL.DSPSUBTYPE != 6711
        prop NoGen :: 1
        prop Set :: (if ($1 != self.MAPSELECT) {if ($1 == "Map 0") {scan ($i; MEM) {if ($i.base >= 0x00000000 && $i.base <= 0x003fffff) {$i.base = $i.base + 0x01400000 - 0x00000000} else {if ($i.base >= 0x00400000 && $i.base <= 0x017fffff) {$i.base = $i.base + 0x00000000 - 0x00400000} }}} , if ($1 == "Map 1") {scan ($i; MEM) {if ($i.base >= 0x01400000 && $i.base <= 0x017fffff) {$i.base = $i.base + 0x00000000 - 0x01400000} else {if ($i.base >= 0x00000000 && $i.base <= 0x013fffff) {$i.base = $i.base + 0x00400000 - 0x00000000} }}} , if ($1 != "Map 0" && $1 != "Map 1") {self.error("Invalid memory map selection")} } , self.MAPSELECT = $1, "ok")
    }
    global ARGSSIZE :: = if GBL.LARGEMODEL == 1 {16} else {8} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Argument Buffer Size"
        prop JSName :: "ARGSSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("The 'arguments' section must have at least 4 words.")} else {self.ARGSSIZE = $1 << 1, "ok"})
    }
    global ARGSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Argument Buffer Section (.args)"
        prop JSName :: "ARGSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global BIOSSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "BIOS Code Section (.bios)"
        prop JSName :: "BIOSSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "Stack Size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 < GlobalStatus.MinStackSize) {self.error("The software stack must be at least as large as the Estimated Minimum Stack Size.")} else {self.STACKSIZE = $1, "ok"})
    }
    global USERCMD :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User .cmd File For Non-DSP/BIOS Sections"
        prop JSName :: "USERCOMMANDFILE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "Stack Section (.stack)"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global SYSSTACKSIZE :: 256 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x01 | 0x02
        prop Label :: "System Stack Size (MAUs)"
        prop JSName :: "SYSSTACKSIZE"
        prop Visible :: if GBL.DSPTYPE == 55 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 1
    }
    global SYSSTACKSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "System Stack Section (.sysstack)"
        prop JSName :: "SYSSTACKSEG"
        prop Visible :: if GBL.DSPTYPE == 55 {1} else {0}
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
        prop Set :: (if (GBL.DSPTYPE == 55) {(MEM.STACKSEG = $1), (MEM.SYSSTACKSEG = $1)} else {(MEM.STACKSEG = $1)}, "ok")
    }
    global ENABLELOADSEG :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
        prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - BIOS Code Section (.bios)"
        prop JSName :: "LOADBIOSSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global INITSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Startup Code Section (.sysinit)"
        prop JSName :: "SYSINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.codeMember($1)
        prop Label :: "Load Address - Startup Code Section (.sysinit)"
        prop JSName :: "LOADSYSINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: SARAM_A { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "GBLINITSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: SARAM_A { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "TRC Initial Value (.trcdata)"
        prop JSName :: "TRCDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - DSP/BIOS Init Tables (.gblinit)"
        prop JSName :: "LOADGBLINITSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG :: = self.TRCINITSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataCodeMember($1)
        prop Label :: "Load Address - TRC Initial Value (.trcdata)"
        prop JSName :: "LOADTRCDATASEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SYSDATASEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Kernel State (.sysdata)"
        prop JSName :: "SYSDATASEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: self.dataMember($1)
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
        prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No Dynamic Memory Heaps"
        prop JSName :: "NOMEMORYHEAPS"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1) {self.SEGZERO.iReqHeapCount--, self.SEGZERO = MEM_NULL, self.MALLOCSEG.iReqHeapCount--, self.MALLOCSEG = MEM_NULL, TSK.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, scan ($i; MEM) {if ($i.iAllocHeap && $i != MEM_NULL) {$i.iAllocHeap = 0, $i.iHeapSize = 0} }} , self.NOHEAPS = $1, "ok")
        prop PropSetOkUserMsg :: if (MEM.NOHEAPS == 1) {"Currently specified heaps no longer valid"} else {"Please reconfigure heaps under individual mem segments"}
    }
    global SEGZERO :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For DSP/BIOS Objects"
        prop JSName :: "BIOSOBJSEG"
        prop Visible :: 1
        prop Writable :: MEM.NOHEAPS == 0
        prop NoGen :: 0
        prop Set :: (if (self.SEGZERO.iReqHeapCount > 0) {self.SEGZERO.iReqHeapCount--} , self.SEGZERO = $1, self.SEGZERO.iReqHeapCount++, "ok")
    }
    global MALLOCSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
        prop JSName :: "MALLOCSEG"
        prop Visible :: 1
        prop Writable :: (MEM.NOHEAPS == 0)
        prop NoGen :: 0
        prop Set :: (if (self.MALLOCSEG.iReqHeapCount > 0) {self.MALLOCSEG.iReqHeapCount--} , self.MALLOCSEG = $1, self.MALLOCSEG.iReqHeapCount++, "ok")
    }
    global LNKCMDFILE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TEXTSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Text Section (.text)"
        prop JSName :: "TEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.codeMember($1))
        prop Label :: "Load Address - Text Section (.text)"
        prop JSName :: "LOADTEXTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global SWITCHSEG :: SARAM_A { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Switch Jump Tables (.switch)"
        prop JSName :: "SWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Switch Jump Tables (.switch)"
        prop JSName :: "LOADSWITCHSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global BSSSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.bss)"
        prop JSName :: "BSSSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global FARSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "C Variables Section (.far)"
        prop JSName :: "FARSEG"
        prop Visible :: if GBL.DSPTYPE == 62 {1} else {0}
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: SARAM_A { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Data Initialization Section (.cinit)"
        prop JSName :: "CINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - Data Initialization Section (.cinit)"
        prop JSName :: "LOADCINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global PINITSEG :: SARAM_A { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "C Function Initialization Table (.pinit)"
        prop JSName :: "PINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADPINITSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataCodeMember($1))
        prop Label :: "Load Address - C Function Initialization Table (.pinit)"
        prop JSName :: "LOADPINITSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Constant Section (.const)"
        prop JSName :: "CONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Load Address - Constant Section (.const)"
        prop JSName :: "LOADCONSTSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0 && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global DATASEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.data)"
        prop JSName :: "DATASEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global CIOSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.cio)"
        prop JSName :: "CIOSEG"
        prop Visible :: 1
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global SYSMEMSEG :: = self.CIOSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (self.dataMember($1))
        prop Label :: "Data Section (.sysmem)"
        prop JSName :: "SYSMEMSEG"
        prop Visible :: 0
        prop Writable :: (self.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG :: = HWI.STUBMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory (.hwi)"
        prop JSName :: "HWISEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.STUBMEMSEG = $1, HWI.STUBMEMSEG = $1, "ok")
    }
    global LOADSTUBMEMSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - Function Stub Memory (.hwi)"
        prop JSName :: "LOADHWISEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global VECMEMSEG :: = HWI.VECMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "HWIVECSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.VECMEMSEG = $1, HWI.VECMEMSEG = $1, GlobalStatus.gDirty = 1, if ($1.base == 0) {HWI.GENERATE_RESET_VEC = 0} , "ok")
    }
    global LOADVECMEMSEG :: VECT { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
        prop JSName :: "LOADHWIVECSEG"
        prop Visible :: 1
        prop Writable :: (self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG :: = RTDX.TEXTMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop JSName :: "RTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: RTDX.USERTDX
        prop NoGen :: 1
        prop TabName :: "BIOS Code"
        prop Set :: (self.RTDXTEXTMEMSEG = $1, RTDX.TEXTMEMSEG = $1, "ok")
    }
    global LOADRTDXTEXTMEMSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
        prop JSName :: "LOADRTDXTEXTSEG"
        prop Visible :: 1
        prop Writable :: (RTDX.USERTDX && self.ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst base :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%06x"}
        prop Style :: 0x02
        prop Label :: "base"
        prop JSName :: "base"
        prop Visible :: 1
        prop Writable :: (self.iIsModifiable)
        prop NoGen :: 1
        prop Set :: (self.base = $1, "ok")
    }
    inst len :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x08
        prop Label :: "len"
        prop JSName :: "len"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 0
        prop Set :: (self.len = $1, "ok")
    }
    inst page :: = (if GBL.DSPTYPE == 62 {-1} else {if GBL.DSPTYPE == 55 {-1} else {if self.space == "code" {0} else {if self.space == "data" {1} else {if self.space == "io" {2} else {3}}}}}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iAllocHeap :: if MEM.NOHEAPS == 1 {0} else {1} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
        prop JSName :: "createHeap"
        prop Visible :: 1
        prop Writable :: (self.space == "data" || self.space == "code/data") && (MEM.NOHEAPS == 0) && self.iIsModifiable
        prop NoGen :: 0
        prop Set :: ($a = "ok", if ($1 == 0 && self.iReqHeapCount > 0) {self.error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")} else {if ($1 == 0) {self.iUserHeapId = 0, self.iHeapId = @segment_name} , self.iAllocHeap = $1, MEM.gDirty = 1, $a})
    }
    inst iHeapSize :: 0x007F00 / 2 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Style :: 0x02
        prop Label :: "heap size"
        prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (self.iHeapSize = $1, "ok")
        prop NoGen :: 1
    }
    inst iSegZero :: = MEM.SEGZERO
    inst iUserHeapId :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "enter a user defined heap identifier label"
        prop JSName :: "enableHeapLabel"
        prop Set :: (if ($1 == 0) {self.iHeapId = @segment_name} , self.iUserHeapId = $1, "ok")
        prop Visible :: 1
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0)
        prop NoGen :: 1
    }
    inst iHeapId :: @segment_name { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "heap identifier label"
        prop JSName :: "heapLabel"
        prop Set :: ($e = self.checkHeapId($1), if ($e == "ok") {self.iHeapId = $1} , $e)
        prop Writable :: (self.iAllocHeap) && (self.iIsModifiable) && (self.NOHEAPS == 0) && (self.iUserHeapId)
        prop Visible :: 1
        prop NoGen :: 0
    }
    inst iReqHeapCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst space :: (if GBL.DSPTYPE == 55 {"code/data"} else {"data"}) { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPTYPE == 62 {"code,data,code/data"} else {if GBL.DSPTYPE == 54 {"code,data,io,other"} else {if GBL.DSPTYPE == 28 {"code,data,io,other"} else {"code/data,io"}}}
        prop JSName :: "space"
        prop Visible :: 1
        prop Writable :: (self.memWritable)
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 != "data" && $1 != "code/data" && self.iAllocHeap == 1) {$e = self.error("Cannot select this space if a heap will be created")} else {self.space = $1}, $e)
    }
    inst iIsModifiable :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 0
    param len :: 0
    param iAllocHeap :: 1
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: -1
    param space :: "code/data"
    param iIsModifiable :: 1
}

type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _objMemDesc, _memSeg, _placement"} )
    prop _objMemDesc :: ("%8t .obj: block(0x10000) {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (202)
    prop GlobalHelpTopic :: (102)
    prop InstancePropertyPage :: ("{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}")
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x10000){\n%8t _CLK_start = %6s;\n CLK_F_gethtime = %5s;\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s \0, name, _objSize, _memSeg, _linkString, clkFxn, _clkStartFxn")
    prop _clkStartFxn :: if (GBL.SUPPORTCSL && self.USETIMER) {@_CLK_start55} else {@FXN_F_nop}
    prop GenLinkEpilogue :: ("%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n\0")
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no CLK objs */"}
    prop _memSeg :: CLK.OBJMEMSEG
    prop _objSize :: 2
    prop clkFxn :: if (self.USETIMER == 1) {self.CLKFXN} else {@FXN_F_zero}
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (if (GBL.CALLBACKOBJ != CLK) {CLK.gGBLChain = GBL.CALLBACKOBJ, GBL.CALLBACKOBJ = CLK} )
    prop dataSize :: (2 * (CLK.gNumOf + 1))
    prop localCanCreate :: (if self.USETIMER {"ok"} else {self.error("The CLK Manager must be enabled before inserting a CLK")})
    prop localCreate :: (CLK.HOOKFXN = @CLK_F_run, "ok")
    prop localDelete :: (if (self.gNumOf == 1) {if (GBL.CALLMODEL == "far") {CLK.HOOKFXN = @CLK_F_frete} else {CLK.HOOKFXN = @CLK_F_rete}} , "ok")
    prop adjustPrd :: (if GBL.DSPTYPE == 62 {0} else {1})
    prop seizeHwi :: (if ($1.client == "USER" && $1.function != @HWI_unused) {self.error("Interrupt mapped to selected timer is already in use.")} else {if ($1.client == "CSL") {self.error("Interrupt mapped to selected timer is already in use by CSL.")} else {$1.function = @CLK_F_isr, $1.client = "CLK", $1.iUseDispatcher = (if CLK.HOOKFXN == @CLK_F_run {0} else {if CLK.HOOKFXN == @CLK_F_rete {0} else {1}}), $1.iArg = (if $1.iUseDispatcher == 1 {@CLK_A_TABBEG} else {0}), HWI.gDirty = 1, "ok"}})
    prop releaseHwi :: ($1.function = @HWI_unused, $1.client = "USER", $1.iUseDispatcher = 0, $1.iArg = 0, HWI.gDirty = 1, "ok")
    prop setMicroseconds :: ($c = if self.FIXTDDR == 1 {(self.TDDR + 1.0) * (float(0xffff) + self.adjustPrd + 0.5) * 2 / GBL.CPUCLOCK} else {(0xf + 1.0) * (float(0xffff) + self.adjustPrd + 0.5) * 2 / GBL.CPUCLOCK}, if ($1 < $c && $1 > 0.1) {if (self.FIXTDDR == 0) {self.TDDR = int(round((1.0 * $1 * GBL.CPUCLOCK / 2) - 1) / (0xffff + self.adjustPrd))} , self.PRD = int(round(1.0 * $1 * GBL.CPUCLOCK / (2 * (self.TDDR + 1.0)))) - CLK.adjustPrd, self.MICROSECONDS = ((float((self.PRD)) + CLK.adjustPrd) * ((self.TDDR) + 1.0) * 2 / GBL.CPUCLOCK), if (self.CALLBACKOBJ != nil) {self.CALLBACKOBJ.call()} , "ok"} else {self.error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")})
    prop call :: ($a = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK), $b = CLK.MICROSECONDS, $e = "ok", if (($e = self.setMicroseconds(CLK.MICROSECONDS)) == "ok") {if (CLK.gGBLChain != nil) {$e = CLK.gGBLChain.call()} , if ($e != "ok") {self.setMicroseconds($b), self.error($e)} else {"ok"}} else {$e})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gGBLChain :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global IMR0TINTMASK :: 16 { 
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global IMR1TINTMASK :: 0 { 
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global WHICHHWI :: = (if self.WHICHTIMER == "Timer 0" {Timer_0.iHwi} else {Timer_1.iHwi}) { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop Label :: "CPU Interrupt"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global INTBIT :: = (if self.WHICHTIMER == "Timer 0" {4} else {6}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global TIMERIMRMASK :: = (if self.WHICHTIMER == "Timer 0" {self.WHICHHWI.Ier0Mask} else {self.WHICHHWI.Ier1Mask}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: self.USETIMER
        prop NoGen :: 0
    }
    global WHICHTIMER :: "Timer 0" { 
        prop Label :: "Timer Selection"
        prop JSName :: "TIMERSELECT"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Timer 0,Timer 1"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (self.WHICHTIMER != $1) {if (self.USETIMER == 0) {$e = "ok"} else {if ($1 == "Timer 0") {$a = Timer_0.iHwi} else {if ($1 == "Timer 1") {$a = Timer_1.iHwi} }, $e = self.seizeHwi($a)}, if ($e == "ok") {self.releaseHwi(self.WHICHHWI), if ($1 == "Timer 0") {self.REGS = 0x1000, self.TIMERNUM = 0, self.WHICHHWI = Timer_0.iHwi, self.TIMERIMR = 0x0, self.TIMERIFR = 0x1, self.INTBIT = 4, self.TIMERIMRMASK = self.WHICHHWI.Ier0Mask, self.IMR0TINTMASK = self.WHICHHWI.Ier0Mask, self.IMR1TINTMASK = 0x0, self.setMicroseconds(self.MICROSECONDS)} else {if ($1 == "Timer 1") {self.REGS = 0x2400, self.TIMERNUM = 1, self.WHICHHWI = Timer_1.iHwi, self.TIMERIMR = 0x45, self.TIMERIFR = 0x46, self.INTBIT = 6, self.TIMERIMRMASK = self.WHICHHWI.Ier1Mask, self.IMR0TINTMASK = 0x0, self.IMR1TINTMASK = self.WHICHHWI.Ier1Mask, self.setMicroseconds(self.MICROSECONDS)} }, self.WHICHTIMER = $1, self.HOOKFXN = if self.gNumOf > 0 {@CLK_F_run} else {@CLK_F_rete}, self.seizeHwi(self.WHICHHWI)} , $e} )
    }
    global REGS :: 4096 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERIMR :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERIFR :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global TIMERNUM :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
    }
    global USETIMER :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable CLK Manager"
        prop JSName :: "ENABLECLK"
        prop Visible :: 1
        prop Writable :: if self.gNumOf > 0 {0} else {1}
        prop NoGen :: 0
        prop Set :: (if ($1 == 1 && self.USETIMER == 0) {if (($e = self.seizeHwi(self.WHICHHWI)) == "ok") {self.USETIMER = 1, self.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}, self.HOOKFXN = if self.gNumOf > 0 {@CLK_F_run} else {@CLK_F_rete}, self.seizeHwi(self.WHICHHWI), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, GlobalStatus.gDirty = 1, self.error("Current stack size inadequate to enable CLK")} else {if (GBL.ENABLEINST == 1) {IDL_busyObj.Create("IDL"), IDL.USEIDLBUSYOBJ = 1, IDL_cpuLoad.Create("IDL"), IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE} , "ok"}} else {$e}} else {if ($1 == 0 && self.USETIMER == 1) {self.releaseHwi(self.WHICHHWI), self.TIMEFXN = @FXN_F_zero, self.HOOKFXN = @FXN_F_nop, self.USETIMER = 0, if (GBL.ENABLEINST == 1) {IDL_busyObj.Delete("IDL"), IDL.USEIDLBUSYOBJ = 0, IDL_cpuLoad.Delete("IDL"), GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE, IDL.AUTOCALCULATE = 0} , "ok"} else {"ok"}})
    }
    global HIRES :: = 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use high resolution time for internal timings"
        prop JSName :: "HIRESTIME"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
        prop Set :: (if (CLK.USETIMER) {CLK.HIRES = $1, if (CLK.USETIMER) {CLK.TIMEFXN = if CLK.HIRES {CLK.clkFxn()} else {@CLK_F_getltime}} , "ok"} else {self.error("CLK Manager must be enabled in order to get high resolution timings.")})
    }
    global INSTRPERCLK :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "Microseconds/Int"
        prop JSName :: "MICROSECONDS"
        prop Set :: (self.setMicroseconds($1))
        prop Visible :: 1
        prop Writable :: if ((CLK.PROGTIMREGS != 0) | (self.USETIMER == 0)) {0} else {1}
        prop NoGen :: 1
    }
    global PROGTIMREGS :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Directly configure on-chip timer registers"
        prop JSName :: "CONFIGURETIMER"
        prop Visible :: 1
        prop Writable :: self.USETIMER
        prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global FIXTDDR :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Fix TDDR"
        prop JSName :: "FIXTDDR"
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 1
    }
    global TDDR :: 3 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Label :: if GBL.DSPSUBTYPE == 5561 {"TDDR Register (PREMD=0)"} else {"TDDR Register"}
        prop JSName :: "TCRTDDR"
        prop Set :: (CLK.TDDR = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: GBL.DSPTYPE != 62
        prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
        prop NoGen :: 0
    }
    global PRD :: 49999 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: if GBL.DSPWORDSIZE == 16 {0x01 | 0x02} else {0x02}
        prop Label :: "PRD Register"
        prop JSName :: "PRD"
        prop Set :: (CLK.PRD = $1, CLK.MICROSECONDS = ((float((CLK.PRD)) + CLK.adjustPrd) * ((CLK.TDDR) + 1.0) * 2 / GBL.CPUCLOCK), if (CLK.CALLBACKOBJ != nil) {CLK.CALLBACKOBJ.call()} , "ok")
        prop Visible :: 1
        prop Writable :: if ((self.PROGTIMREGS) && (self.USETIMER)) {1} else {0}
        prop NoGen :: 0
    }
    global COUNTSPMS :: = int(round(GBL.CPUCLOCK * 1000.0 / (CLK.TDDR + 1) / 2)) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global COUNTSPMSHIGH :: = ((self.COUNTSPMS & 0xffff0000) >> 16) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global INSTRUCTIONS :: = (1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.0f"
        prop Label :: "Instructions/Int"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TIMEFXN :: = CLK.clkFxn() { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HOOKFXN :: @CLK_F_run { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CLKFXN :: = (if (CLK.PRD == 0xffff) {@CLK_F_getfhtime} else {@CLK_F_getshtime}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: PRD { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (210)
    prop GlobalHelpTopic :: (110)
    prop InstancePropertyPage :: ("{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: ("%g ticks")
    prop STSGetSumFmt :: (PRD.STSGetMaxFmt())
    prop STSGetAvgFmt :: ("%.2f ticks")
    prop GetPeriod :: self.period
    prop IsOneShot :: if self.mode == "one-shot" {1} else {0}
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x10000){\n%8t %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\n%4t} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {if GBL.DSPTYPE == 28 {" PAGE 1 "} else {" PAGE 1"}}}
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(10 * 1) * 2} else {(10 * 1)}
    prop dataSize :: ((10 * 1) * PRD.gNumOf)
    prop localInit :: (if (CLK.CALLBACKOBJ != nil) {self.error("PRD initialization failure")} , CLK.CALLBACKOBJ = PRD, if (PRD.USECLK && PRD_clock.iIsUsed == 0) {PRD_clock.Create("PRD")} , if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} else {PRD_clock.function = @PRD_F_tick}} )
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error(" System Stack Size too small")} else {self.myCreate("can")})
    prop localCreate :: (STS.gNumEmbed += 1, if (($a = self.myCreate("do")) == "ok") {if (PRD_clock.iIsUsed == 1) {if (self.gNumOf == 0) {PRD_clock.function = @PRD_F_tick} } } , $a)
    prop localCanDelete :: (self.myDelete("can"))
    prop localDelete :: (STS.gNumEmbed -= 1, if (($a = self.myDelete("do")) == "ok") {if (self.gNumOf == 1) {if (PRD_clock.iIsUsed == 1) {if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {PRD_clock.function = @PRD_F_tick} else {PRD_clock.function = @FXN_F_nop}} } } , $a)
    prop maxObjs :: (32767)
    prop myCreate :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (PRD_swi.iIsUsed) {"ok"} else {if (SWI.CanCreate() == "ok") {if ($1 == "do") {if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {PRD_swi.pri = 1} , PRD_swi.Create("PRD")} else {"ok"}} else {self.error("Can't create an SWI for PRD (try deleting a SWI)")}})
    prop myDelete :: (if (PRD_swi.function != @PRD_F_swi) {PRD_swi.function = @PRD_F_swi} , if (self.gNumOf == 1) {if ($1 == "do") {PRD_swi.Delete("PRD")} else {"ok"}} else {"ok"})
    prop call :: (if (CLK.USETIMER != 0) {PRD.MICROSECONDS = CLK.MICROSECONDS} , PRD.CALLBACKOBJ.call())
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"prd.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PRD_Obj %0r;\n\0"} else {"extern PRD_Obj %0r;\n\0"})
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop DEFAULT_THOOKFXN :: @KNL_tick_stub
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USECLK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use CLK Manager to drive PRD"
        prop JSName :: "USECLK"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 1 && self.USECLK == 0) {if (CLK.USETIMER == 0) {self.error("In order to drive periodic functions, the CLK Manager must be enabled")} else {self.USECLK = 1, self.MICROSECONDS = CLK.MICROSECONDS, CLK.CALLBACKOBJ = PRD, PRD_clock.Create("PRD"), GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD"), self.error("Current Stack size inadequate to enable this option")} else {"ok"}}} else {if ($1 == 0 && self.USECLK == 1) {self.USECLK = 0, self.MICROSECONDS = 0.0, CLK.CALLBACKOBJ = nil, PRD_clock.Delete("PRD")} , "ok"})
        prop NoGen :: 1
    }
    global MICROSECONDS :: 1000.000000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Label :: "Microseconds/Tick"
        prop JSName :: "MICROSECONDS"
        prop Visible :: 1
        prop Writable :: self.USECLK == 0
        prop NoGen :: 1
    }
    global SCALAR :: = ($d = 2, $f = 0, while ($d <= 0x4000 && $f == 0) {scan ($i; PRD) {if (($i.period / $d) * $d != $i.period) {$f = 1} }, if ($f == 0) {$d = 2 * $d} }, $d / 2) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global THOOKFXN :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "System Tick Hook Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALLBACKOBJ :: STS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst period :: 0xffff { 
        prop Label :: "period (ticks)"
        prop JSName :: "period"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 > 0) {self.period = $1, self.gDirty = 1, "ok"} else {self.error("Periodic function periods must be greater than 0")})
    }
    inst mode :: "continuous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "continuous,one-shot"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst milliseconds :: = ((self.period * PRD.MICROSECONDS) / 1000.0) { 
        prop Label :: "period (ms)"
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.1f"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object PRD_swi :: SWI {
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted when all PRD objects are deleted"
    param function :: @PRD_F_swi
    param pri :: 1
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
}

object PRD_clock :: CLK {
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "PRD"
    param iDelMsg :: "This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    param function :: @PRD_F_tick
    param Order :: 0
    param iPri :: 0
}

type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: self.USERTDX
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (113)
    prop InstanceHelpTopic :: (213)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop AllocType :: (if self.USERTDX {"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"} else {""})
    prop _rtdxDataAllocDesc :: (" .%1L_data: block(0x10000){} \0, name")
    prop _rtdxTextAllocDesc :: (if (MEM.ENABLELOADSEG == 1) {if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {" .%1L_text: {} \0, name"} else {" .%1L_text: {} load > %2s, run \0, name, _loadRtdxTextMemSeg"}} else {" .%1L_text: {} \0, name"})
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop GenLinkPrologue :: (if self.USERTDX {"_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"} else {""})
    prop _interruptMask :: RTDX.MASK
    prop cGen :: 1
    prop noObjectAlias :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"rtdx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {if (self.iChannelMode == "output") {"extern far RTDX_outputChannel %0r;\n\0"} else {"extern far RTDX_inputChannel %0r;\n\0"}} else {if (self.iChannelMode == "output") {"extern RTDX_outputChannel %0r;\n\0"} else {"extern RTDX_inputChannel %0r;\n\0"}})
    prop cGenCInst :: (if (self.iChannelMode == "output") {"RTDX_CreateOutputChannel(%0r);\n\0"} else {"RTDX_CreateInputChannel(%0r);\n\0"})
    prop dataSize :: ($d = 0, if (self.USERTDX) {$d = RTDX.BUFMEMSIZE} else {$d = 0}, scan ($a; RTDX) {if ($a.iChannelMode == "output") {$d += 1} else {$d += 3}}, $d)
    prop localCanCreate :: ($e = "ok", if (RTDX.USERTDX != 1) {$e = self.error("RTDX manager not enabled")} , $e)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USERTDX :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Data Exchange (RTDX)"
        prop JSName :: "ENABLERTDX"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 0) {if (HST.LNKTYPE == "RTDX") {self.error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX")} else {if (self.gNumOf > 0) {self.error("Cannot disable RTDX until all RTDX objects are deleted.")} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"}}} else {GlobalStatus.gDirty = 1, self.USERTDX = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok"})
    }
    global USERTEXECUTION :: = 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real-Time Execution Control"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "JTAG,Simulator"
        prop Label :: "RTDX Mode"
        prop JSName :: "MODE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.RTDXTYPE = $1, if (RTDX.CALLBACKOBJ != nil) {RTDX.CALLBACKOBJ.call()} , "ok")
    }
    global DATAMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "RTDX Data Segment (.rtdx_data)"
        prop JSName :: "RTDXDATASEG"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
    }
    global BUFMEMSIZE :: = (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "RTDX Buffer Size (MAUs)"
        prop JSName :: "BUFSIZE"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 0
        prop Set :: (if (HST.RTDX == 0) {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, "ok"} else {if ($1 < (HST.MAXFRAMESET + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {self.error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 2) * (MAUs per word)")} else {self.BUFMEMSIZE = $1, GlobalStatus.gDirty = 1, if (HST.LNKTYPE == "RTDX") {HST.MAXFRAMEALLOWED = (self.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"} else {"ok"}}})
    }
    global TEXTMEMSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "RTDX Text Segment (.rtdx_text)"
        prop Visible :: 0
        prop Writable :: self.USERTDX
        prop NoGen :: 1
    }
    global MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Style :: 0x02
        prop Label :: "RTDX Interrupt Mask"
        prop JSName :: "INTERRUPTMASK"
        prop Visible :: 1
        prop Writable :: self.USERTDX
        prop NoGen :: 1
        prop Set :: (self.MASK = $1, "ok")
    }
    global CALLBACKOBJ :: HWI { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iChannelMode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Channel Mode"
        prop JSName :: "channelMode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.iChannelMode = $1, "ok")
    }
}

type HST {
    isa ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (104)
    prop InstanceHelpTopic :: (204)
    prop maxObjs :: (GBL.DSPWORDSIZE)
    prop dataSize :: ($b = 0, scan ($i; HST) {if ($i.IsConfObj()) {$b += ((6) + $i.framesize) * $i.numframes + ((50) * 2) + (8 * 1)} }, $b)
    prop InstancePropertyPage :: ("{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}")
    prop DependsOn :: "HWI"
    prop localCreate :: (PIP.gNumEmbed += 1, if (self.gNumOf == 0) {(LNK_dataPump.Create("HST"))} , "ok")
    prop localDelete :: (PIP.gNumEmbed -= 1, $b = 0, scan ($i; HST) {if ($i != self) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } } }, self.MAXFRAMESET = $b, if (self.gNumOf == 1) {(LNK_dataPump.Delete("HST"))} , "ok")
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, \
	      _dsmAllocDesc, _dsmMemSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x10000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop _dsmAllocDesc :: ("%8t .dsm: block(0x10000) {}")
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: ("/* %0s buffer */\n.hst%2d: block(0x10000) %3S\0, name, _objId, _alignString, _objAlign")
    prop _alignString :: if self.bufalign > 1 {"align = 0x%4x {}"} else {""}
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: (8 * 1)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"hst.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far HST_Obj %0r;\n\0"} else {"extern HST_Obj %0r;\n\0"})
    prop modifiable :: ((if self.iDelUser == "USER" {1} else {0}))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LNKTYPE :: "RTDX" { 
        prop Label :: "Host Link Type"
        prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (if ($1 == "RTDX") {if (RTDX.USERTDX == 0) {self.error("RTDX module must be enabled before it can be used by HST")} else {if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < self.MAXFRAMESET) {self.error("RTDX buffer size too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2, "ok"}}}} else {if ($1 == "Shared Memory") {if ((self.DSMMEMSIZE / 4) < self.MAXFRAMESET) {self.error("Shared memory buffer too small for largest configured HST channel")} else {if (self.LNKTYPE == "NONE") {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {self.LNKTYPE = $1, self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"}}} else {GlobalStatus.gDirty = 1, self.LNKTYPE = $1, "ok"}})
    }
    global RTDX :: = if self.LNKTYPE == "RTDX" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM :: = if self.LNKTYPE == "Shared Memory" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 :: = if self.LNKTYPE == "EVM54" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE :: = if self.LNKTYPE == "NONE" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET :: 64 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED :: 256 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
    }
    global DSMMEMSIZE :: = 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: self.DSM
        prop NoGen :: 0
        prop Set :: (if ($1 < HST.MAXFRAMESET * 4) {self.error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")} else {self.DSMMEMSIZE = $1, GlobalStatus.gDirty = 1, if (self.LNKTYPE == "Shared Memory") {self.MAXFRAMEALLOWED = self.DSMMEMSIZE / 4, "ok"} else {"ok"}})
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst mode :: "output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "mode"
        prop Enum :: "input,output"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst bufalign :: 4 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 1
        prop Set :: (if ($1 < 4) {self.error("Alignment must be greater than or equal to 4")} else {if (($1 % 2) != 0) {self.error("Alignment must be a power of 2")} else {$i = $1, while ((($i % 2) == 0) && ($i != 2)) {$i = $i / 2}, if (($i % 2) != 0) {self.error("Alignment must be a power of 2")} else {self.bufalign = $1, "ok"}}})
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {if (($1 > self.MAXFRAMEALLOWED) && ((self.RTDX == 1) || (self.DSM == 1))) {if (self.RTDX == 1) {self.error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 2")} else {self.error("size (in words) is limited to: shared memory frame size (in MAUs)/4")}} else {self.framesize = $1, $b = 0, scan ($i; HST) {if ($i.IsConfObj()) {if ($i.framesize > $b) {$b = $i.framesize} } }, self.MAXFRAMESET = $b, GlobalStatus.gDirty = 1, "ok"}})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: self.modifiable()
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Channels must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst stsflg :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "statistics"
        prop JSName :: "statistics"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "DHL" || self.iDelUser != "USER" {0} else {1})
        prop NoGen :: 0
        prop TabName :: "Notify Function"
    }
    inst lnk :: = if self.RTDX {"RTDX"} else {"NOTRTDX"} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "link type"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Make this channel available for a new DHL device"
        prop JSName :: "availableForDHL"
        prop Set :: (if (($1 == 0) && (self.iDHLAvailable == 1)) {DHL.gChannelsAvailable--} else {if (($1 == 1) && (self.iDHLAvailable == 0)) {DHL.gChannelsAvailable++} }, self.iDHLAvailable = $1, "ok")
        prop Writable :: self.modifiable()
        prop Visible :: 1
        prop NoGen :: 1
    }
    inst bufFrameAlign :: = self.bufalign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

object LNK_dataPump :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @LNK_F_dataPump
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_dispatcher :: IDL {
    param iComment :: "This object cannot be deleted"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param function :: @RTA_F_dispatch
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object RTA_fromHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "input"
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 8
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

object RTA_toHost :: HST {
    param iComment :: "Used to access LOG and STS data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HST"
    param iDelMsg :: "This object cannot be deleted"
    param mode :: "output"
    param bufalign :: 4
    param buf :: "<NULL>"
    param framesize :: 64
    param numframes :: 1
    param stsflg :: 0
    param notify :: @_FXN_F_nop
    param arg0 :: 0
    param arg1 :: 0
    param iDHLAvailable :: 0
}

type HWI {
    isa ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (205)
    prop GlobalHelpTopic :: (105)
    prop dataSize :: (0 * HWI.gNumOf)
    prop localCanCreate :: (self.error("New hardware interrupt objects cannot be created"))
    prop InstancePropertyPage :: ("{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "GBL,OBJ,CLK,IDL,LCK,LOG,MBX,MEM,PIP,PRD,QUE,RTDX,SEM,STS,SYS"
    prop AllocType :: ("3\0,	_stubsAllocDesc,	_memSeg,	_placement,
		_vectAllocDesc,  	_vecSeg,	_minplace,
		_dispAllocDesc,		_dispSeg,       _minplace ")
    prop _dispAllocDesc :: ("%8t .hwi_disp_sec:     {}")
    prop _stubsAllocDesc :: ("%8t .%1L:  {} \0, name")
    prop _vectAllocDesc :: ("%8t .%1L_vec:  align = 0x100{%12t\n %1U_A_VECS = .;\n_%1U_A_VECS = . ; \n*(.hwi_vec)%8t\n }\0 , name, name")
    prop _placement :: (0x7fffff / 2)
    prop _minplace :: 0
    prop localInit :: (if (RTDX.CALLBACKOBJ != nil) {self.error("HWI initialization failure.")} , RTDX.CALLBACKOBJ = HWI)
    prop call :: (if (RTDX.USERTDX == 0) {HWI_DLOG.function = @HWI_unused, if (HWI_RTOS.function == @_RTDX_H2TPoll) {HWI_RTOS.function = @HWI_unused, HWI_RTOS.iUseDispatcher = 0} } else {HWI_DLOG.function = @_RTDX_F_isr, HWI_RTOS.function = @_RTDX_H2TPoll, HWI_RTOS.iUseDispatcher = 1})
    prop GenLinkPrologue :: (if CLK.TIMERNUM == 0 {"HWI_TINT = HWI_INT4;\n_HWI_TINT = HWI_TINT;"} else {"HWI_TINT = HWI_INT22;\n_HWI_TINT = HWI_TINT;"})
    prop _dispSeg :: MEM.BSSSEG
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: ($b = 0, scan ($a; HWI) {if ($a.monitor != "Nothing") {$b = 1} }, if ($b == 1) {"*(.hwi)"} else {"/* no HWI stubs are necessary */"})
    prop name2addr :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "xsp", "ac0g", "ac0h", "ac0l", "ac1g", "ac1h", "ac1l", "ac2g", "ac2h", "ac2l", "ac3g", "ac3h", "ac3l", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "mdp05", "mdp67", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67", "bsac", "trn1", "brc1", "csr", "rptc"}) {if ($b == nil) {if ($a == $1) {$b = {0, 0, 0x18, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x20, 0x21, 0x21, 0x23, 0x4b, 0, 0x6, 0x7, 0x4c, 0x37, 0xf, 0x19, 0x1a, 0x2e, 0x27, 0x2b, 0x2c, 0x2d, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x38, 0x39, 0x3b, 0x44}[$i]} , $i++} }, if ($b == nil) {$b = 0} , $b)
    prop name2type :: ($i = 0, $b = nil, scan ($a; {"Nothing", "Data Value", "xsp", "ac0g", "ac0h", "ac0l", "ac1g", "ac1h", "ac1l", "ac2g", "ac2h", "ac2l", "ac3g", "ac3h", "ac3l", "xar0", "xar1", "xar2", "xar3", "xar4", "xar5", "xar6", "xar7", "t0", "t1", "t2", "t3", "xssp", "tim", "st0_55", "st1_55", "st2_55", "st3_55", "trn0", "bk03", "brc0", "xdp", "xcdp", "dph", "mdp05", "mdp67", "pdp", "bk47", "bkc", "bsa01", "bsa23", "bsa45", "bsa67", "bsac", "trn1", "brc1", "csr", "rptc"}) {if ($b == nil) {if ($a == $1) {if ($i < 5) {$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]} } , $i++} }, if ($b == nil) {$b = "unsigned"} , $b)
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: -1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 32 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STUBMEMSEG :: SARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.codeMember($1)
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ZEROTAB :: = MEM.VECMEMSEG.base == 0xffff00 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Writable :: 0
        prop Visible :: 0
    }
    global VECMEMSEG :: VECT { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop MemberTest :: if GBL.DSPTYPE == 55 {($1.space != "data")} else {($1.space == "code")}
    }
    global STACKMODEL :: "C54X_STK" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "C54X_STK,USE_RETA,NO_RETA"
        prop Label :: "Stack Mode"
        prop JSName :: "STACKMODE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @HWI_unused { 
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if ((self.function == @RESERVED) || (self.client != "USER")) {0} else {1}
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (self.function = $1, GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTSObj :: HWI_RESETSTS { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst monitor :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value,xsp,ac0g,ac0h,ac0l,ac1g,ac1h,ac1l,ac2g,ac2h,ac2l,ac3g,ac3h,ac3l,xar0,xar1,xar2,xar3,xar4,xar5,xar6,xar7,t0,t1,t2,t3,xssp,tim,st0_55,st1_55,st2_55,st3_55,trn0,bk03,brc0,xdp,xcdp,dph,mdp05,mdp67,pdp,bk47,bkc,bsa01,bsa23,bsa45,bsa67,bsac,trn1,brc1,csrrptc"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((self.function != @HWI_unused && self.function != @RESERVED) && (self.iId != 0))
        prop NoGen :: 0
        prop Set :: (if ($1 != self.monitor) {$e = "ok", if ($1 == "Nothing") {if (($e = self.iSTSObj.Delete("HWI")) == "ok") {self.monitor = "Nothing", self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)} } else {if (self.iSTSObj.iIsUsed || ($e = self.iSTSObj.Create("HWI")) == "ok") {self.monitor = $1, if (self.monitor == "Data Value") {self.addr = self.saveAddr, self.dataType = self.saveType} else {self.addr = self.name2addr(self.monitor), self.dataType = self.name2type(self.monitor)}} else {self.monitor = "Nothing"}}, $e} else {"ok"})
    }
    inst saveAddr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst saveType :: "signed" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst addr :: 0 { 
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Data Value" {1} else {0})
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: if GBL.DSPTYPE == 62 {"0x%08x"} else {"0x%04x"}
        prop Set :: (self.addr = $1, self.saveAddr = $1, "ok")
    }
    inst dataType :: "signed" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (if (self.monitor != "Nothing") {self.dataType = $1, self.saveType = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst operation :: "STS_add(*addr)" { 
        prop Visible :: 1
        prop Writable :: (if self.monitor == "Nothing" {0} else {1})
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (if (self.monitor != "Nothing") {self.operation = $1, "ok"} else {self.error("The monitor field must set to modify this field")})
    }
    inst client :: "USER" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iUseDispatcher :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: if (self.client == "USER") {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if (self.function == @CLK_F_isr) {self.error("This HWI is being used by the system and cannot be modified")} else {self.iUseDispatcher = $1, "ok"})
    }
    inst iArg :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.client == "USER")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (self.iArg = $1, "ok")
    }
    inst iIer0Mask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER0"
        prop JSName :: "interruptMask0"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.Ier0Mask = 0xffff} else {if ($1 == "self") {if (self.iId < 16) {self.Ier0Mask = (1 << self.iId)} else {self.warning("This Interrupt is NOT maskable via IER0").Ier0Mask = 0}} else {if ($1 == "none") {self.Ier0Mask = 0} }}, self.iIer0Mask = $1, "ok")
    }
    inst Ier0Mask :: if (self.iId < 16) {(1 << self.iId)} else {0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER0"
        prop JSName :: "interruptBitMask0"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIer0Mask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.Ier0Mask = $1, "ok"})
    }
    inst iIer1Mask :: "self" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER1"
        prop JSName :: "interruptMask1"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: if (self.iUseDispatcher == 1) {1} else {0}
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 == "all") {self.Ier1Mask = 0xffff} else {if ($1 == "self") {if (self.iId < 16) {self.warning("This Interrupt is NOT maskable via IER1").Ier1Mask = 0} else {self.Ier1Mask = (1 << (self.iId - 16))}} else {if ($1 == "none") {self.Ier1Mask = 0} }}, self.iIer1Mask = $1, "ok")
    }
    inst Ier1Mask :: if (self.iId > 16) {(1 << (self.iId - 16))} else {0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER1"
        prop JSName :: "interruptBitMask1"
        prop Visible :: 1
        prop Writable :: if ((self.iUseDispatcher == 1) && (self.iIer1Mask == "bitmask")) {1} else {0}
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (if ($1 > 0xffff) {self.error("Invalid Number")} else {self.Ier1Mask = $1, "ok"})
    }
}

object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_c_int00
    param iSTSObj :: HWI_RESET_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 1
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_NMI_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 2
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT2_STS :: STS {
    param iComment :: "provides statistics for the INT2 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT2 :: HWI {
    param iComment :: "defines the INT2 Interrupt"
    param iIsUsed :: 1
    param iId :: 2
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT2_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 4
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT3_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT3 :: HWI {
    param iComment :: "defines the INT3 Interrupt"
    param iIsUsed :: 1
    param iId :: 3
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT3_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 8
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iIsUsed :: 1
    param iId :: 4
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @CLK_F_isr
    param iSTSObj :: HWI_INT4_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "CLK"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 16
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iIsUsed :: 1
    param iId :: 5
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT5_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 32
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT6_STS :: STS {
    param iComment :: "provide statistics for  INT6  Interrupt"
    param iIsUsed :: 0
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iIsUsed :: 1
    param iId :: 6
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT6_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 64
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iIsUsed :: 1
    param iId :: 7
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT7_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 128
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iIsUsed :: 1
    param iId :: 8
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT8_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 256
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT 9  ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT9 :: HWI {
    param iComment :: "defines the INT9  Interrupt"
    param iIsUsed :: 1
    param iId :: 9
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT9_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 512
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iIsUsed :: 1
    param iId :: 10
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT10_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 1024
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iIsUsed :: 1
    param iId :: 11
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT11_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 2048
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iIsUsed :: 1
    param iId :: 12
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT12_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 4096
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT13_STS :: STS {
    param iComment :: "provides statistics for the INT13 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iIsUsed :: 1
    param iId :: 13
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT13_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 8192
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT14_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT14 :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iIsUsed :: 1
    param iId :: 14
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT14_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 16384
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT15_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT15 :: HWI {
    param iComment :: "defines the INT15 Interrupt"
    param iIsUsed :: 1
    param iId :: 15
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT15_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 32768
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT16_STS :: STS {
    param iComment :: "provides statistics for the INT16 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT16 :: HWI {
    param iComment :: "defines the INT16 Interrupt"
    param iIsUsed :: 1
    param iId :: 16
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT16_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 0
}

object HWI_INT17_STS :: STS {
    param iComment :: "provides statistics for the INT17 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT17 :: HWI {
    param iComment :: "defines the INT17 Interrupt"
    param iIsUsed :: 1
    param iId :: 17
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT17_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 2
}

object HWI_INT18_STS :: STS {
    param iComment :: "provides statistics for the INT18 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT18 :: HWI {
    param iComment :: "defines the INT18 Interrupt"
    param iIsUsed :: 1
    param iId :: 18
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT18_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 4
}

object HWI_INT19_STS :: STS {
    param iComment :: "provides statistics for the INT19 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT19 :: HWI {
    param iComment :: "defines the INT19 Interrupt"
    param iIsUsed :: 1
    param iId :: 19
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT19_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 8
}

object HWI_INT20_STS :: STS {
    param iComment :: "provides statistics for the INT20 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT20 :: HWI {
    param iComment :: "defines the INT20 Interrupt"
    param iIsUsed :: 1
    param iId :: 20
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT20_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 16
}

object HWI_INT21_STS :: STS {
    param iComment :: "provides statistics for the INT21 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT21 :: HWI {
    param iComment :: "defines the INT21 Interrupt"
    param iIsUsed :: 1
    param iId :: 21
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT21_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 32
}

object HWI_INT22_STS :: STS {
    param iComment :: "provides statistics for the INT22 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT22 :: HWI {
    param iComment :: "defines the INT22 Interrupt"
    param iIsUsed :: 1
    param iId :: 22
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT22_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 64
}

object HWI_INT23_STS :: STS {
    param iComment :: "provides statistics for the INT23 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_INT23 :: HWI {
    param iComment :: "defines the INT23 Interrupt"
    param iIsUsed :: 1
    param iId :: 23
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_INT23_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 128
}

object HWI_BERR_STS :: STS {
    param iComment :: "provides statistics for the BERRINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_BERR :: HWI {
    param iComment :: "defines the BERR Interrupt"
    param iIsUsed :: 1
    param iId :: 24
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_BERR_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 256
}

object HWI_DLOG_STS :: STS {
    param iComment :: "provides statistics for the DLOGINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_DLOG :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iIsUsed :: 1
    param iId :: 25
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_RTDX_F_isr
    param iSTSObj :: HWI_DLOG_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "RTDX"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 512
}

object HWI_RTOS_STS :: STS {
    param iComment :: "provides statistics for the RTOSINT ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_RTOS :: HWI {
    param iComment :: "defines the RTOS Interrupt"
    param iIsUsed :: 1
    param iId :: 26
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @_RTDX_H2TPoll
    param iSTSObj :: HWI_RTOS_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 1
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 1024
}

object HWI_SINT27_STS :: STS {
    param iComment :: "provides statistics for the SINT27 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT27 :: HWI {
    param iComment :: "defines the SINT27 Interrupt"
    param iIsUsed :: 1
    param iId :: 27
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT27_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 2048
}

object HWI_SINT28_STS :: STS {
    param iComment :: "provides statistics for the SINT28 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT28 :: HWI {
    param iComment :: "defines the SINT28 Interrupt"
    param iIsUsed :: 1
    param iId :: 28
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT28_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 4096
}

object HWI_SINT29_STS :: STS {
    param iComment :: "provides statistics for the SINT29 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT29 :: HWI {
    param iComment :: "defines the SINT29 Interrupt"
    param iIsUsed :: 1
    param iId :: 29
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT29_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 8192
}

object HWI_SINT30_STS :: STS {
    param iComment :: "provides statistics for the SINT30 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT30 :: HWI {
    param iComment :: "defines the SINT30 Interrupt"
    param iIsUsed :: 1
    param iId :: 30
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT30_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 16384
}

object HWI_SINT31_STS :: STS {
    param iComment :: "provides statistics for the SINT31 ISR"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HWI"
    param iDelMsg :: "This STS object is being used by a HWI object and cannot be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

object HWI_SINT31 :: HWI {
    param iComment :: "defines the SINT31 Interrupt"
    param iIsUsed :: 1
    param iId :: 31
    param iDelUser :: "HWI"
    param iDelMsg :: "Hardware interrupt objects cannot be deleted"
    param function :: @HWI_unused
    param iSTSObj :: HWI_SINT31_STS
    param monitor :: "Nothing"
    param saveAddr :: 0
    param saveType :: "signed"
    param addr :: 0
    param dataType :: "signed"
    param operation :: "STS_add(*addr)"
    param client :: "USER"
    param iUseDispatcher :: 0
    param iArg :: 0
    param iIer0Mask :: "self"
    param Ier0Mask :: 0
    param iIer1Mask :: "self"
    param Ier1Mask :: 32768
}

type SWI {
    isa ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (211)
    prop GlobalHelpTopic :: (111)
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop STSGetMaxFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (SWI.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (SWI.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if SWI.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMax :: ($a = if (CLK.HIRES) {$1 * CLK.INSTRPERCLK} else {$1}, $a = $a * (CLK.TDDR + 1), $a)
    prop STSFilterSum :: (SWI.STSFilterMax($1))
    prop GetPriority :: (self.pri)
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x10000){%8t\n %1U_A_TABBEG = .;\n %4S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;%4t\n} > %3s%5s\0, name, objSize, memSeg, linkString, pageString")
    prop GenLinkEpilogue :: ("%0t}\n\0")
    prop linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {" PAGE 1"}}
    prop memSeg :: SWI.OBJMEMSEG
    prop objSize :: if GBL.DSPTYPE == 55 {(2 * (11 * 1))} else {(11 * 1)}
    prop maxObjs :: (32767)
    prop dataSize :: ((11 * 1) * SWI.gNumOf)
    prop localCanCreate :: (if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {"ok"})
    prop localCreate :: (STS.gNumEmbed += 1, SWI.EXECFXN = @SWI_F_exec, SWI.RUNFXN = @SWI_F_run, "ok")
    prop localDelete :: (STS.gNumEmbed -= 1, if (self.gNumOf == 1) {SWI.EXECFXN = @FXN_F_nop, SWI.RUNFXN = @FXN_F_nop} , "ok")
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: ("{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}")
    prop DependsOn :: "HWI,SIO"
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"swi.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SWI_Obj %0r;\n\0"} else {"extern SWI_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global EHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Scheduler and Return to Idle Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Configured SWI executive body"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst priority :: = (self.pri + 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
        prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst pri :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
        prop Label :: "priority"
        prop JSName :: "priority"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: ($a = self.pri, self.pri = $1, if (self == KNL_swi) {if ($1 != 0) {self.pri = $a, self.error("KNL_swi must remain at Priority 0.")} else {"ok"}} else {if ($1 == 0 && KNL_swi.iIsUsed == 1) {self.pri = $a, self.error("Priority 0 reserved for KNL_swi only.")} else {GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {self.pri = $a, self.error("System stack size (see MEM) is too small to support a new SWI priority level.")} else {if ($1 > 14) {self.pri = $a, self.error("SWI can only support 15 priority levels.")} else {"ok"}}}})
    }
    inst mailbox :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop JSName :: "mailbox"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst arg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst dorta :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
}

type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: self.USETSK
    prop IsContainedIn :: SCH
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (314)
    prop InstanceHelpTopic :: (414)
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A65-B1A8-11d0-9885-0020AFEE33C6}")
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop AllocType :: (if (self.USETSK) {"1\0,    _bssAllocDesc, _bssmemSeg, _placement"} else {""})
    prop _objAllocDesc :: ("%8t .TSK$obj: {}")
    prop _bssAllocDesc :: ("%8t .tsk: block(0x10000){%12t\n *(.tsk)%8t\n }")
    prop _bssmemSeg :: self.OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG
    prop AllocInst :: (if self.iAUTOSTK {"1\0, _instStackDesc, _instStackSeg, _placement"} else {"0\0"})
    prop _instStackDesc :: (if (GBL.DSPTYPE == 40) {"%8t .%0s$stk: fill = 0xC0FFEE {%12t\n %0s$stack = .;\n . += %1d;%8t\n }\0, _instStackSize"} else {"%8t .%0s$stk: block(0x10000){%12t\n *(.%0s$stk)%8t\n }\0"})
    prop _self :: self
    prop _instStackSize :: self.iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instsyStackSize :: self.iSYSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: self.iSTKSEG
    prop _placement :: (0x7fffff / 2)
    prop localInit :: (KNL_swi.Create("SWI"), if (self.STACKSEG.iAllocHeap == 1) {self.STACKSEG.iReqHeapCount++, "ok"} else {self.error("TSK default stack segment must be a memory segment with a heap")})
    prop HighTimeBased :: (if CLK.HIRES == 1 {1} else {0})
    prop LowTimeBased :: (if CLK.HIRES == 1 {0} else {1})
    prop STSGetMaxFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%g inst"} else {"%g ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSGetSumFmt :: (TSK.STSGetMaxFmt())
    prop STSGetAvgFmt :: (if (TSK.STSUNITS == "raw") {if CLK.HIRES {"%.2f inst"} else {"%.2f ints"}} else {if TSK.STSUNITS == "microseconds" {"%.1f us"} else {"%.2f ms"}})
    prop STSFilterMax :: ($a = if (CLK.HIRES) {$1 * CLK.INSTRPERCLK} else {$1}, $a = $a * (CLK.TDDR + 1), $a)
    prop STSFilterSum :: (TSK.STSFilterMax($1))
    prop localCreate :: (STS.gNumEmbed += 1, "ok")
    prop localCanCreate :: ($e = "ok", if (TSK.USETSK != 1) {$e = self.error("TSK manager not enabled")} , $e)
    prop localDelete :: (STS.gNumEmbed -= 1, "ok")
    prop GenLinkPrologue :: (if (self.USETSK == 0) {"_KNL_swi = 0;"} )
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"tsk.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far TSK_Obj %0r;\n\0"} else {"extern TSK_Obj %0r;\n\0"})
    prop _objId :: self.iId
    prop dataSize :: ($d = 0, scan ($i; TSK) {$d += ($i.iSTKSZ + (6 + 34) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))}, $d)
    prop minStackSize :: ($a = self.STACKSIZE, scan ($i; TSK) {if ($i.STACKSIZE < $a) {$a = $i.STACKSIZE} }, $a)
    prop maxObjs :: (32767)
    prop GetPriority :: (self.iPRI)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USETSK :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable TSK Manager"
        prop JSName :: "ENABLETSK"
        prop Visible :: 1
        prop Writable :: if GBL.DSPSUBTYPE == 0x55DA200 {0} else {1}
        prop NoGen :: 1
        prop Set :: (if ($1 == 0) {if (self.gNumOf > 1) {self.error("Cannot disable TSK until all TSK objects are deleted.")} else {self.STACKSEG.iReqHeapCount--, TSK.STACKSEG = MEM_NULL, TSK.OBJMEMSEG = MEM_NULL, TSK_idle.iSTKSEG = MEM_NULL, TSK_idle.Delete("TSK"), KNL_swi.Delete("TSK"), PRD.THOOKFXN = @FXN_F_nop, self.USETSK = $1, "ok"}} else {$e = "ok", GlobalStatus.gDirty = 1, if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {$e = self.error("Current stack size inadequate to enable TSK"), break} , scan ($a; SWI) {if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {$e = self.error("Cannot enable TSK when there are SWI objects at Priority 0."), break} }, if ($e == "ok") {TSK.STACKSEG = MEM_NULL, scan ($b; MEM) {if ($b.iAllocHeap && $b != MEM_NULL) {TSK.STACKSEG = $b, break} }, self.STACKSEG.iReqHeapCount++, self.USETSK = $1, TSK.OBJMEMSEG = SWI.OBJMEMSEG, TSK_idle.iSTKSEG = self.OBJMEMSEG, TSK_idle.Create("TSK"), KNL_swi.Create("TSK"), PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN, if (MEM.NOHEAPS) {self.STACKSEG.iReqHeapCount++, $e = "No Memory Heaps Are Allocated for Dynamic TSK creation"} , $e} else {$e}})
    }
    global OBJMEMSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "OBJMEMSEG"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global STACKSIZE :: 1024 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Default stack size (MAUs)"
        prop JSName :: "STACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global SYSTACKSIZE :: 256 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Default systack size (MAUs)"
        prop JSName :: "SYSSTACKSIZE"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global STACKSEG :: MEM_NULL { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1) && $1.iAllocHeap
        prop Label :: "Stack segment for dynamic tasks"
        prop JSName :: "STACKSEG"
        prop Visible :: 1
        prop Writable :: self.USETSK && (MEM.NOHEAPS == 0)
        prop Set :: (if (self.STACKSEG.iReqHeapCount > 0) {self.STACKSEG.iReqHeapCount--} , self.STACKSEG = $1, self.STACKSEG.iReqHeapCount++, "ok")
    }
    global PRIORITY :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "PRIORITY"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Label :: "Default task priority"
        prop Visible :: 1
        prop Writable :: self.USETSK
    }
    global CREATEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.CREATEFXN = $1, HOOK_KNL.createFxn = self.CREATEFXN, "ok")
        prop NoGen :: 1
    }
    global VCREATEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doCreate} else {self.CREATEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.DELETEFXN = $1, HOOK_KNL.deleteFxn = self.DELETEFXN, "ok")
        prop NoGen :: 1
    }
    global VDELETEFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doDelete} else {self.DELETEFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop TabName :: "Function Hooks"
        prop Set :: (self.EXITFXN = $1, HOOK_KNL.exitFxn = self.EXITFXN, "ok")
        prop NoGen :: 1
    }
    global VEXITFXN :: = if HOOK_KNL.iIsUsed == 1 {@__HOOK_doExit} else {self.EXITFXN} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global DOSWITCH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "CALLSWITCHFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOSWITCH = $1, HOOK_KNL.callSwitchFxn = self.DOSWITCH, "ok")
        prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "SWITCHFXN"
        prop Visible :: 1
        prop NoGen :: 1
        prop Writable :: self.DOSWITCH && self.USETSK
        prop Set :: (self.VSWFXN = $1, HOOK_KNL.switchFxn = self.VSWFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global SWITCHFXN :: = if self.DOSWITCH {(if HOOK_KNL.iIsUsed == 1 {@__HOOK_doSwitch} else {self.VSWFXN})} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "CALLREADYFXN"
        prop Writable :: self.USETSK
        prop Visible :: 1
        prop NoGen :: 1
        prop Set :: (self.DOREADY = $1, HOOK_KNL.callReadyFxn = self.DOREADY, "ok")
        prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "READYFXN"
        prop Visible :: 1
        prop Writable :: self.DOREADY && self.USETSK
        prop NoGen :: 1
        prop Set :: (self.VRDYFXN = $1, HOOK_KNL.readyFxn = self.VRDYFXN, "ok")
        prop TabName :: "Function Hooks"
    }
    global READYFXN :: = if self.DOREADY {(if HOOK_KNL.iIsUsed == 1 {@__HOOK_doReady} else {self.VRDYFXN})} else {0} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS :: = HOOK.gNumOf { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
    }
    global STSUNITS :: "raw" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "raw,milliseconds,microseconds"
        prop Label :: "Statistics Units"
        prop Visible :: 0
        prop Writable :: self.USETSK
        prop NoGen :: 1
    }
    global TSKTICK :: "PRD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "PRD,User"
        prop Label :: "TSK tick driven by"
        prop JSName :: "DRIVETSKTICK"
        prop Visible :: 1
        prop Writable :: self.USETSK
        prop NoGen :: 1
        prop Set :: (if ($1 != self.TSKTICK) {if ($1 == "PRD") {PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN} , if ($1 == "User") {PRD.THOOKFXN = @_FXN_F_nop} , if ($1 != "PRD" && $1 != "User") {self.error("Invalid TSK tick driver selection")} } , self.TSKTICK = $1, "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFXN :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Task function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG2 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 2"
        prop JSName :: "arg2"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG3 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 3"
        prop JSName :: "arg3"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG4 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 4"
        prop JSName :: "arg4"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG5 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 5"
        prop JSName :: "arg5"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG6 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 6"
        prop JSName :: "arg6"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iARG7 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "Task function argument 7"
        prop JSName :: "arg7"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
        prop TabName :: "Function"
    }
    inst iAUTOSTK :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Automatically allocate stack"
        prop JSName :: "autoAllocateStack"
        prop Set :: (if (($1 == 1) && (self.iAUTOSTK == 0)) {self.iSTKSZ = TSK.STACKSIZE} , self.iAUTOSTK = $1, "ok")
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "TSK" {0} else {1}
    }
    inst iMANSTK :: @null { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Manually allocated stack"
        prop JSName :: "manualStack"
        prop Visible :: 1
        prop Writable :: self.iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Stack size (MAUs)"
        prop JSName :: "stackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, self.iSTKSZ = ($1 - ($1 - 1) % 2 + 1), GlobalStatus.gDirty = 1, "ok")
    }
    inst iSYSTKSZ :: TSK.SYSTACKSIZE { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "SyStack size (MAUs)"
        prop JSName :: "sysStackSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: ($a = $1, self.iSYSTKSZ = ($1 - ($1 - 1) % 2 + 1), GlobalStatus.gDirty = 1, "ok")
    }
    inst iSTKSEG :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: $1 == MEM_NULL || MEM.dataMember($1)
        prop Label :: "Stack Memory Segment"
        prop JSName :: "stackMemSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY { 
        prop Label :: "Priority"
        prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if (self == TSK_idle) {if ($1 == 0) {"ok"} else {self.error("Cannot change the priority of the idle task.")}} else {if ($1 == 0) {self.error("Priority 0 is reserved for the system idle task")} else {self.iPRI = $1, "ok"}})
    }
    inst iENV :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Environment pointer"
        prop JSName :: "envPointer"
        prop Visible :: 1
        prop Writable :: self.iDelUser != "TSK"
        prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Don't shut down system while this task is still running"
        prop JSName :: "exitFlag"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Task Name on Target"
        prop JSName :: "allocateTaskName"
        prop Visible :: 1
        prop Writable :: 1
        prop TabName :: "Advanced"
    }
    inst iSTATREG :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%08x"
        prop Label :: "Initial Status Register value"
        prop Visible :: 0
        prop Writable :: 1
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
}

object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: @IDL_F_loop
    param iARG0 :: 0
    param iARG1 :: 0
    param iARG2 :: 0
    param iARG3 :: 0
    param iARG4 :: 0
    param iARG5 :: 0
    param iARG6 :: 0
    param iARG7 :: 0
    param iAUTOSTK :: 1
    param iMANSTK :: @null
    param iSTKSZ :: 1024
    param iSYSTKSZ :: 256
    param iSTKSEG :: MEM_NULL
    param iPRI :: 0
    param iENV :: 0
    param iEXITFLAG :: 1
    param iUSETSKNAME :: 0
    param iSTATREG :: 0
    param Order :: 0
}

object KNL_swi :: SWI {
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "TSK"
    param iDelMsg :: "This object cannot be deleted in DSP/BIOS."
    param function :: @_KNL_run
    param pri :: 0
    param mailbox :: 0
    param arg0 :: 0
    param arg1 :: 0
    param dorta :: 1
    param Order :: 0
}

type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (106)
    prop InstanceHelpTopic :: (206)
    prop InstancePropertyPage :: ("{586735F1-770B-11d0-A61F-0000C070F3E9}")
    prop GlobalPropertyPage :: ("{586735F0-770B-11d0-A61F-0000C070F3E9}")
    prop GenLinkPrologue :: ("SECTIONS {%4t\n.%1L: block(0x10000){%8t\n %1U_A_TABBEG = .;\n %3S\n %1U_A_TABEND = .;\n %1U_A_TABLEN = (. - %1U_A_TABBEG) / %2d;\0, name, _objSize, _linkString")
    prop GenLinkEpilogue :: ("%8t %1U_A_CALBEG = .;\n %4S\n %1U_A_CALEND = .;\n %1U_A_CALLEN = (. - %1U_A_CALBEG) / %2d;%4t\n} > %3s%5s%0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj")
    prop _linkString :: "*(.%1L)"
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: if GBL.DSPTYPE == 62 {""} else {if GBL.DSPTYPE == 55 {""} else {" PAGE 1"}}
    prop _nilBusyObj :: (if ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) {"IDL_busyObj = 0;\n"} else {""})
    prop _memSeg :: IDL.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * (2 * 1))} else {(2 * 1)}
    prop dataSize :: ((2 * 1) * (IDL.gNumOf + 1))
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop idlFxnSum :: ($a = 0, scan ($i; IDL) {$a += $i.cycles}, $a)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global AUTOCALCULATE :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Auto calculate idle loop instruction count"
        prop JSName :: "AUTOCALCULATE"
        prop Visible :: 1
        prop Writable :: CLK.USETIMER
        prop Set :: (if ($1 == 1 && CLK.USETIMER == 0) {self.error("CLK must be enabled to do idle loop intruction count")} else {if ($1 == 1 && GBL.ENABLEINST == 0) {self.error("Real Time Analysis must be enabled to do idle loop instuction count")} else {self.AUTOCALCULATE = $1, "ok"}})
        prop NoGen :: 1
    }
    global USECLKIDLTIME :: = IDL.AUTOCALCULATE { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global USEIDLBUSYOBJ :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALIBRFXN :: = (if (IDL.AUTOCALCULATE == 1) {if TSK.USETSK {@IDL_F_stub} else {@IDL_F_calibrate}} else {@GBL_NULL}) { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Function"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global CALIBRERROR :: = (if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {6} else {0}) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Idle Loop Auto-Calibrate Error"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LOOPOVERHEAD :: 0 { 
        prop Label :: "Idle Loop Instruction Count"
        prop JSName :: "LOOPINSTCOUNT"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: self.AUTOCALCULATE == 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
    }
    inst cycles :: 0 { 
        prop Label :: "CPU cycles"
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 1
    }
    inst calibration :: 1 { 
        prop Label :: "Include in CPU load calibration"
        prop JSName :: "calibration"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if (self.iDelUser == "USER") {1} else {0}
        prop NoGen :: 0
    }
    inst Order :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to compute CPU load and can't be deleted"
    param function :: @IDL_F_busy
    param cycles :: 0
    param calibration :: 1
    param Order :: 0
    param iPri :: 0
}

object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "IDL"
    param iDelMsg :: "This object is required to accumulate CPU load data and can't be deleted"
    param prev :: 0
    param format :: "%g"
    param unittype :: "Not time based"
    param operation :: "Nothing"
    param iA :: 1
    param iB :: 0
    param iC :: 1
    param prevhigh :: 0
    param prevlow :: 0
}

type ISRC {
    isa ObjectMgr
    prop name :: "ISRC"
    prop Label :: "ISRC - Interrupt Sources"
    prop IsConfMod :: 1
    prop Visible :: 0
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHwi :: HWI_UNUSED { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: HWI
        prop MemberTest :: 1
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
}

object Timer_0 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT4
}

object Timer_1 :: ISRC {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param iHwi :: HWI_INT22
}

type LOG {
    isa ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (207)
    prop GlobalHelpTopic :: (107)
    prop InstancePropertyPage :: ("{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}")
    prop maxObjs :: (32767)
    prop AllocType :: ("2\0, _globalAllocDesc, _memSeg, _placement, _printfAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x10000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop _printfAllocDesc :: ("%8t .printf (COPY): {}")
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _fillValue :: if GBL.DSPWORDSIZE == 16 {0xffff} else {0xffffffff}
    prop _instAllocDesc :: ("%8t /* %0s buffer */\n .%0s$buf: block(0x10000) align = 0x%1x fill = 0x%2x {}\0, _objAlign, _fillValue")
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * 10)} else {10}
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _objAlign :: if GBL.DSPTYPE == 55 {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {self.buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)}
    prop _objMemSeg :: self.bufseg
    prop LogType :: self.iType
    prop LogFormat :: self.iFormat
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"log.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far LOG_Obj %0r;\n\0"} else {"extern LOG_Obj %0r;\n\0"})
    prop dataSize :: ($d = 0, scan ($i; LOG) {if ($i.IsConfObj()) {$d += $i.buflen} , $d += 10}, $d)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ENABLED :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Compile in logging"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "bufseg"
        prop JSName :: "bufSeg"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst buflen :: 64 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "buflen (words)"
        prop JSName :: "bufLen"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (GlobalStatus.gDirty = 1, self.buflen = $1, "ok")
    }
    inst logtype :: "circular" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "circular,fixed"
        prop Label :: "logtype"
        prop JSName :: "logType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iType :: "printf" { 
        prop Label :: "datatype"
        prop JSName :: "dataType"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "printf,raw data"
        prop Visible :: 1
        prop Writable :: if self.iType == "system" {0} else {1}
        prop NoGen :: 1
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" { 
        prop Label :: "format"
        prop JSName :: "format"
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: if self.iType == "raw data" {1} else {0}
        prop NoGen :: 1
    }
}

object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "LOG"
    param iDelMsg :: "LOG_system is a system log and cannot be deleted."
    param buflen :: 64
    param logtype :: "circular"
    param iType :: "system"
    param iFormat :: "0x%x, 0x%x, 0x%x"
}

type PIP {
    isa ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (109)
    prop InstanceHelpTopic :: (209)
    prop name :: "PIP"
    prop maxObjs :: (32767)
    prop dataSize :: ($b = 0, scan ($i; PIP) {if ($i.IsConfObj()) {$b += ((6) + $i.framesize) * $i.numframes + ((50) * 2)} }, $b)
    prop InstancePropertyPage :: ("{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}")
    prop GlobalPropertyPage :: ("{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}")
    prop localCreate :: ("ok")
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x10000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop AllocInst :: ("1\0, _instAllocDesc, _objMemSeg, _placement")
    prop _instAllocDesc :: (if self.bufalign > 1 {"%8t /* %0s buffer */\n .pip%1d: block(0x10000) align = 0x%2x {}\0, _objId, _objAlign"} else {"%8t /* %0s buffer */\n .pip%1d: block(0x10000){}\0, _objId"})
    prop _placement :: (0x7fffff / 2)
    prop _objId :: self.iId
    prop _objAlign :: self.bufalign * 2
    prop _objMemSeg :: self.bufseg
    prop _linkString :: if (self.gNumOf + self.gNumEmbed) > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: ((50) * 2)
    prop mkId :: (self.iId = self.gNextId++, self.gNumOf++, self.iId)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"pip.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far PIP_Obj %0r;\n\0"} else {"extern PIP_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: 2 { 
        prop NoGen :: 0
    }
    global gNextId :: 0
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst bufseg :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
    }
    inst bufalign :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "bufAlign"
        prop Style :: 0x01 | 0x02
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 1
        prop Set :: ($e = "ok", if ($1 == 0) {$e = self.error("Cannot set align value to 0")} else {self.bufalign = $1}, $e)
    }
    inst buf :: "<NULL>" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 8 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "framesize (words)"
        prop JSName :: "frameSize"
        prop Style :: if GBL.DSPTYPE == 62 {0x02} else {0x01 | 0x02}
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("framesize must be >= 1.")} else {GlobalStatus.gDirty = 1, self.framesize = $1, "ok"})
    }
    inst numframes :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop JSName :: "numFrames"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop Set :: (if ($1 < 1) {self.error("Pipes must contain at least 1 frame.")} else {GlobalStatus.gDirty = 1, self.numframes = $1, "ok"})
    }
    inst monitor :: "reader" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "monitor"
        prop Enum :: "reader,writer,none"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyWriterArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderFxn"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg0"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: "notifyReaderArg1"
        prop Visible :: 1
        prop Writable :: (if self.iDelUser == "USER" {1} else {0})
        prop NoGen :: 0
        prop TabName :: "Notify Functions"
    }
    inst bufFrameAlign :: = self._objAlign { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (310)
    prop InstanceHelpTopic :: (410)
    prop InstancePropertyPage :: ("{D01ACC04-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC05-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .sem: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: ((14 + 6) * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sem.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SEM_Obj %0r;\n\0"} else {"extern SEM_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iCount :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Initial semaphore count"
        prop JSName :: "count"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (307)
    prop InstanceHelpTopic :: (407)
    prop InstancePropertyPage :: ("{0EB45D44-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D45-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0,	_bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .mbx: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0 _instAllocDesc, _instMemSeg, _placement")
    prop _instAllocDesc :: ("%8t .%0s$que: block(0x10000) align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize")
    prop _instMemSeg :: self.iMbxSeg
    prop _qElemSize :: (if ((GBL.DSPTYPE == 55) || (GBL.DSPTYPE == 28)) {(4 + self.iMsgSize) * self.iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * 2} else {(4 + self.iMsgSize) * self.iMbxLength * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)})
    prop dataSize :: ($d = 0, scan ($i; MBX) {$d += (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + 46)}, $d)
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"mbx.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far MBX_Obj %0r;\n\0"} else {"extern MBX_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iMsgSize :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Message Size"
        prop JSName :: "messageSize"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Message size cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMsgSize = $1, "ok"})
    }
    inst iMbxLength :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Mailbox Length"
        prop JSName :: "length"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (if ($1 == 0) {self.error("Mailbox length cannot be zero")} else {GlobalStatus.gDirty = 1, self.iMbxLength = $1, "ok"})
    }
    inst iMbxSeg :: MBX.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Element memory segment"
        prop JSName :: "elementSeg"
        prop Visible :: 1
        prop Writable :: 1
    }
}

type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (309)
    prop InstanceHelpTopic :: (409)
    prop InstancePropertyPage :: ("{D01ACC01-38DD-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{D01ACC02-38DD-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .que: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: (2 * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"que.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far QUE_Obj %0r;\n\0"} else {"extern QUE_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (306)
    prop InstanceHelpTopic :: (406)
    prop InstancePropertyPage :: ("{0EB45D40-38C1-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{0EB45D41-38C1-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .lck: block(0x10000){}")
    prop _objAllocDesc :: ("%8t .LCK$obj: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop dataSize :: ((8 + 2) * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (311)
    prop InstanceHelpTopic :: (411)
    prop InstancePropertyPage :: ("{7C4C9A60-763E-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7C4C9A61-763E-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV,UDEV,DGN,DHL,DPI"
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .SIO$bss: block(0x10000) {%12t\n *(.SIO$bss)%8t\n }")
    prop _objAllocDesc :: ("%8t .SIO$obj: block(0x10000) {%12t\n *(.SIO$obj)%8t\n }")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop AllocInst :: ("1\0, _instBufDesc, _instBufSeg, _placement")
    prop _instBufDesc :: (if self.iAlign > 1 {"%8t .%0s$bufs: block(0x10000) align = 0x%1x {}\0, _objAlign"} else {"%8t .%0s$bufs: block(0x10000) {}"})
    prop _objAlign :: self.iAlign * 2
    prop _instBufSeg :: self.iBufSegid
    prop defDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, break} }} }, $j)
    prop devList :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($j == nil && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {$j = $i, scan ($a; DIO) {if ($a == $i) {$i.numTimeUse++} }, break} }} }, $j)
    prop setDev :: ($h = nil, $i = nil, $j = nil, scan ($h; nil) {if ($h.isDriver == 1) {scan ($i; $h) {if ($i == $1) {$j = $i} }} }, $j)
    prop localCanCreate :: (if (self.defDev == nil) {self.error("A driver device must be created before creating a stream.")} else {"ok"})
    prop localDelete :: (scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, "ok")
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sio.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far SIO_Obj %0r;\n\0"} else {"extern SIO_Obj %0r;\n\0"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumEmbed :: 0 { 
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Only Issue/Reclaim Model"
        prop JSName :: "USEISSUERECLAIM"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.USEISSUERECLAIM = $1, if ($1 == 1) {scan ($i; SIO) {$i.iModelName = "Issue/Reclaim"}} , "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: SIO.devList { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop TypeTest :: $1.isDriver == 1
        prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
        prop Label :: "Device"
        prop JSName :: "deviceName"
        prop Set :: (if (($1.iIsTerminal == 0) && (self.iDevCtrlParam == "")) {self.error("To select a stacking device, enter first a terminal device in Device Control String")} else {if ($1.iIsVirtual == 1) {self.error("The device you have selected is a virtual instance, you must select a non-virtual device")} else {scan ($a; DIO) {if ($a == self.iDevice) {self.iDevice.numTimeUse--} }, scan ($b; DIO) {if ($b == $1) {$1.numTimeUse++} }, self.iDevice = self.setDev($1), "ok"}})
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevCtrlParam :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Device Control String"
        prop JSName :: "controlParameter"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iDevId :: = self.iDevice.iDevId
    inst iFxns :: = self.iDevice.iFxns
    inst iMode :: "input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "input,output"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufsize :: 0x80 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x02
        prop Label :: "Buffer size"
        prop JSName :: "bufSize"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iNbufs :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Label :: "Number of buffers"
        prop JSName :: "numBufs"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iBufSegid :: = self.OBJMEMSEG { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Place buffers in memory segment"
        prop JSName :: "bufSegId"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iAlign :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
        prop Label :: "Buffer alignment"
        prop JSName :: "bufAlign"
        prop Visible :: 1
        prop Writable :: self.iAllocBuf == 1
    }
    inst iFlush :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Flush"
        prop JSName :: "flush"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst iModelName :: "Standard" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Standard,Issue/Reclaim"
        prop Label :: "Model"
        prop JSName :: "modelName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($e = "ok", if (self.USEISSUERECLAIM == 1) {if ($1 == "Standard") {$e = self.error("SIO Issue/Reclaim model support selected")} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}} else {self.iModel = if $1 == "Standard" {"SIO_STANDARD"} else {"SIO_ISSUERECLAIM"}, self.iModelName = $1}, $e)
    }
    inst iAllocBuf :: = self.iSaveAllocBuf { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Allocate Static Buffer(s)"
        prop JSName :: "allocStaticBuf"
        prop Visible :: 1
        prop Writable :: 1
        prop Set :: (self.iSaveAllocBuf = $1, "ok")
    }
    inst iSaveAllocBuf :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
        prop Visible :: 0
        prop Writable :: 0
    }
    inst iTimeout :: = if self.iModel == "SIO_ISSUERECLAIM" {self.iSaveTimeout} else {-1} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timeout for I/O operation"
        prop JSName :: "timeout"
        prop Visible :: 1
        prop Writable :: self.iModel == "SIO_ISSUERECLAIM"
        prop Set :: (self.iSaveTimeout = $1, "ok")
    }
    inst iSaveTimeout :: -1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback function"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "callback function"
        prop JSName :: "callBackFxn"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg0 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 0"
        prop JSName :: "arg0"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
    inst arg1 :: 0 { 
        prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
        prop Label :: "argument 1"
        prop JSName :: "arg1"
        prop Visible :: 1
        prop Writable :: self.useCallBackFxn
        prop NoGen :: 0
        prop TabName :: "Callback"
    }
}

type STS {
    isa ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (212)
    prop GlobalHelpTopic :: (112)
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _placement")
    prop _globalAllocDesc :: ("%8t .%1L: block(0x10000){%12t\n  %1U_A_TABBEG = .;\n _%1U_A_TABBEG = .;\n %2S\n %1U_A_TABEND = .;\n _%1U_A_TABEND = .;\n  %1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;\n _%1U_A_TABLEN = (. - _%1U_A_TABBEG) / %3d;%8t\n }\0, name, _linkString, _objSize")
    prop localInit :: (if (PRD.CALLBACKOBJ != nil) {self.error("STS initialization failure")} , PRD.CALLBACKOBJ = STS)
    prop _placement :: (0x7fffff / 2)
    prop _linkString :: if self.gNumOf > 0 {"*(.%1L)"} else {"/* no %1U objects */"}
    prop _memSeg :: STS.OBJMEMSEG
    prop _objSize :: if GBL.DSPTYPE == 55 {(2 * (4 * 2))} else {(4 * 2)}
    prop dataSize :: ((4 * 2) * (STS.gNumOf + STS.gNumEmbed))
    prop maxObjs :: (32767)
    prop InstancePropertyPage :: ("{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}")
    prop GlobalPropertyPage :: ("{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}")
    prop STSGetMaxFmt :: (self.format)
    prop STSGetSumFmt :: (self.format)
    prop STSGetAvgFmt :: ("%.2f")
    prop STSFilterSum :: ((self.iA * $1 + self.iB * $2) / (1.0 * self.iC))
    prop STSFilterMax :: ((self.iA * $1 + self.iB) / (1.0 * self.iC))
    prop HighTimeBased :: (if self.unittype == "High resolution time based" {1} else {0})
    prop LowTimeBased :: (if self.unittype == "Low resolution time based" {1} else {0})
    prop cGen :: 1
    prop cHeaderName :: if self.gNumOf > 0 {"sts.h"} else {""}
    prop cGenHInst :: (if (GBL.DSPTYPE == 62) {"extern far STS_Obj %0r;\n\0"} else {"extern STS_Obj %0r;\n\0"})
    prop call :: (scan ($a; STS) {if ($a.unittype == "High resolution time based") {$a.iA = CLK.INSTRPERCLK * (CLK.TDDR + 1)} })
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global gNumEmbed :: -1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst prev :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (if (self.iDelUser == "USER" || self.iDelUser == "HWI") {1} else {0})
        prop JSName :: "previousVal"
        prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
        prop Set :: (self.prev = $1, self.prevlow = $1 & 0xffff, self.prevhigh = ($1 >> 16) & 0xffff, "ok")
    }
    inst format :: "%g" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 1
        prop Label :: "format"
        prop NoGen :: 1
    }
    inst unittype :: "Not time based" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Not time based,High resolution time based,Low resolution time based"
        prop Label :: "unit type"
        prop JSName :: "unitType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.unittype = $1, if ($1 == "High resolution time based") {self.iA = CLK.INSTRPERCLK * (CLK.TDDR + 1), self.iB = 0, self.iC = 1, self.operation = "A * x"} else {if ($1 == "Low resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "A * x"} else {self.iA = 1, self.iB = 0, self.iC = 1, self.operation = "Nothing"}}, "ok")
    }
    inst operation :: "Nothing" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
        prop Label :: "host operation"
        prop JSName :: "operation"
        prop Visible :: 1
        prop Writable :: (if self.unittype != "Low resolution time based" {1} else {0})
        prop NoGen :: 1
        prop Set :: (self.operation = $1, if ($1 == "Nothing" && self.unittype != "High resolution time based") {self.iA = 1, self.iB = 0, self.iC = 1} else {if ($1 == "A * x") {self.iB = 0, self.iC = 1} else {if ($1 == "A * x + B") {self.iC = 1} }}, "ok")
    }
    inst iA :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (if (self.unittype != "Not time based" || self.operation == "Nothing") {0} else {1})
        prop Label :: "A"
        prop JSName :: "numA"
        prop NoGen :: 1
    }
    inst iB :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (if (self.unittype == "Low resolution time based" || self.operation == "Nothing" || self.operation == "A * x") {0} else {1})
        prop Label :: "B"
        prop JSName :: "numB"
        prop NoGen :: 1
    }
    inst iC :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (if (self.unittype == "Not time based" && self.operation == "(A * x + B) / C") {1} else {0})
        prop Label :: "C"
        prop JSName :: "numC"
        prop NoGen :: 1
    }
    inst prevhigh :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    inst prevlow :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
}

type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1
    prop GlobalHelpTopic :: (313)
    prop InstanceHelpTopic :: (413)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop AllocType :: (if self.PUTCFXN == @_UTL_doPutc {"2\0, _globalAllocDesc,	_memSeg, _midPlace, \
	      _traceString, _traceSeg, _midPlace"} else {"1\0, _globalAllocDesc,	_memSeg, _midPlace"})
    prop _globalAllocDesc :: ("%8t .sys: block(0x10000)    {}")
    prop _traceString :: ("%8t .trace: block(0x10000) fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize")
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACESIZE :: 512 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "%d"
        prop Style :: 0x01 | 0x02
        prop Label :: "Trace Buffer Size"
        prop JSName :: "TRACESIZE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global TRACESEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Trace Buffer Memory"
        prop JSName :: "TRACESEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Abort Function"
        prop JSName :: "ABORTFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Error Function"
        prop JSName :: "ERRORFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit Function"
        prop JSName :: "EXITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Putc Function"
        prop JSName :: "PUTCFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
}

type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: self.USEGIO
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (320)
    prop InstanceHelpTopic :: (420)
    prop InstancePropertyPage :: ("{473C4A62-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{473C4A63-B1A8-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV,UDEV"
    prop AllocType :: ("1\0, _globalAllocDesc, _memSeg, _midPlace")
    prop _globalAllocDesc :: ("%8t .gio: block(0x10000)    {}")
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CALLBACKOBJ :: nil { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global USEGIO :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable General Input/Output Manager"
        prop JSName :: "ENABLEGIO"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CREATEFXN :: = if self.USEGIO == 1 {@_SEM_create} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create Function"
        prop JSName :: "CREATEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global DELETEFXN :: = if self.USEGIO == 1 {@_SEM_delete} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete Function"
        prop JSName :: "DELETEFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global PENDFXN :: = if self.USEGIO == 1 {@_SEM_pend} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Pend Function"
        prop JSName :: "PENDFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
    global POSTFXN :: = if self.USEGIO == 1 {@_SEM_post} else {@_FXN_F_nop} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Post Function"
        prop JSName :: "POSTFXN"
        prop Visible :: 1
        prop Writable :: self.USEGIO
        prop NoGen :: 0
    }
}

type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (BIOSHELP_DEV_FOLDER)
    prop GlobalPropertyPage :: ("{A2BCEC70-5365-11d4-947C-0050048381B7}")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _bssAllocDesc, _memSeg, _placement"} )
    prop _bssAllocDesc :: ("%8t .dev: block(0x10000){}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    prop DependsOn :: "HWI"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (315)
    prop InstanceHelpTopic :: (415)
    prop InstancePropertyPage :: ("{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}")
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .udev: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (if self.fxnTableType == "DEV_Fxns" {"DEV_SIOTYPE"} else {"DEV_IOMTYPE"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iInit :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "init function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iInit = $1, self.initFxn = self.iInit, "ok")
    }
    inst iFxns :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "function table ptr"
        prop JSName :: "fxnTable"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst fxnTableType :: "DEV_Fxns" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_Fxns,IOM_Fxns"
        prop Label :: "function table type"
        prop JSName :: "fxnTableType"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst driverType :: = self._driverType { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
        prop Visible :: 0
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device id"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (self.iDevId = $1, self.deviceId = self.iDevId, "ok")
    }
    inst iParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device params ptr"
        prop JSName :: "params"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst deviceId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst initFxn :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop JSName :: ""
        prop Visible :: 0
    }
    inst iIsStacking :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stacking Device"
        prop JSName :: "stackingDevice"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "device global data ptr"
        prop JSName :: "deviceGlobalDataPtr"
        prop Visible :: 1
        prop Writable :: self.fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal :: = if self.fxnTableType == "DEV_Fxns" {1} else {0} { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (302)
    prop InstanceHelpTopic :: (402)
    prop InstancePropertyPage :: ("{054FE166-B014-11d0-9885-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{054FE167-B014-11d0-9885-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dgn: block(0x10000){}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevice :: "user" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: if GBL.DSPARITHMETIC == "FLOAT" {"user,sine,random,constant,printFloat,printHex,printInt"} else {"user,sine,random,constant,printHex,printInt"}
        prop Label :: "Device category"
        prop JSName :: "device"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = $1, if ($a != self.iDevice) {self.iDevice = $a, self.iUserFxn = @_FXN_F_nop} , if ($a == "user") {self.iUserFxn = self.iSaveUserFxn} , if ($a == "printFloat") {self.iUserFxn = @_DGN_printFloat} , if ($a == "printHex") {self.iUserFxn = @_DGN_printHex} , if ($a == "printInt") {self.iUserFxn = @_DGN_printInt} , "ok")
    }
    inst iUseDefaults :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use default parameters"
        prop Visible :: 1
        prop JSName :: "useDefaultParam"
        prop Writable :: self.iDevice == "sine" || self.iDevice == "constant" || self.iDevice == "random" || self.iDevice == "user"
    }
    inst iDevId :: = if self.iDevice == "constant" {@DGN_CONST} else {if self.iDevice == "random" {@DGN_RAND} else {if self.iDevice == "sine" {@DGN_SINE} else {@DGN_USER}}} { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Device ID"
        prop JSName :: "deviceId"
        prop Visible :: 1
        prop Writable :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iConstant :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Constant value"
        prop JSName :: "constant"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "constant" || self.iDevice == "user")
    }
    inst iRandSeed :: 1 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Seed value"
        prop JSName :: "seedValue"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandLower :: if GBL.DSPARITHMETIC == "FIXED" {-32767} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Lower limit"
        prop JSName :: "lowerLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iRandUpper :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Upper limit"
        prop JSName :: "upperLimit"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "random" || self.iDevice == "user")
    }
    inst iSineGain :: if GBL.DSPARITHMETIC == "FIXED" {32767} else {1.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Gain"
        prop JSName :: "gain"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineFreq :: if GBL.DSPARITHMETIC == "FIXED" {1} else {1000.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Frequency (Hz)"
        prop JSName :: "frequency"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSinePhase :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0.0} { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: if GBL.DSPARITHMETIC == "FIXED" {0} else {0x04}
        prop Format :: if GBL.DSPARITHMETIC == "FIXED" {"%d"} else {"%f"}
        prop Label :: "Phase (radians)"
        prop JSName :: "phase"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iSineRate :: if GBL.DSPARITHMETIC == "FIXED" {256} else {44000} { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample rate (samples/sec)"
        prop JSName :: "rate"
        prop Visible :: 1
        prop Writable :: self.iUseDefaults == 0 && (self.iDevice == "sine" || self.iDevice == "user")
    }
    inst iUserFxn :: if self.iDevice == "printFloat" {@_DGN_printFloat} else {if self.iDevice == "printHex" {@_DGN_printHex} else {if self.iDevice == "printInt" {@_DGN_printInt} else {@_FXN_F_nop}}} { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function"
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
        prop Set :: (self.iUserFxn = $1, self.iSaveUserFxn = self.iUserFxn, "ok")
    }
    inst iSaveUserFxn :: @_FXN_F_nop { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iUserArg :: = 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User function argument"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: self.iDevice == "user"
    }
    inst iFxns :: @_DGN_FXNS { 
        prop NoGen :: 1
    }
}

type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    prop dataSize :: (8 + 11 * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
    prop localCanCreate :: (if (self.gChannelsAvailable > 0) {"ok"} else {self.warning("No HST channels are available for a new DHL device.")})
    prop localCreate :: (self.gChannelsAvailable--, self.seizeHSTChannel(self.iHSTChannel), "ok")
    prop seizeHSTChannel :: ($1.iDelUser = "DHL", $1.iDHLAvailable = 0, $1.notify = @_DHL_notify, $1.arg0 = $1.iId, "ok")
    prop localDelete :: (self.gChannelsAvailable++, self.releaseHSTChannel(self.iHSTChannel), "ok")
    prop releaseHSTChannel :: ($1.iDelUser = "USER", $1.iDHLAvailable = 1, $1.notify = @_FXN_F_nop, $1.arg0 = 0, "ok")
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: "%8t .dhl: block(0x10000){}"
    prop _memSeg :: self.OBJMEMSEG
    prop _placement :: (0x7fffff / 2)
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gChannelsAvailable :: 0
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iHSTChannel :: (scan ($i; HST) {if ($i.iDHLAvailable == 1) {$a = $i} }, $a) { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Underlying HST Channel"
        prop JSName :: "hstChannel"
        prop MemberType :: HST
        prop MemberTest :: (if (($1.iDHLAvailable == 1) || ($1 == self.iHSTChannel)) {1} else {0})
        prop Set :: (if ($1.iDHLAvailable != 1) {self.error("This channel is already in use.")} else {self.releaseHSTChannel(self.iHSTChannel), self.seizeHSTChannel($1), self.iHSTChannel = $1, "ok"})
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode :: = self.iHSTChannel.mode { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Mode"
        prop JSName :: "mode"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iDevId :: = (self.iHSTChannel.iId) { 
        prop NoGen :: 0
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS { 
        prop NoGen :: 1
    }
}

type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (304)
    prop InstanceHelpTopic :: (404)
    prop InstancePropertyPage :: ("{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}")
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (1)
    prop localCreate :: (self.gCurDevId += 1, "ok")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gCurDevId :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop Set :: (self.error("DPI.iDevId parameter no longer settable, it is now handled automatically"))
    }
    inst iIsVirtual :: 0 { 
        prop Label :: "Allow virtual instances of this device."
        prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (if ($1 == 1) {$a = "ok", $b = 1, scan ($i; SIO) {if ($i.iDevice == self) {$a = self.error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"), $b = 0} }, if ($b == 1) {self.iIsVirtual = 1} , $a} else {self.iIsVirtual = 0, "ok"})
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DPI_FXNS { 
        prop NoGen :: 1
    }
}

type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: ("{473C4A64-B1A8-11d0-9885-0020AFEE33C6}")
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (318)
    prop InstanceHelpTopic :: (418)
    prop localCreate :: (if (self.gNumOf == 0) {HOOK_KNL.iIsUsed = 1, self.mkId(0)} , "ok")
    prop localDelete :: (if (self.gNumOf == 2) {HOOK_KNL.iIsUsed = 0, self.rmId} , "ok")
    prop maxObjs :: (32767)
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global KNLID :: = (HOOK_KNL.Order - 1) { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst initFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Initialization function"
        prop JSName :: "initFxn"
        prop Visible :: 1
        prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Create function"
        prop JSName :: "createFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Delete function"
        prop JSName :: "deleteFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Exit function"
        prop JSName :: "exitFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call switch function"
        prop JSName :: "callSwitchFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Switch function"
        prop JSName :: "switchFxn"
        prop Visible :: 1
        prop Writable :: self.callSwitchFxn
    }
    inst callReadyFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call ready function"
        prop JSName :: "callReadyFxn"
        prop Visible :: 1
        prop Writable :: self.iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop { 
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Ready function"
        prop JSName :: "readyFxn"
        prop Visible :: 1
        prop Writable :: self.callReadyFxn
    }
    inst Order :: 2 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "order"
        prop NoGen :: 1
        prop Writable :: 1
    }
    inst iPri :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}

object HOOK_KNL :: HOOK {
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: @_FXN_F_nop
    param deleteFxn :: @_FXN_F_nop
    param exitFxn :: @_FXN_F_nop
    param callSwitchFxn :: 0
    param switchFxn :: @_FXN_F_nop
    param callReadyFxn :: 0
    param readyFxn :: @_FXN_F_nop
    param Order :: 1
    param iPri :: 0
}

type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (319)
    prop InstanceHelpTopic :: (419)
    prop InstancePropertyPage :: ("{f80273c0-3838-11d2-a32c-006097656921}")
    prop GlobalPropertyPage :: ("{050a0600-3839-11d2-a32c-006097656921}")
    prop maxObjs :: (32767)
    prop AllocType :: (if (self.gNumOf > 0) {"1\0, _globalAllocDesc, _memSeg, _placement"} )
    prop _globalAllocDesc :: ("%8t .dio: {}")
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: self.OBJMEMSEG
    prop isDriver :: (1)
    prop mdObject :: ($h = nil, $j = nil, scan ($h; UDEV) {if ($h.driverType == "DEV_IOMTYPE") {$j = $h, break} }, $j)
    prop localCanCreate :: (if (self.mdObject == nil) {self.error("An IOM type device must be created first.")} else {"ok"})
    prop numTsk :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 0) {$a = $a + $h.numTimeUse} }, $a)
    prop numSwi :: ($a = 0, $h = nil, scan ($h; DIO) {if ($h.useCallBackFxn == 1) {$a = $a + $h.numTimeUse} }, $a)
    prop functionTablePtr :: (if (self.STATIC) {if (self.useCallBackFxn) {@_DIO_cbStaticFxns} else {@_DIO_tskStaticFxns}} else {if (self.useCallBackFxn) {@_DIO_cbDynamicFxns} else {@_DIO_tskDynamicFxns}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global OBJMEMSEG :: DARAM { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
        prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global STATIC :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Create all DIO Objects Statically"
        prop JSName :: "STATICCREATE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global NUMTSKBASE :: = self.numTsk { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "TSK based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global NUMSWIBASE :: = self.numSwi { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "SWI based"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst useCallBackFxn :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "use callback version of DIO function table"
        prop JSName :: "useCallBackFxn"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst fxnsTable :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst deviceName :: self.mdObject { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: UDEV
        prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label :: "device name"
        prop JSName :: "deviceName"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst chanParams :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "channel parameters"
        prop JSName :: "chanParams"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst numTimeUse :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDevId :: 0 { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iFxns :: = self.functionTablePtr { 
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iIsTerminal :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}

type CHIPFOLDER {
    prop Label :: "CHIP - Global CSL Device Configuration"
    prop GlobalIcon :: 177
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1020
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type chipCfg {
    isa ObjectMgr
    prop name :: "CHIP"
    prop Label :: "CHIP Configuration"
    prop JSName :: "CHIP"
    prop GlobalHelpTopic :: 1021
    prop InstanceHelpTopic :: 1021
    prop GlobalIcon :: 177
    prop InstanceIcon :: 178
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: CHIPFOLDER
    prop cGen :: 1
    prop cStruct :: 0
    prop cHeaderName :: if (GBL.CHIPTYPE == "5509") {"csl_chip.h"} else {""}
    prop maxObjs :: 0
    prop NoGen :: 1
    prop address_update :: (if ((self.PP_SETUP == "Full EMIF") || (self.PP_SETUP == "Non-Multiplexed EHPI")) {0} else {1})
    prop XBSR_VALUE_update :: (self.SP2_VALUE | self.SP1_VALUE | self.PP_VALUE)
    prop SP2_VALUE :: (if (self.SP2_SETUP == "McBSP2") {0x0000} else {if (self.SP2_SETUP == "MMC/SD2") {0x0010} else {0x0030}})
    prop SP1_VALUE :: (if (self.SP1_SETUP == "McBSP1") {0x0000} else {if (self.SP1_SETUP == "MMC/SD1") {0x0004} else {0x000c}})
    prop PP_VALUE :: (if (self.PP_SETUP == "Data EMIF") {0x0000} else {if (self.PP_SETUP == "Full EMIF") {0x0001} else {if (self.PP_SETUP == "Non-Multiplexed EHPI") {0x0002} else {0x0003}}})
    prop xbsrValue :: self.XBSR_VALUE
    prop xbsrStr :: if ((chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")) {"\nCHIP_RSET(XBSR, %1d);\n"} else {""}
    prop cGenFxnPrologue :: ("%5t%2S%0t\0, xbsrValue,xbsrStr")
    prop chipInclStr :: if ((chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")) {"#include <csl_chiphal.h>\n"} else {""}
    prop cGenCPrologue :: ("%1S\n\0, chipInclStr")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global ADDRESS :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Address Signals Used "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global CHIP_CFG_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Settings"
    }
    global SP2_SETUP :: "McBSP2" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "McBSP2,MMC/SD2,Memory Stick2"
        prop Label :: "Serial Port2 Mode"
        prop JSName :: "chipXbsrSp2Mode"
        prop Visible :: 1
        prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Settings"
        prop Set :: (self.SP2_SETUP = $1, self.XBSR_VALUE = self.XBSR_VALUE_update(), "ok")
    }
    global SP1_SETUP :: "McBSP1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "McBSP1,MMC/SD1,Memory Stick1"
        prop Label :: "Serial Port1 Mode"
        prop JSName :: "chipXbsrSp1Mode"
        prop Visible :: 1
        prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Settings"
        prop Set :: (self.SP1_SETUP = $1, self.XBSR_VALUE = self.XBSR_VALUE_update(), "ok")
    }
    global PP_SETUP :: "Data EMIF" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data EMIF,Full EMIF,Non-Multiplexed EHPI,Multiplexed EHPI"
        prop Label :: "Parallel Port Mode "
        prop JSName :: "chipXbsrPPMode"
        prop Visible :: 1
        prop Writable :: (chipCfg.CHIP_CFG_ENABLE) && (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Settings"
        prop Set :: (self.PP_SETUP = $1, self.XBSR_VALUE = self.XBSR_VALUE_update(), self.ADDRESS = self.address_update(), "ok")
    }
    global XBSR_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "External Bus Selection Register "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type DMAFOLDER {
    prop Label :: "DMA - Direct Memory Access Controller"
    prop GlobalIcon :: 157
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1030
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type dmaCfg {
    isa ObjectMgr
    prop name :: "DMA"
    prop Label :: "DMA Configuration Manager"
    prop JSName :: "DMA"
    prop GlobalHelpTopic :: 1031
    prop InstanceHelpTopic :: 1031
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: DMAFOLDER
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "DMA_Config"
    prop cHeaderName :: if ((self.gNumOf > 0) || (hDMA.gDMAconfig == 1)) {"csl_dma.h"} else {""}
    prop NoGen :: 1
    prop PG2_MODE :: ((hDMA.MODE_SETUP == "Independent index for src/dst"))
    prop PG1_MODE :: ((hDMA.MODE_SETUP == "Same index for src/dst"))
    prop CEI_SUPPORT :: ((GBL.CHIPTYPE == "5509") || (GBL.CHIPTYPE == "5510") || (GBL.CHIPTYPE == "5510PG1_0") || (GBL.CHIPTYPE == "5510PG1_2") || (((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG1_MODE)))
    prop CFI_SUPPORT :: ((GBL.CHIPTYPE == "5509") || (GBL.CHIPTYPE == "5510") || (GBL.CHIPTYPE == "5510PG1_0") || (GBL.CHIPTYPE == "5510PG1_2") || (((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG1_MODE)))
    prop CSFI_SUPPORT :: ((((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG2_MODE)))
    prop CSEI_SUPPORT :: ((((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG2_MODE)))
    prop CDFI_SUPPORT :: ((((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG2_MODE)))
    prop CDEI_SUPPORT :: ((((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2") || (GBL.CHIPTYPE == "5502")) && (dmaCfg.PG2_MODE)))
    prop DATA_TYPE_CSDP :: (if (self.DATA_TYPE_SETUP == "8-bit") {0x0000} else {if (self.DATA_TYPE_SETUP == "16-bit") {0x0001} else {0x0002}})
    prop SRC_BEN_CSDP :: (if (self.SRC_BEN_SETUP == "Single Access (No Burst)") {0x0000} else {0x0100})
    prop SRC_PACK_CSDP :: (if (self.SRC_PACK_SETUP == "Packed Accesses") {0x0040} else {0x0000})
    prop SRC_AMODE_CCR :: (if (self.SRC_AMODE_SETUP == "Constant") {0x0000} else {if (self.SRC_AMODE_SETUP == "Post-incremented") {0x1000} else {if (self.SRC_AMODE_SETUP == "Single index") {0x2000} else {0x3000}}})
    prop SRC_CSDP :: (if (self.SRC_SETUP == "SARAM") {0x0000} else {if (self.SRC_SETUP == "DARAM") {0x0004} else {if (self.SRC_SETUP == "EMIF") {0x0008} else {0x000C}}})
    prop DST_BEN_CSDP :: (if (self.DST_BEN_SETUP == "Single Access (No Burst)") {0x0000} else {0x8000})
    prop DST_PACK_CSDP :: (if (self.DST_PACK_SETUP == "Packed Accesses") {0x2000} else {0x0000})
    prop DST_AMODE_CCR :: (if (self.DST_AMODE_SETUP == "Constant") {0x0000} else {if (self.DST_AMODE_SETUP == "Post-incremented") {0x4000} else {if (self.DST_AMODE_SETUP == "Single index") {0x8000} else {0xC000}}})
    prop DST_CSDP :: (if (self.DST_SETUP == "SARAM") {0x0000} else {if (self.DST_SETUP == "DARAM") {0x0200} else {if (self.DST_SETUP == "EMIF") {0x0400} else {0x0600}}})
    prop SYNC_CCR :: (if (self.SYNC_SETUP == "No Event") {0x0000} else {if (self.SYNC_SETUP == "McBSP 0 Receive Event (REVT0)") {0x0001} else {if (self.SYNC_SETUP == "McBSP 0 Transmit Event (XEVT0)") {0x0002} else {if (self.SYNC_SETUP == "McBSP 0 Receive EventA (REVTA0)") {0x0003} else {if (self.SYNC_SETUP == "McBSP 0 Transmit EventA (XEVTA0)") {0x0004} else {if (self.SYNC_SETUP == "McBSP 1 Receive Event (REVT1)") {0x0005} else {if (self.SYNC_SETUP == "McBSP 1 Transmit Event (XEVT1)") {0x0006} else {if (self.SYNC_SETUP == "McBSP 1 Receive EventA (REVTA1)") {0x0007} else {if (self.SYNC_SETUP == "McBSP 1 Transmit EventA (XEVTA1)") {0x0008} else {if (self.SYNC_SETUP == "McBSP 2 Receive Event (REVT2)") {0x0009} else {if (self.SYNC_SETUP == "McBSP 2 Transmit Event (XEVT2)") {0x000A} else {if (self.SYNC_SETUP == "McBSP 2 Receive EventA (REVTA2)") {0x000B} else {if (self.SYNC_SETUP == "McBSP 2 Transmit EventA (XEVTA2)") {0x000C} else {if (self.SYNC_SETUP == "Timer 1 Interrupt") {0x000D} else {if (self.SYNC_SETUP == "Timer 2 Interrupt") {0x000E} else {if (self.SYNC_SETUP == "External Interrupt 0") {0x000F} else {if (self.SYNC_SETUP == "External Interrupt 1") {0x0010} else {if (self.SYNC_SETUP == "External Interrupt 2") {0x0011} else {if (self.SYNC_SETUP == "External Interrupt 3") {0x0012} else {if (self.SYNC_SETUP == "External Interrupt 4") {0x0013} else {0x0014}}}}}}}}}}}}}}}}}}}})
    prop REPEAT_CCR :: (if (self.REPEAT_SETUP == "Unconditionally") {0x0200} else {0x0000})
    prop END_PROG_CCR :: (if (self.END_PROG_SETUP == "Allow re-initialization") {0x0800} else {0x0000})
    prop FS_CCR :: (if (self.FS_SETUP == "Enabled") {0x0020} else {0x0000})
    prop PRIO_CCR :: (if (self.PRIO_SETUP == "High") {0x0040} else {0x0000})
    prop EN_CCR :: (if (self.EN_SETUP == "Enabled") {0x0080} else {0x0000})
    prop AUTO_INIT_CCR :: (if (self.AUTO_INIT_SETUP == "Enabled") {0x0100} else {0x0000})
    prop TIMEOUT_IE_CICR :: (if (self.TIMEOUT_IE_SETUP == "Enabled") {0x0001} else {0x0000})
    prop DROP_IE_CICR :: (if (self.DROP_IE_SETUP == "Enabled") {0x0002} else {0x0000})
    prop HALF_IE_CICR :: (if (self.HALF_IE_SETUP == "Enabled") {0x0004} else {0x0000})
    prop FRAME_IE_CICR :: (if (self.FRAME_IE_SETUP == "Enabled") {0x0008} else {0x0000})
    prop LAST_IE_CICR :: (if (self.LAST_IE_SETUP == "Enabled") {0x0010} else {0x0000})
    prop BLOCK_IE_CICR :: (if (self.BLOCK_IE_SETUP == "Enabled") {0x0020} else {0x0000})
    prop CSDP_VALUE_update :: (self.DATA_TYPE_CSDP() | self.SRC_CSDP() | self.SRC_PACK_CSDP() | self.SRC_BEN_CSDP() | self.DST_CSDP() | self.DST_PACK_CSDP() | self.DST_BEN_CSDP())
    prop CCR_VALUE_update :: (self.SYNC_CCR() | self.FS_CCR() | self.PRIO_CCR() | self.EN_CCR() | self.AUTO_INIT_CCR() | self.REPEAT_CCR() | self.END_PROG_CCR() | self.SRC_AMODE_CCR() | self.DST_AMODE_CCR())
    prop CICR_VALUE_update :: (self.TIMEOUT_IE_CICR() | self.DROP_IE_CICR() | self.HALF_IE_CICR() | self.FRAME_IE_CICR() | self.LAST_IE_CICR() | self.BLOCK_IE_CICR())
    prop CEN_VALUE_update :: (self.CEN_SETUP)
    prop CFN_VALUE_update :: (self.CFN_SETUP)
    prop CFI_VALUE_update :: (self.CFI_SETUP)
    prop CEI_VALUE_update :: (self.CEI_SETUP)
    prop CSDP_SETUP_update :: (self.DATA_TYPE_SETUP = ($a = $1 & 0x0003, if ($a == 0x0002) {"32-bit"} else {if ($a == 0x0001) {"16-bit"} else {"8-bit"}}), self.SRC_SETUP = ($a = $1 & 0x000C, if ($a == 0x000C) {"Peripheral Bus"} else {if ($a == 0x0008) {"EMIF"} else {if ($a == 0x0004) {"DARAM"} else {"SARAM"}}}), self.SRC_PACK_SETUP = if ($1 & 0x0040) {"Packed Accesses"} else {"No Packed Accesses"}, self.SRC_BEN_SETUP = ($a = $1 & 0x0180, if ($a == 0x0100) {"Burst of 4"} else {"Single Access (No Burst)"}), self.DST_SETUP = ($a = $1 & 0x0600, if ($a == 0x0600) {"Peripheral Bus"} else {if ($a == 0x0400) {"EMIF"} else {if ($a == 0x0200) {"DARAM"} else {"SARAM"}}}), self.DST_PACK_SETUP = if ($1 & 0x2000) {"Packed Accesses"} else {"No Packed Accesses"}, self.DST_BEN_SETUP = ($a = $1 & 0xC000, if ($1 & 0x8000) {"Burst of 4"} else {"Single Access (No Burst)"}))
    prop CCR_SETUP_update :: (self.SYNC_SETUP = ($a = $1 & 0x001F, if ($a == 0x0001) {"McBSP 0 Receive Event (REVT0)"} else {if ($a == 0x0002) {"McBSP 0 Transmit Event (XEVT0)"} else {if ($a == 0x0003) {"McBSP 0 Receive EventA (REVTA0)"} else {if ($a == 0x0004) {"McBSP 0 Transmit EventA (XEVTA0)"} else {if ($a == 0x0005) {"McBSP 1 Receive Event (REVT1)"} else {if ($a == 0x0006) {"McBSP 1 Transmit Event (XEVT1)"} else {if ($a == 0x0007) {"McBSP 1 Receive EventA (REVTA1)"} else {if ($a == 0x0008) {"McBSP 1 Transmit EventA (XEVTA1)"} else {if ($a == 0x0009) {"McBSP 2 Receive Event (REVT2)"} else {if ($a == 0x000A) {"McBSP 2 Transmit Event (XEVT2)"} else {if ($a == 0x000B) {"McBSP 2 Receive EventA (REVTA2)"} else {if ($a == 0x000C) {"McBSP 2 Transmit EventA (XEVTA2)"} else {if ($a == 0x000D) {"Timer 1 Interrupt"} else {if ($a == 0x000E) {"Timer 2 Interrupt"} else {if ($a == 0x000F) {"External Interrupt 0"} else {if ($a == 0x0010) {"External Interrupt 1"} else {if ($a == 0x0011) {"External Interrupt 2"} else {if ($a == 0x0012) {"External Interrupt 3"} else {if ($a == 0x0013) {"External Interrupt 4"} else {if ($a == 0x0014) {"External Interrupt 5"} else {"No Event"}}}}}}}}}}}}}}}}}}}}), self.FS_SETUP = if ($1 & 0x0020) {"Enabled"} else {"Disabled"}, self.PRIO_SETUP = if ($1 & 0x0040) {"High"} else {"Low"}, self.EN_SETUP = if ($1 & 0x0080) {"Enabled"} else {"Disabled"}, self.AUTO_INIT_SETUP = if ($1 & 0x0100) {"Enabled"} else {"Disabled"}, self.REPEAT_SETUP = if ($1 & 0x0200) {"Unconditionally"} else {"Only if END PROG = 1"}, self.END_PROG_SETUP = if ($1 & 0x0800) {"Allow re-initialization"} else {"Delay re-initialization"}, self.SRC_AMODE_SETUP = ($a = $1 & 0x3000, if ($a == 0x1000) {"Post-incremented"} else {if ($a == 0x2000) {"Single index"} else {if ($a == 0x3000) {"Double index"} else {"Constant"}}}), self.DST_AMODE_SETUP = ($a = $1 & 0x0C000, if ($a == 0x4000) {"Post-incremented"} else {if ($a == 0x8000) {"Single index"} else {if ($a == 0xC000) {"Double index"} else {"Constant"}}}))
    prop CICR_SETUP_update :: (self.TIMEOUT_IE_SETUP = if ($1 & 0x0001) {"Enabled"} else {"Disabled"}, self.DROP_IE_SETUP = if ($1 & 0x0002) {"Enabled"} else {"Disabled"}, self.HALF_IE_SETUP = if ($1 & 0x0004) {"Enabled"} else {"Disabled"}, self.FRAME_IE_SETUP = if ($1 & 0x0008) {"Enabled"} else {"Disabled"}, self.LAST_IE_SETUP = if ($1 & 0x0010) {"Enabled"} else {"Disabled"}, self.BLOCK_IE_SETUP = if ($1 & 0x0020) {"Enabled"} else {"Disabled"})
    prop CSSAL_HC_SETUP_update :: (self.CSSA_HC_SETUP &= 0x00000000, self.CSSA_HC_SETUP |= $1)
    prop CSSAU_HC_SETUP_update :: (self.CSSA_HC_SETUP &= 0x0000FFFF, self.CSSA_HC_SETUP |= $1 << 16)
    prop CDSAL_HC_SETUP_update :: (self.CDSA_HC_SETUP &= 0x00000000, self.CDSA_HC_SETUP |= $1)
    prop CDSAU_HC_SETUP_update :: (self.CDSA_HC_SETUP &= 0x0000FFFF, self.CDSA_HC_SETUP |= $1 << 16)
    prop CEN_SETUP_update :: (self.CEN_SETUP = $1)
    prop CFN_SETUP_update :: (self.CFN_SETUP = $1)
    prop CFI_SETUP_update :: (self.CFI_SETUP = $1)
    prop CEI_SETUP_update :: (self.CEI_SETUP = $1)
    prop srcSym :: if ((self.srcAddrFormat == "Symbolic") && (self.CSSAL_SYM_VALUE != "NULL")) {self.CSSAL_SYM_VALUE} else {""}
    prop dstSym :: if ((self.dstAddrFormat == "Symbolic") && (self.CDSAL_SYM_VALUE != "NULL")) {self.CDSAL_SYM_VALUE} else {""}
    prop externStr :: if (((self.dstAddrFormat == "Symbolic") && (self.CDSAL_SYM_VALUE != "NULL")) || ((self.srcAddrFormat == "Symbolic") && (self.CSSAL_SYM_VALUE != "NULL"))) {"extern Uint16 "} else {""}
    prop srcStr :: if ((self.srcAddrFormat == "Symbolic") && (self.CSSAL_SYM_VALUE != "NULL")) {"%5s"} else {""}
    prop comma :: if ((self.dstAddrFormat == "Symbolic") && (self.CDSAL_SYM_VALUE != "NULL") && (self.srcAddrFormat == "Symbolic") && (self.CSSAL_SYM_VALUE != "NULL") && (self.CDSAL_SYM_VALUE != self.CSSAL_SYM_VALUE)) {", "} else {""}
    prop dstStr :: if ((self.dstAddrFormat == "Symbolic") && (self.CDSAL_SYM_VALUE != "NULL") && (self.CDSAL_SYM_VALUE != self.CSSAL_SYM_VALUE)) {"%6s"} else {""}
    prop termStr :: if (((self.dstAddrFormat == "Symbolic") && (self.CDSAL_SYM_VALUE != "NULL")) || ((self.srcAddrFormat == "Symbolic") && (self.CSSAL_SYM_VALUE != "NULL"))) {";\n"} else {""}
    prop cGenCInst :: ("%1S%2S%3S%4S%7S\n\0, externStr,srcStr,comma,dstStr,srcSym,dstSym,termStr")
    prop cssalSymbol :: self.CSSAL_SYM_VALUE
    prop cssauSymbol :: self.CSSA_SYM_SETUP
    prop cdsalSymbol :: self.CDSAL_SYM_VALUE
    prop cdsauSymbol :: self.CDSA_SYM_SETUP
    prop configStruct :: self
    prop pdmcssalShift :: if ((self.srcAddrFormat == "Symbolic") && (self.SRC_SPACE_SETUP == "Program Space") && (self.CSSAL_SYM_VALUE != "NULL")) {"%5t%9s.dmacssal = (DMA_AdrPtr)((Uint32)(&%10s) & 0xFFFF);\n%0t"} else {""}
    prop ddmcssalShift :: if ((self.srcAddrFormat == "Symbolic") && (self.SRC_SPACE_SETUP == "Data Space") && (self.CSSAL_SYM_VALUE != "NULL")) {"%5t%9s.dmacssal = (DMA_AdrPtr)(((Uint32)(&%10s) << 1) & 0xFFFF);\n%0t"} else {""}
    prop pdmcssauShift :: if ((self.srcAddrFormat == "Symbolic") && (self.SRC_SPACE_SETUP == "Program Space") && (self.CSSA_SYM_SETUP != "NULL")) {"%5t%9s.dmacssau = (Uint16)((Uint32)(&%11s) >> 16);\n%0t"} else {""}
    prop ddmcssauShift :: if ((self.srcAddrFormat == "Symbolic") && (self.SRC_SPACE_SETUP == "Data Space") && (self.CSSA_SYM_SETUP != "NULL")) {"%5t%9s.dmacssau = (Uint16)((Uint32)(&%11s) >> 15);\n%0t"} else {""}
    prop pdmcdsalShift :: if ((self.dstAddrFormat == "Symbolic") && (self.DST_SPACE_SETUP == "Program Space") && (self.CDSAL_SYM_VALUE != "NULL")) {"%5t%9s.dmacdsal = (DMA_AdrPtr)((Uint32)(&%12s) & 0xFFFF);\n%0t"} else {""}
    prop ddmcdsalShift :: if ((self.dstAddrFormat == "Symbolic") && (self.DST_SPACE_SETUP == "Data Space") && (self.CDSAL_SYM_VALUE != "NULL")) {"%5t%9s.dmacdsal = (DMA_AdrPtr)(((Uint32)(&%13s) << 1) & 0xFFFF);\n%0t"} else {""}
    prop pdmcdsauShift :: if ((self.dstAddrFormat == "Symbolic") && (self.DST_SPACE_SETUP == "Program Space") && (self.CDSA_SYM_SETUP != "NULL")) {"%5t%9s.dmacdsau = (Uint16)((Uint32)(&%13s) >> 16);\n%0t"} else {""}
    prop ddmcdsauShift :: if ((self.dstAddrFormat == "Symbolic") && (self.DST_SPACE_SETUP == "Data Space") && (self.CDSA_SYM_SETUP != "NULL")) {"%5t%9s.dmacdsau = (Uint16)((Uint32)(&%13s) >> 15);\n%0t"} else {""}
    prop cGenFxnPreInst :: ("%1S%2S%3S%4S%5S%6S%7S%8S\0, pdmcssalShift,ddmcssalShift,pdmcssauShift,ddmcssauShift,pdmcdsalShift,ddmcdsalShift,pdmcdsauShift,ddmcdsauShift,configStruct,cssalSymbol,cssauSymbol,cdsalSymbol,cdsauSymbol")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst DATA_TYPE_SETUP :: "8-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit,16-bit,32-bit"
        prop JSName :: "dmaCsdpDataType"
        prop Label :: "DATA TYPE"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
        prop Set :: (self.DATA_TYPE_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst SRC_BEN_SETUP :: "Single Access (No Burst)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Access (No Burst),Burst of 4"
        prop JSName :: "dmaCsdpSrcBen"
        prop Label :: "Burst Enable (SRC BEN)"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRC_BEN_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst SRC_PACK_SETUP :: "No Packed Accesses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Packed Accesses,Packed Accesses"
        prop Label :: "Packing (SRC PACK)"
        prop JSName :: "dmaCsdpSrcPack"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRC_PACK_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst SRC_SPACE_SETUP :: "Data Space" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Source Space"
        prop JSName :: "dmaSrcSpace"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRC_SPACE_SETUP = $1, self.SRC_SPACE_ADSETUP = $1, "ok")
    }
    inst srcAddrFormat :: "Symbolic" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Source Address Format"
        prop JSName :: "dmaSrcAddrFormat"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.srcAddrFormat = $1, self.srcAddrFormatAd = $1, "ok")
    }
    inst CSSA_HC_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "Start Address (CSSA) - Numeric(Byte Address)"
        prop JSName :: "dmaCssaNumeric"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (self.srcAddrFormat == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.CSSA_HC_SETUP = $1, self.CSSAL_HC_VALUE = $1, self.CSSAU_HC_VALUE = (($1 >> 16) & 0xFFFF), "ok")
    }
    inst CSSA_SYM_SETUP :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Address (CSSA) - Symbolic(Byte Address)"
        prop JSName :: "dmaCssaSymbolic"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (self.srcAddrFormat == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.CSSA_SYM_SETUP = $1, self.CSSAL_SYM_VALUE = $1, "ok")
    }
    inst SRC_AMODE_SETUP :: "Constant" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Constant,Post-incremented,Single index,Double index"
        prop JSName :: "dmaCcrSrcAmode"
        prop Label :: "Addressing Mode (SRC AMODE)"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRC_AMODE_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst SRC_SETUP :: "SARAM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SARAM,DARAM,EMIF,Peripheral Bus"
        prop Label :: "Transfer Source (SRC)"
        prop JSName :: "dmaCsdpSrc"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.SRC_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst CSEI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Element index (CSEI) "
        prop JSName :: "dmaCeiSrc"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (dmaCfg.CSEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.CSEI_SETUP = $1, self.CSEI_VALUE = self.CSEI_SETUP, "ok")
    }
    inst CSFI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Source Frame index (CSFI) "
        prop JSName :: "dmaCfiSrc"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (dmaCfg.CSFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Source"
        prop Set :: (self.CSFI_SETUP = $1, self.CSFI_VALUE = self.CSFI_SETUP, "ok")
    }
    inst DST_BEN_SETUP :: "Single Access (No Burst)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single Access (No Burst),Burst of 4"
        prop Label :: "Burst Enable (DST BEN)"
        prop JSName :: "dmaCsdpDstBen"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DST_BEN_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst DST_PACK_SETUP :: "No Packed Accesses" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Packed Accesses,Packed Accesses"
        prop Label :: "Packing (DST PACK)"
        prop JSName :: "dmaCsdpDstPack"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DST_PACK_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst DST_SPACE_SETUP :: "Data Space" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Destination Space"
        prop JSName :: "dmaDstSpace"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DST_SPACE_SETUP = $1, self.DST_SPACE_ADSETUP = $1, "ok")
    }
    inst dstAddrFormat :: "Symbolic" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Destination Address Format"
        prop JSName :: "dmaDstAddrFormat"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.dstAddrFormat = $1, self.dstAddrFormatAd = $1, "ok")
    }
    inst CDSA_HC_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "Start Address (CDSA) - Numeric(Byte Address)"
        prop JSName :: "dmaCdsaNumeric"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (self.dstAddrFormat == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.CDSA_HC_SETUP = $1, self.CDSAL_HC_VALUE = $1, self.CDSAU_HC_VALUE = (($1 >> 16) & 0xFFFF), "ok")
    }
    inst CDSA_SYM_SETUP :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Address (CDSA) - Symbolic(Byte Address)"
        prop JSName :: "dmaCdsaSymbolic"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man) && (self.dstAddrFormat == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.CDSA_SYM_SETUP = $1, self.CDSAL_SYM_VALUE = $1, "ok")
    }
    inst DST_AMODE_SETUP :: "Constant" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Constant,Post-incremented,Single index,Double index"
        prop Label :: "Addressing Mode (DST AMODE)"
        prop JSName :: "dmaCcrDstAmode"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DST_AMODE_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst DST_SETUP :: "SARAM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "SARAM,DARAM,EMIF,Peripheral Bus"
        prop Label :: "Transfer Destination (DST)"
        prop JSName :: "dmaCsdpDst"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.DST_SETUP = $1, self.CSDP_VALUE = self.CSDP_VALUE_update(), "ok")
    }
    inst CDEI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Element index (CDEI) "
        prop JSName :: "dmaCeiDst"
        prop Visible :: 1
        prop Writable :: (!(self.DMA_man)) && (dmaCfg.CDEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.CDEI_SETUP = $1, self.CDEI_VALUE = self.CDEI_SETUP, "ok")
    }
    inst CDFI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Destination Frame index (CDFI) "
        prop JSName :: "dmaCfiDst"
        prop Visible :: 1
        prop Writable :: (!(self.DMA_man)) && (dmaCfg.CDFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Destination"
        prop Set :: (self.CDFI_SETUP = $1, self.CDFI_VALUE = self.CDFI_SETUP, "ok")
    }
    inst SYNC_SETUP :: "No Event" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Event,McBSP 0 Receive Event (REVT0),McBSP 0 Transmit Event (XEVT0),McBSP 0 Receive EventA (REVTA0),McBSP 0 Transmit EventA (XEVTA0),McBSP 1 Receive Event (REVT1),McBSP 1 Transmit Event (XEVT1),McBSP 1 Receive EventA (REVTA1),McBSP 1 Transmit EventA (XEVTA1),McBSP 2 Receive Event (REVT2),McBSP 2 Transmit Event (XEVT2),McBSP 2 Receive EventA (REVTA2),McBSP 2 Transmit EventA (XEVTA2),Timer 1 Interrupt,Timer 2 Interrupt,External Interrupt 0,External Interrupt 1,External Interrupt 2,External Interrupt 3,External Interrupt 4,External Interrupt 5"
        prop Label :: "Sync Event (SYNC)"
        prop JSName :: "dmaCcrSync"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.SYNC_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst REPEAT_SETUP :: "Only if END PROG = 1" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Only if END PROG = 1,Unconditionally"
        prop Label :: "Repetitive Operations (REPEAT)"
        prop JSName :: "dmaCcrRepeat"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.REPEAT_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst END_PROG_SETUP :: "Delay re-initialization" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Delay re-initialization,Allow re-initialization"
        prop Label :: "End of Programmation (END PROG)"
        prop JSName :: "dmaCcrEndProg"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.END_PROG_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst FS_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Frame Synchronization (FS)"
        prop JSName :: "dmaCcrFs"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.FS_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst PRIO_SETUP :: "Low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High"
        prop Label :: "Channel Priority (PRIO)"
        prop JSName :: "dmaCcrPrio"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.PRIO_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst EN_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Channel Enable (EN)"
        prop JSName :: "dmaCcrEn"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.EN_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst AUTO_INIT_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Auto-initialization (AUTO INIT)"
        prop JSName :: "dmaCcrAutoinit"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Control"
        prop Set :: (self.AUTO_INIT_SETUP = $1, self.CCR_VALUE = self.CCR_VALUE_update(), "ok")
    }
    inst TIMEOUT_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Timeout (TIMEOUT IE)"
        prop JSName :: "dmaCicrTimeoutIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.TIMEOUT_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst DROP_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Synchronization event drop (DROP IE)"
        prop JSName :: "dmaCicrDropIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.DROP_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst HALF_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Half frame (HALF IE)"
        prop JSName :: "dmaCicrHalfIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.HALF_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst FRAME_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Frame complete (FRAME IE)"
        prop JSName :: "dmaCicrFrameIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.FRAME_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst LAST_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Last frame (LAST IE)"
        prop JSName :: "dmaCicrLastIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.LAST_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst BLOCK_IE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "End block (BLOCK IE)"
        prop JSName :: "dmaCicrBlockIe"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Interrupts"
        prop Set :: (self.BLOCK_IE_SETUP = $1, self.CICR_VALUE = self.CICR_VALUE_update(), "ok")
    }
    inst CEN_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Number of Elements (CEN)"
        prop JSName :: "dmaCen"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
        prop Set :: (if (($1 > 0) && ($1 < 65536)) {self.CEN_SETUP = $1, self.CEN_VALUE = self.CEN_SETUP, "ok"} else {self.error("Entered value exceeds limits")})
    }
    inst CFN_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Number of Frames (CFN)"
        prop JSName :: "dmaCfn"
        prop Visible :: 1
        prop Writable :: !(self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Frame"
        prop Set :: (if (($1 > 0) && ($1 < 65536)) {self.CFN_SETUP = $1, self.CFN_VALUE = self.CFN_SETUP, "ok"} else {self.error("Entered value exceeds limits")})
    }
    inst CFI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame index (CFI) "
        prop JSName :: "dmaCfi"
        prop Visible :: 1
        prop Writable :: (!(self.DMA_man)) && (dmaCfg.CFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Frame"
        prop Set :: (self.CFI_SETUP = $1, self.CFI_VALUE = self.CFI_SETUP, "ok")
    }
    inst CEI_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Element index (CEI) "
        prop JSName :: "dmaCei"
        prop Visible :: 1
        prop Writable :: (!(self.DMA_man)) && (dmaCfg.CEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Frame"
        prop Set :: (self.CEI_SETUP = $1, self.CEI_VALUE = self.CEI_SETUP, "ok")
    }
    inst DMA_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually"
        prop JSName :: "dmaSetManually"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Advanced"
    }
    inst CSDP_VALUE :: self.CSDP_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Source Destination Register (CSDP)"
        prop JSName :: "dmaCsdp"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.CSDP_VALUE = $1, self.CSDP_SETUP_update($1), "ok")
    }
    inst CCR_VALUE :: self.CCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Control Register (CCR)"
        prop JSName :: "dmaCcr"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.CCR_VALUE = $1, self.CCR_SETUP_update($1), "ok")
    }
    inst CICR_VALUE :: self.CICR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Interrupt Control Register (CICR)"
        prop JSName :: "dmaCicr"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.CICR_VALUE = $1, self.CICR_SETUP_update($1), "ok")
    }
    inst SRC_SPACE_ADSETUP :: "Data Space" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Source Space"
        prop JSName :: "dmaSrcSpaceAdv"
        prop Visible :: 1
        prop Writable :: (self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.SRC_SPACE_ADSETUP = $1, self.SRC_SPACE_SETUP = $1, "ok")
    }
    inst srcAddrFormatAd :: "Symbolic" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Source Address Format"
        prop JSName :: "dmaSrcAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.srcAddrFormatAd = $1, self.srcAddrFormat = $1, "ok")
    }
    inst CSSAL_HC_VALUE :: self.CSSAL_HC_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Lower Source Address (CSSA_L)- Numeric(Byte Address)"
        prop JSName :: "dmaCssalNumeric"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.srcAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.srcAddrFormat == "Numeric")
        prop cType :: "Uint16"
        prop cPreVal :: "(DMA_AdrPtr)"
        prop Set :: (self.CSSAL_HC_VALUE = $1, self.CSSAL_HC_SETUP_update($1), "ok")
    }
    inst CSSAL_SYM_VALUE :: self.CSSA_SYM_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Lower Source Address (CSSA_L) - Symbolic(Byte Address)"
        prop JSName :: "dmaCssalSymbolic"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.srcAddrFormatAd == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.srcAddrFormat == "Symbolic")
        prop cType :: "char[]"
        prop cPreVal :: if (self.CSSAL_SYM_VALUE != "NULL") {"(DMA_AdrPtr)&"} else {""}
        prop Set :: (self.CSSAL_SYM_VALUE = $1, self.CSSA_SYM_SETUP = $1, "ok")
    }
    inst CSSAU_HC_VALUE :: self.CSSAU_HC_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Upper Source Address (CSSA_U) - Numeric(Byte Address)"
        prop JSName :: "dmaCssauNumeric"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.srcAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.srcAddrFormat == "Numeric")
        prop cType :: "Uint16"
        prop Set :: (self.CSSAU_HC_VALUE = $1, self.CSSAU_HC_SETUP_update($1), "ok")
    }
    inst CSSAU_SYM_VALUE :: self.CSSA_SYM_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Upper Source Address (CSSA_U) - Symbolic(Byte Address)"
        prop JSName :: "dmaCssauSymbolic"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.srcAddrFormat == "Symbolic")
        prop cType :: "char[]"
        prop cPreVal :: if (self.CSSAU_SYM_VALUE != "NULL") {"(Uint16)&"} else {""}
        prop Set :: (self.CSSAU_SYM_VALUE = $1, self.CSSA_SYM_SETUP = $1, "ok")
    }
    inst DST_SPACE_ADSETUP :: "Data Space" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Data Space,Program Space"
        prop Label :: "Destination Space"
        prop JSName :: "dmaDstSpaceAdv"
        prop Visible :: 1
        prop Writable :: (self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.DST_SPACE_ADSETUP = $1, self.DST_SPACE_SETUP = $1, "ok")
    }
    inst dstAddrFormatAd :: "Symbolic" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Symbolic,Numeric"
        prop Label :: "Destination Address Format"
        prop JSName :: "dmaDstAddrFormatAdv"
        prop Visible :: 1
        prop Writable :: (self.DMA_man)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.dstAddrFormatAd = $1, self.dstAddrFormat = $1, "ok")
    }
    inst CDSAL_HC_VALUE :: self.CDSAL_HC_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Lower Destination Address (CDSA_L)- Numeric(Byte Address)"
        prop JSName :: "dmaCdsalNumeric"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.dstAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.dstAddrFormat == "Numeric")
        prop cType :: "Uint16"
        prop cPreVal :: "(DMA_AdrPtr)"
        prop Set :: (self.CDSAL_HC_VALUE = $1, self.CDSAL_HC_SETUP_update($1), "ok")
    }
    inst CDSAL_SYM_VALUE :: self.CDSA_SYM_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Lower Destination Address (CDSA_L) - Symbolic(Byte Address)"
        prop JSName :: "dmaCdsalSymbolic"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.dstAddrFormatAd == "Symbolic")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.dstAddrFormat == "Symbolic")
        prop cType :: "char[]"
        prop cPreVal :: if (self.CDSAL_SYM_VALUE != "NULL") {"(DMA_AdrPtr)&"} else {""}
        prop Set :: (self.CDSAL_SYM_VALUE = $1, self.CDSA_SYM_SETUP = $1, "ok")
    }
    inst CDSAU_HC_VALUE :: self.CDSAU_HC_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Upper Destination Address (CDSA_U) - Numeric(Byte Address)"
        prop JSName :: "dmaCdsauNumeric"
        prop Visible :: 1
        prop Writable :: (self.DMA_man) && (self.dstAddrFormatAd == "Numeric")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.dstAddrFormat == "Numeric")
        prop cType :: "Uint16"
        prop Set :: (self.CDSAU_HC_VALUE = $1, self.CDSAU_HC_SETUP_update($1), "ok")
    }
    inst CDSAU_SYM_VALUE :: self.CDSA_SYM_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Upper Destination Address (CDSA_U) - Symbolic(Byte Address)"
        prop JSName :: "dmaCdsauSymbolic"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (self.dstAddrFormat == "Symbolic")
        prop cType :: "char[]"
        prop cPreVal :: if (self.CDSAU_SYM_VALUE != "NULL") {"(Uint16)&"} else {""}
        prop Set :: (self.CDSAU_SYM_VALUE = $1, self.CDSA_SYM_SETUP = $1, "ok")
    }
    inst CEN_VALUE :: self.CEN_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Element Number (CEN)"
        prop JSName :: "dmaCenAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 > 0) && ($1 < 65536)) {self.CEN_VALUE = $1, self.CEN_SETUP = $1, "ok"} else {self.error("Entered value exceeds limits")})
    }
    inst CFN_VALUE :: self.CFN_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Frame Number (CFN)"
        prop JSName :: "dmaCfnAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 > 0) && ($1 < 65536)) {self.CFN_VALUE = $1, self.CFN_SETUP = $1, "ok"} else {self.error("Entered value exceeds limits")})
    }
    inst CFI_VALUE :: self.CFI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Frame Index (CFI)"
        prop JSName :: "dmaCfiAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CFI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CFI_VALUE = $1, self.CFI_SETUP = $1, "ok")
    }
    inst CSFI_VALUE :: self.CSFI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Source Frame Index (CSFI)"
        prop JSName :: "dmaCfiSrcAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CSFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CSFI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CSFI_VALUE = $1, self.CSFI_SETUP = $1, "ok")
    }
    inst CDFI_VALUE :: self.CDFI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Destination Frame Index (CDFI)"
        prop JSName :: "dmaCfiDstAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CDFI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CDFI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CDFI_VALUE = $1, self.CDFI_SETUP = $1, "ok")
    }
    inst CEI_VALUE :: self.CEI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Element Index (CEI)"
        prop JSName :: "dmaCeiAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CEI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CEI_VALUE = $1, self.CEI_SETUP = $1, "ok")
    }
    inst CSEI_VALUE :: self.CSEI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Source Element Index (CSEI)"
        prop JSName :: "dmaCeiSrcAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CSEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CSEI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CSEI_VALUE = $1, self.CSEI_SETUP = $1, "ok")
    }
    inst CDEI_VALUE :: self.CDEI_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Destination Element Index (CDEI)"
        prop JSName :: "dmaCeiDstAdv"
        prop Visible :: 1
        prop Writable :: self.DMA_man && (dmaCfg.CDEI_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (dmaCfg.CDEI_SUPPORT)
        prop cType :: "Uint16"
        prop Set :: (self.CDEI_VALUE = $1, self.CDEI_SETUP = $1, "ok")
    }
}

type hDMA {
    isa ObjectMgr
    prop name :: "hDMA"
    prop Label :: "DMA Resource Manager"
    prop JSName :: "HDMA"
    prop GlobalHelpTopic :: 1032
    prop InstanceHelpTopic :: 1033
    prop GlobalIcon :: 157
    prop InstanceIcon :: 158
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: DMAFOLDER
    prop maxObjs :: (if (GBL.CHIPTYPE == "5510") {6} else {6})
    prop NoGen :: 1
    prop cGen :: 1
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: if self.c55dma == 1 {"csl_dma.h"} else {""}
    prop cHandleType :: "DMA_Handle"
    prop cOpenName :: "DMA_open"
    prop cConfigName :: "DMA_config"
    prop cHandleName :: self.handleName
    prop DMA_GSCR_SUPPORT :: ((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2"))
    prop EHPI_PRIO_GCR :: (if (self.EHPI_PRIO_SETUP == "High") {0x0001} else {0x0000})
    prop EHPI_EXCL_GCR :: (if (self.EHPI_EXCL_SETUP == "Exclusive") {0x0002} else {0x0000})
    prop FREE_GCR :: (if (self.FREE_SETUP == "Continue After Breakpoint") {0x0004} else {0x0000})
    prop GCR_VALUE_update :: (self.FREE_GCR() | self.EHPI_EXCL_GCR() | self.EHPI_PRIO_GCR())
    prop GCR_SETUP_update :: (self.FREE_SETUP = if ($1 & 0x0004) {"Continue After Breakpoint"} else {"Stop Clock At Breakpoint"}, self.EHPI_EXCL_SETUP = if ($1 & 0x0002) {"Exclusive"} else {"Non-Exclusive"}, self.EHPI_PRIO_SETUP = if ($1 & 0x0001) {"High"} else {"Low"})
    prop gblFxnName :: "DMA_RSET(DMAGCR, "
    prop gblRegValue :: hDMA.GCR_VALUE
    prop gblBracket :: if (hDMA.gDMAconfig) {");\n%0t"} else {""}
    prop gblFxnNameStr :: if (hDMA.gDMAconfig) {"%5t%7s"} else {""}
    prop gblRegValueStr :: if (hDMA.gDMAconfig) {"%4d"} else {""}
    prop gscrFxnName :: "DMA_RSET(DMAGSCR, "
    prop gscrRegValue :: hDMA.GSCR_VALUE
    prop gscrBracket :: if ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT)) {");\n%0t"} else {""}
    prop gscrNameStr :: if ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT)) {"%5t%9s"} else {""}
    prop gscrValueStr :: if ((hDMA.gDMAconfig) && (hDMA.DMA_GSCR_SUPPORT)) {"%10x"} else {""}
    prop comment :: "/* You must use DMA_start() in your main code to start the DMA. */"
    prop cGenFxnEpilogue :: ("%1S%2S%3S%4S%5S%6S\n%5t%11S%0t\n\0, gblFxnNameStr, gblRegValueStr, gblBracket, gscrNameStr, gscrValueStr, gscrBracket, gblFxnName, gblRegValue, gscrFxnName, gscrRegValue, comment")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 6 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55dma :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x DMA opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global MODE_SETUP :: "Same index for src/dst" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Same index for src/dst,Independent index for src/dst"
        prop Label :: "PG1.0 Compatibility Mode Select "
        prop JSName :: "dmaModeSelect"
        prop Visible :: 1
        prop Writable :: (hDMA.DMA_GSCR_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global"
        prop Set :: (self.MODE_SETUP = $1, if ($1 == "Independent index for src/dst") {self.GSCR_VALUE = 0x0001} else {self.GSCR_VALUE = 0x0000}, "ok")
    }
    global gDMAconfig :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Generate Global DMA Configuration and Function Call"
        prop JSName :: "dmaGenerateGlobalCall"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Global"
    }
    global gDMA_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually"
        prop JSName :: "dmaSetManually"
        prop Visible :: 1
        prop Writable :: self.gDMAconfig
        prop NoGen :: 1
        prop TabName :: "Global"
    }
    global GSCR_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Global Software Compatibility Register (GSCR)"
        prop Visible :: 0
        prop Writable :: (hDMA.DMA_GSCR_SUPPORT)
        prop NoGen :: 1
        prop TabName :: "Global"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.GSCR_VALUE = $1 & 0x0001, if ($1 & 0x0001) {self.MODE_SETUP = "Independent index for src/dst"} else {self.MODE_SETUP = "Same index for src/dst"}, "ok")
    }
    global GCR_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Global Control Register (GCR)"
        prop JSName :: "dmaGcr"
        prop Visible :: 1
        prop Writable :: (self.gDMAconfig && self.gDMA_man)
        prop NoGen :: 1
        prop TabName :: "Global"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.GCR_VALUE = $1 & 0x000F, self.GCR_SETUP_update($1 & 0x000F), "ok")
    }
    global EHPI_PRIO_SETUP :: "Low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Low,High"
        prop Label :: "EHPI PRIO"
        prop JSName :: "dmaGcrEhpiPrio"
        prop Visible :: 1
        prop Writable :: (self.gDMAconfig && !(self.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
        prop Set :: (self.EHPI_PRIO_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    global EHPI_EXCL_SETUP :: "Non-Exclusive" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Non-Exclusive,Exclusive"
        prop Label :: "EHPI EXCL"
        prop JSName :: "dmaGcrEhpiExcl"
        prop Visible :: 1
        prop Writable :: (self.gDMAconfig && !(self.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
        prop Set :: (self.EHPI_EXCL_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    global FREE_SETUP :: "Stop Clock At Breakpoint" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Clock At Breakpoint,Continue After Breakpoint"
        prop Label :: "FREE"
        prop JSName :: "dmaGcrFree"
        prop Visible :: 1
        prop Writable :: (self.gDMAconfig && !(self.gDMA_man))
        prop NoGen :: 1
        prop TabName :: "Global"
        prop Set :: (self.FREE_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Handle to DMA "
        prop JSName :: "dmaHandleEnable"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
        prop Set :: (self.cOpenGen = $1, if ($1 == 1) {self.c55dma = 1} else {self.c55dma = 0}, "ok")
    }
    inst cOpenArg0 :: "DMA_CHA0" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "DMA_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst handleName :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Handle Name "
        prop JSName :: "dmaHandleName"
        prop Visible :: 1
        prop Writable :: (self.cOpenGen)
        prop NoGen :: 1
        prop Set :: (self.handleName = $1, self.cConfigArg0 = $1, "ok")
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable pre-initialization "
        prop JSName :: "dmaEnablePreInit"
        prop Visible :: 1
        prop Writable :: self.cOpenGen
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; dmaCfg) {$a = 1}, if ($a == 0) {"You must create a configuration object"} else {self.PINIT_ENABLE = $1, "ok"})
    }
    inst cConfigGen :: = ((self.cOpenGen == 1) && (self.PINIT_ENABLE == 1) && (self.cConfigArg1 != DMA_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: self.handleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
    }
    inst cConfigArg1 :: DMA_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: dmaCfg
        prop Label :: "Pre-initialize "
        prop JSName :: "dmaPreInit"
        prop Visible :: 1
        prop Writable :: (self.PINIT_ENABLE == 1) && (self.cOpenGen)
        prop NoGen :: 0
        prop cPreVal :: "&"
        prop Set :: (self.cConfigArg1 = $1, "ok")
    }
}

object DMA_NOTHING :: dmaCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param DATA_TYPE_SETUP :: "8-bit"
    param SRC_BEN_SETUP :: "Single Access (No Burst)"
    param SRC_PACK_SETUP :: "No Packed Accesses"
    param SRC_SPACE_SETUP :: "Data Space"
    param srcAddrFormat :: "Symbolic"
    param CSSA_HC_SETUP :: 0
    param CSSA_SYM_SETUP :: "NULL"
    param SRC_AMODE_SETUP :: "Constant"
    param SRC_SETUP :: "SARAM"
    param CSEI_SETUP :: 0
    param CSFI_SETUP :: 0
    param DST_BEN_SETUP :: "Single Access (No Burst)"
    param DST_PACK_SETUP :: "No Packed Accesses"
    param DST_SPACE_SETUP :: "Data Space"
    param dstAddrFormat :: "Symbolic"
    param CDSA_HC_SETUP :: 0
    param CDSA_SYM_SETUP :: "NULL"
    param DST_AMODE_SETUP :: "Constant"
    param DST_SETUP :: "SARAM"
    param CDEI_SETUP :: 0
    param CDFI_SETUP :: 0
    param SYNC_SETUP :: "No Event"
    param REPEAT_SETUP :: "Only if END PROG = 1"
    param END_PROG_SETUP :: "Delay re-initialization"
    param FS_SETUP :: "Disabled"
    param PRIO_SETUP :: "Low"
    param EN_SETUP :: "Disabled"
    param AUTO_INIT_SETUP :: "Disabled"
    param TIMEOUT_IE_SETUP :: "Disabled"
    param DROP_IE_SETUP :: "Disabled"
    param HALF_IE_SETUP :: "Disabled"
    param FRAME_IE_SETUP :: "Disabled"
    param LAST_IE_SETUP :: "Disabled"
    param BLOCK_IE_SETUP :: "Disabled"
    param CEN_SETUP :: 1
    param CFN_SETUP :: 1
    param CFI_SETUP :: 0
    param CEI_SETUP :: 0
    param DMA_man :: 0
    param CSDP_VALUE :: 0
    param CCR_VALUE :: 0
    param CICR_VALUE :: 0
    param SRC_SPACE_ADSETUP :: "Data Space"
    param srcAddrFormatAd :: "Symbolic"
    param CSSAL_SYM_VALUE :: "NULL"
    param CSSAU_SYM_VALUE :: "NULL"
    param DST_SPACE_ADSETUP :: "Data Space"
    param dstAddrFormatAd :: "Symbolic"
    param CDSAL_SYM_VALUE :: "NULL"
    param CDSAU_SYM_VALUE :: "NULL"
    param CEN_VALUE :: 1
    param CFN_VALUE :: 1
    param CFI_VALUE :: 0
    param CSFI_VALUE :: 0
    param CDFI_VALUE :: 0
    param CEI_VALUE :: 0
    param CSEI_VALUE :: 0
    param CDEI_VALUE :: 0
}

object DMA0 :: hDMA {
    param iComment :: "DMA Channel 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 0"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA0"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma0"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma0"
    param cConfigArg1 :: DMA_NOTHING
}

object DMA1 :: hDMA {
    param iComment :: "DMA Channel 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 1"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA1"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma1"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma1"
    param cConfigArg1 :: DMA_NOTHING
}

object DMA2 :: hDMA {
    param iComment :: "DMA Channel 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 2"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA2"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma2"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma2"
    param cConfigArg1 :: DMA_NOTHING
}

object DMA3 :: hDMA {
    param iComment :: "DMA Channel 3"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 3"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA3"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma3"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma3"
    param cConfigArg1 :: DMA_NOTHING
}

object DMA4 :: hDMA {
    param iComment :: "DMA Channel 4"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 4"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA4"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma4"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma4"
    param cConfigArg1 :: DMA_NOTHING
}

object DMA5 :: hDMA {
    param iComment :: "DMA Channel 5"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hDMA"
    param iDelMsg :: "DMA Channel 5"
    param cOpenGen :: 0
    param cOpenArg0 :: "DMA_CHA5"
    param cOpenArg1 :: "DMA_OPEN_RESET"
    param handleName :: "hDma5"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hDma5"
    param cConfigArg1 :: DMA_NOTHING
}

type EMIFFOLDER {
    prop Label :: "EMIF - External Memory Interface"
    prop GlobalIcon :: 163
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1040
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type emifCfg {
    isa ObjectMgr
    prop name :: "EMIF"
    prop Label :: "EMIF Configuration Manager"
    prop JSName :: "EMIF"
    prop GlobalHelpTopic :: 1041
    prop InstanceHelpTopic :: 1041
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: EMIFFOLDER
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "EMIF_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_emif.h"} else {""}
    prop NoGen :: 1
    prop synch_update :: ($a = 0, scan ($b; emifCfg) {if (($b.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") || ($b.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") || ($b.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") || ($b.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || ($b.CE3_MTYPE_SETUP == "32-bit wide SBSRAM")) {1} else {0}})
    prop CE0_MTYPE_SCR1 :: (if (self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") {0x0000} else {if (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") {0x1000} else {if (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous") {0x2000} else {if (self.CE0_MTYPE_SETUP == "32-bit wide SDRAM") {0x3000} else {0x4000}}}})
    prop CE0_RDSET_SCR1 :: (self.CE0_RDSET_SETUP << 8)
    prop CE0_WRSET_SCR2 :: (self.CE0_WRSET_SETUP << 8)
    prop CE0_RDSTROBE_SCR1 :: (self.CE0_RDSTROBE_SETUP << 2)
    prop CE0_WRSTROBE_SCR2 :: (self.CE0_WRSTROBE_SETUP << 2)
    prop CE0_RDHOLD_SCR1 :: (self.CE0_RDHOLD_SETUP)
    prop CE0_WRHOLD_SCR2 :: (self.CE0_WRHOLD_SETUP)
    prop CE0_EXRDHOLD_SCR2 :: (self.CE0_EXRDHOLD_SETUP << 14)
    prop CE0_EXWRHOLD_SCR2 :: (self.CE0_EXWRHOLD_SETUP << 12)
    prop CE1_MTYPE_SCR1 :: (if (self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") {0x0000} else {if (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") {0x1000} else {if (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous") {0x2000} else {if (self.CE1_MTYPE_SETUP == "32-bit wide SDRAM") {0x3000} else {0x4000}}}})
    prop CE1_RDSET_SCR1 :: (self.CE1_RDSET_SETUP << 8)
    prop CE1_WRSET_SCR2 :: (self.CE1_WRSET_SETUP << 8)
    prop CE1_RDSTROBE_SCR1 :: (self.CE1_RDSTROBE_SETUP << 2)
    prop CE1_WRSTROBE_SCR2 :: (self.CE1_WRSTROBE_SETUP << 2)
    prop CE1_RDHOLD_SCR1 :: (self.CE1_RDHOLD_SETUP)
    prop CE1_WRHOLD_SCR2 :: (self.CE1_WRHOLD_SETUP)
    prop CE1_EXRDHOLD_SCR2 :: (self.CE1_EXRDHOLD_SETUP << 14)
    prop CE1_EXWRHOLD_SCR2 :: (self.CE1_EXWRHOLD_SETUP << 12)
    prop CE2_MTYPE_SCR1 :: (if (self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") {0x0000} else {if (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") {0x1000} else {if (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous") {0x2000} else {if (self.CE2_MTYPE_SETUP == "32-bit wide SDRAM") {0x3000} else {0x4000}}}})
    prop CE2_RDSET_SCR1 :: (self.CE2_RDSET_SETUP << 8)
    prop CE2_WRSET_SCR2 :: (self.CE2_WRSET_SETUP << 8)
    prop CE2_RDSTROBE_SCR1 :: (self.CE2_RDSTROBE_SETUP << 2)
    prop CE2_WRSTROBE_SCR2 :: (self.CE2_WRSTROBE_SETUP << 2)
    prop CE2_RDHOLD_SCR1 :: (self.CE2_RDHOLD_SETUP)
    prop CE2_WRHOLD_SCR2 :: (self.CE2_WRHOLD_SETUP)
    prop CE2_EXRDHOLD_SCR2 :: (self.CE2_EXRDHOLD_SETUP << 14)
    prop CE2_EXWRHOLD_SCR2 :: (self.CE2_EXWRHOLD_SETUP << 12)
    prop CE3_MTYPE_SCR1 :: (if (self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") {0x0000} else {if (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") {0x1000} else {if (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous") {0x2000} else {if (self.CE3_MTYPE_SETUP == "32-bit wide SDRAM") {0x3000} else {0x4000}}}})
    prop CE3_RDSET_SCR1 :: (self.CE3_RDSET_SETUP << 8)
    prop CE3_WRSET_SCR2 :: (self.CE3_WRSET_SETUP << 8)
    prop CE3_RDSTROBE_SCR1 :: (self.CE3_RDSTROBE_SETUP << 2)
    prop CE3_WRSTROBE_SCR2 :: (self.CE3_WRSTROBE_SETUP << 2)
    prop CE3_RDHOLD_SCR1 :: (self.CE3_RDHOLD_SETUP)
    prop CE3_WRHOLD_SCR2 :: (self.CE3_WRHOLD_SETUP)
    prop CE3_EXRDHOLD_SCR2 :: (self.CE3_EXRDHOLD_SETUP << 14)
    prop CE3_EXWRHOLD_SCR2 :: (self.CE3_EXWRHOLD_SETUP << 12)
    prop RESET_GCR :: (if (self.RESET_SETUP == "CLKMEM Enabled to Clock") {0x0020} else {0x0000})
    prop MEMCEN_GCR :: (if (self.MEMCEN_SETUP == "CLKMEM Enabled to Clock") {0x0020} else {0x0000})
    prop MEMFREQ_GCR :: (if (self.MEMFREQ_SETUP == "CLKMEM = DSP Clock") {0x0000} else {0x0200})
    prop NOHOLD_GCR :: (if (self.NOHOLD_SETUP == "Hold Enabled") {0x0000} else {0x0001})
    prop WPE_GCR :: (if (self.WPE_SETUP == "Disabled") {0x0000} else {0x0080})
    prop SDACC_SDCR2 :: (if (self.SDACC_SETUP == "16-bits wide (D[15:0])") {0x0000} else {0x0400})
    prop SDSIZE_SDCR1 :: (if (self.SDSIZE_SETUP == "64Mbit") {0x0000} else {0x0400})
    prop SDWID_SDCR1 :: (if (self.SDWID_SETUP == "16-bits") {0x0000} else {0x0200})
    prop RFEN_SDCR1 :: (if (self.RFEN_SETUP == "Disabled") {0x0000} else {0x0100})
    prop TRP_SDCR1 :: (self.TRP_SETUP)
    prop TRC_SDCR1 :: (self.TRC_SETUP << 11)
    prop TRCD_SDCR1 :: (self.TRCD_SETUP << 4)
    prop TRAS_SDCR2 :: (self.TRAS_SETUP << 4)
    prop TMRD_SDCR2 :: (self.TMRD_SETUP << 8)
    prop TACTV_SDCR2 :: (self.TACTV_SETUP)
    prop CE0_SCR1_VALUE_update :: (self.CE0_RDHOLD_SCR1 | self.CE0_RDSTROBE_SCR1 | self.CE0_RDSET_SCR1 | self.CE0_MTYPE_SCR1)
    prop CE0_SCR2_VALUE_update :: (self.CE0_WRHOLD_SCR2 | self.CE0_WRSTROBE_SCR2 | self.CE0_WRSET_SCR2 | self.CE0_EXRDHOLD_SCR2 | self.CE0_EXWRHOLD_SCR2)
    prop CE1_SCR1_VALUE_update :: (self.CE1_RDHOLD_SCR1 | self.CE1_RDSTROBE_SCR1 | self.CE1_RDSET_SCR1 | self.CE1_MTYPE_SCR1)
    prop CE1_SCR2_VALUE_update :: (self.CE1_WRHOLD_SCR2 | self.CE1_WRSTROBE_SCR2 | self.CE1_WRSET_SCR2 | self.CE1_EXRDHOLD_SCR2 | self.CE1_EXWRHOLD_SCR2)
    prop CE2_SCR1_VALUE_update :: (self.CE2_RDHOLD_SCR1 | self.CE2_RDSTROBE_SCR1 | self.CE2_RDSET_SCR1 | self.CE2_MTYPE_SCR1)
    prop CE2_SCR2_VALUE_update :: (self.CE2_WRHOLD_SCR2 | self.CE2_WRSTROBE_SCR2 | self.CE2_WRSET_SCR2 | self.CE2_EXRDHOLD_SCR2 | self.CE2_EXWRHOLD_SCR2)
    prop CE3_SCR1_VALUE_update :: (self.CE3_RDHOLD_SCR1 | self.CE3_RDSTROBE_SCR1 | self.CE3_RDSET_SCR1 | self.CE3_MTYPE_SCR1)
    prop CE3_SCR2_VALUE_update :: (self.CE3_WRHOLD_SCR2 | self.CE3_WRSTROBE_SCR2 | self.CE3_WRSET_SCR2 | self.CE3_EXRDHOLD_SCR2 | self.CE3_EXWRHOLD_SCR2)
    prop GCR_VALUE_update :: (self.NOHOLD_GCR | self.MEMCEN_GCR | self.MEMFREQ_GCR | self.WPE_GCR)
    prop SDCR1_VALUE_update :: (self.TRP_SDCR1 | self.TRC_SDCR1 | self.TRCD_SDCR1 | self.RFEN_SDCR1 | self.SDSIZE_SDCR1 | self.SDWID_SDCR1)
    prop SDCR2_VALUE_update :: (self.TACTV_SDCR2 | self.TMRD_SDCR2 | self.TRAS_SDCR2 | self.SDACC_SDCR2)
    prop GCR_SETUP_update :: (self.NOHOLD_SETUP = if ($1 & 0x0001) {"Hold Disabled"} else {"Hold Enabled"}, self.MEMCEN_SETUP = if ($1 & 0x0020) {"CLKMEM Enabled to Clock"} else {"CLKMEM Held High"}, self.WPE_SETUP = if ($1 & 0x0080) {"Enabled"} else {"Disabled"}, self.MEMFREQ_SETUP = ($a = $1 & 0x0E00, if ($a == 0x0000) {"CLKMEM = DSP Clock"} else {if ($a == 0x0200) {"CLKMEM = DSP Clock / 2"} else {if ($a == 0x0400) {"CLKMEM = DSP Clock / 4"} else {if ($a == 0x0600) {"CLKMEM = DSP Clock / 8"} else {"CLKMEM = DSP Clock / 16"}}}}))
    prop SDCR1_SETUP_update :: (self.TRP_SETUP = ($1 & 0x000F), self.TRCD_SETUP = (($1 >> 4) & 0x000F), self.TRC_SETUP = (($1 >> 11) & 0x001F), self.RFEN_SETUP = if ($1 & 0x0100) {"Enabled"} else {"Disabled"}, self.SDSIZE_SETUP = if ($1 & 0x0400) {"128Mbit"} else {"64Mbit"}, self.SDWID_SETUP = if ($1 & 0x0200) {"32-bits"} else {"16-bits"})
    prop SDCR2_SETUP_update :: (self.TACTV_SETUP = ($1 & 0x000F), self.TRAS_SETUP = (($1 >> 4) & 0x000F), self.TMRD_SETUP = (($1 >> 8) & 0x0003), self.SDACC_SETUP = if ($1 & 0x0400) {"32-bits wide (D[31:0])"} else {"16-bits wide (D[15:0])"})
    prop CE0_SCR1_SETUP_update :: (self.CE0_RDHOLD_SETUP = ($1 & 0x0003), self.CE0_RDSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE0_RDSET_SETUP = (($1 >> 8) & 0x000F), self.CE0_MTYPE_SETUP = (($a = $1 & 0x7000), if ($a == 0x0000) {"8-bit wide Asynchronous"} else {if ($a == 0x1000) {"16-bit wide Asynchronous"} else {if ($a == 0x2000) {"32-bit wide Asynchronous"} else {if ($a == 0x3000) {"32-bit wide SDRAM"} else {"32-bit wide SBSRAM"}}}}))
    prop CE0_SCR2_SETUP_update :: (self.CE0_WRHOLD_SETUP = ($1 & 0x0003), self.CE0_WRSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE0_WRSET_SETUP = (($1 >> 8) & 0x000F), self.CE0_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003), self.CE0_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003))
    prop CE1_SCR1_SETUP_update :: (self.CE1_RDHOLD_SETUP = ($1 & 0x0003), self.CE1_RDSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE1_RDSET_SETUP = (($1 >> 8) & 0x000F), self.CE1_MTYPE_SETUP = (($a = $1 & 0x7000), if ($a == 0x0000) {"8-bit wide Asynchronous"} else {if ($a == 0x1000) {"16-bit wide Asynchronous"} else {if ($a == 0x2000) {"32-bit wide Asynchronous"} else {if ($a == 0x3000) {"32-bit wide SDRAM"} else {"32-bit wide SBSRAM"}}}}))
    prop CE1_SCR2_SETUP_update :: (self.CE1_WRHOLD_SETUP = ($1 & 0x0003), self.CE1_WRSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE1_WRSET_SETUP = (($1 >> 8) & 0x000F), self.CE1_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003), self.CE1_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003))
    prop CE2_SCR1_SETUP_update :: (self.CE2_RDHOLD_SETUP = ($1 & 0x0003), self.CE2_RDSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE2_RDSET_SETUP = (($1 >> 8) & 0x000F), self.CE2_MTYPE_SETUP = (($a = $1 & 0x7000), if ($a == 0x0000) {"8-bit wide Asynchronous"} else {if ($a == 0x1000) {"16-bit wide Asynchronous"} else {if ($a == 0x2000) {"32-bit wide Asynchronous"} else {if ($a == 0x3000) {"32-bit wide SDRAM"} else {"32-bit wide SBSRAM"}}}}))
    prop CE2_SCR2_SETUP_update :: (self.CE2_WRHOLD_SETUP = ($1 & 0x0003), self.CE2_WRSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE2_WRSET_SETUP = (($1 >> 8) & 0x000F), self.CE2_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003), self.CE2_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003))
    prop CE3_SCR1_SETUP_update :: (self.CE3_RDHOLD_SETUP = ($1 & 0x0003), self.CE3_RDSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE3_RDSET_SETUP = (($1 >> 8) & 0x000F), self.CE3_MTYPE_SETUP = (($a = $1 & 0x7000), if ($a == 0x0000) {"8-bit wide Asynchronous"} else {if ($a == 0x1000) {"16-bit wide Asynchronous"} else {if ($a == 0x2000) {"32-bit wide Asynchronous"} else {if ($a == 0x3000) {"32-bit wide SDRAM"} else {"32-bit wide SBSRAM"}}}}))
    prop CE3_SCR2_SETUP_update :: (self.CE3_WRHOLD_SETUP = ($1 & 0x0003), self.CE3_WRSTROBE_SETUP = (($1 >> 2) & 0x003F), self.CE3_WRSET_SETUP = (($1 >> 8) & 0x000F), self.CE3_EXWRHOLD_SETUP = (($1 >> 12) & 0x0003), self.CE3_EXRDHOLD_SETUP = (($1 >> 14) & 0x0003))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global SYNCH :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Synchronous Memory Chosen "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst CE0_MTYPE_SETUP :: "32-bit wide Asynchronous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
        prop Label :: "Memory Type "
        prop JSName :: "emifCe0Mtype"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (self.CE0_MTYPE_SETUP = $1, self.CE0_SCR1_VALUE = self.CE0_SCR1_VALUE_update(), self.SYNCH = self.synch_update(), "ok")
    }
    inst CE0_RDSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Setup Width "
        prop JSName :: "emifCe0ReadSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE0_RDSET_SETUP = $1, self.CE0_SCR1_VALUE = self.CE0_SCR1_VALUE_update()} else {self.error("Read Setup value exceeds limits")}, "ok")
    }
    inst CE0_WRSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Setup Width "
        prop JSName :: "emifCe0WriteSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE0_WRSET_SETUP = $1, self.CE0_SCR2_VALUE = self.CE0_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE0_RDSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Read Strobe Width "
        prop JSName :: "emifCe0ReadStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE0_RDSTROBE_SETUP = $1, self.CE0_SCR1_VALUE = self.CE0_SCR1_VALUE_update()} else {self.error("Read Strobe value exceeds limits")}, "ok")
    }
    inst CE0_WRSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Write Strobe Width "
        prop JSName :: "emifCe0WriteStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE0_WRSTROBE_SETUP = $1, self.CE0_SCR2_VALUE = self.CE0_SCR2_VALUE_update()} else {self.error("Write Strobe value exceeds limits")}, "ok")
    }
    inst CE0_RDHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Hold Width "
        prop JSName :: "emifCe0ReadHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE0_RDHOLD_SETUP = $1, self.CE0_SCR1_VALUE = self.CE0_SCR1_VALUE_update()} else {self.error("Read Hold value exceeds limits")}, "ok")
    }
    inst CE0_WRHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Hold Width "
        prop JSName :: "emifCe0WriteHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE0_WRHOLD_SETUP = $1, self.CE0_SCR2_VALUE = self.CE0_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE0_EXRDHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Read Hold Width "
        prop JSName :: "emifCe0ReadExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE0_EXRDHOLD_SETUP = $1, self.CE0_SCR2_VALUE = self.CE0_SCR2_VALUE_update()} else {self.error("Extended Read Hold value exceeds limits")}, "ok")
    }
    inst CE0_EXWRHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Write Hold Width "
        prop JSName :: "emifCe0WriteExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE0_EXWRHOLD_SETUP = $1, self.CE0_SCR2_VALUE = self.CE0_SCR2_VALUE_update()} else {self.error("Extended Write Setup value exceeds limits")}, "ok")
    }
    inst CE0_TIMEOUT_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Length of Bus Error Timeout "
        prop JSName :: "emifCe0Timeout"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE0_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE0"
        prop Set :: (if (($1 >= 0) && ($1 <= 255)) {self.CE0_TIMEOUT_SETUP = $1, self.CE0_SCR3_VALUE = $1} else {self.error("Timeout value exceeds limits")}, "ok")
    }
    inst CE1_MTYPE_SETUP :: "32-bit wide Asynchronous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
        prop Label :: "Memory Type "
        prop JSName :: "emifCe1Mtype"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (self.CE1_MTYPE_SETUP = $1, self.CE1_SCR1_VALUE = self.CE1_SCR1_VALUE_update(), self.SYNCH = self.synch_update(), "ok")
    }
    inst CE1_RDSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Setup Width "
        prop JSName :: "emifCe1ReadSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE1_RDSET_SETUP = $1, self.CE1_SCR1_VALUE = self.CE1_SCR1_VALUE_update()} else {self.error("Read Setup value exceeds limits")}, "ok")
    }
    inst CE1_WRSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Setup Width "
        prop JSName :: "emifCe1WriteSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE1_WRSET_SETUP = $1, self.CE1_SCR2_VALUE = self.CE1_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE1_RDSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Read Strobe Width "
        prop JSName :: "emifCe1ReadStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE1_RDSTROBE_SETUP = $1, self.CE1_SCR1_VALUE = self.CE1_SCR1_VALUE_update()} else {self.error("Read Strobe value exceeds limits")}, "ok")
    }
    inst CE1_WRSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Write Strobe Width "
        prop JSName :: "emifCe1WriteStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE1_WRSTROBE_SETUP = $1, self.CE1_SCR2_VALUE = self.CE1_SCR2_VALUE_update()} else {self.error("Write Strobe value exceeds limits")}, "ok")
    }
    inst CE1_RDHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Hold Width "
        prop JSName :: "emifCe1ReadHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE1_RDHOLD_SETUP = $1, self.CE1_SCR1_VALUE = self.CE1_SCR1_VALUE_update()} else {self.error("Read Hold value exceeds limits")}, "ok")
    }
    inst CE1_WRHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Hold Width "
        prop JSName :: "emifCe1WriteHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE1_WRHOLD_SETUP = $1, self.CE1_SCR2_VALUE = self.CE1_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE1_EXRDHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Read Hold Width "
        prop JSName :: "emifCe1ReadExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE1_EXRDHOLD_SETUP = $1, self.CE1_SCR2_VALUE = self.CE1_SCR2_VALUE_update()} else {self.error("Extended Read Hold value exceeds limits")}, "ok")
    }
    inst CE1_EXWRHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Write Hold Width "
        prop JSName :: "emifCe1WriteExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE1_EXWRHOLD_SETUP = $1, self.CE1_SCR2_VALUE = self.CE1_SCR2_VALUE_update()} else {self.error("Extended Write Setup value exceeds limits")}, "ok")
    }
    inst CE1_TIMEOUT_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Length of Bus Error Timeout "
        prop JSName :: "emifCe1Timeout"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE1_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE1_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE1"
        prop Set :: (if (($1 >= 0) && ($1 <= 255)) {self.CE1_TIMEOUT_SETUP = $1, self.CE1_SCR3_VALUE = $1} else {self.error("Timeout value exceeds limits")}, "ok")
    }
    inst CE2_MTYPE_SETUP :: "32-bit wide Asynchronous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
        prop Label :: "Memory Type "
        prop JSName :: "emifCe2Mtype"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (self.CE2_MTYPE_SETUP = $1, self.CE2_SCR1_VALUE = self.CE2_SCR1_VALUE_update(), self.SYNCH = self.synch_update(), "ok")
    }
    inst CE2_RDSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Setup Width "
        prop JSName :: "emifCe2ReadSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE2_RDSET_SETUP = $1, self.CE2_SCR1_VALUE = self.CE2_SCR1_VALUE_update()} else {self.error("Read Setup value exceeds limits")}, "ok")
    }
    inst CE2_WRSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Setup Width "
        prop JSName :: "emifCe2WriteSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE2_WRSET_SETUP = $1, self.CE2_SCR2_VALUE = self.CE2_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE2_RDSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Read Strobe Width "
        prop JSName :: "emifCe2ReadStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE2_RDSTROBE_SETUP = $1, self.CE2_SCR1_VALUE = self.CE2_SCR1_VALUE_update()} else {self.error("Read Strobe value exceeds limits")}, "ok")
    }
    inst CE2_WRSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Write Strobe Width "
        prop JSName :: "emifCe2WriteStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE2_WRSTROBE_SETUP = $1, self.CE2_SCR2_VALUE = self.CE2_SCR2_VALUE_update()} else {self.error("Write Strobe value exceeds limits")}, "ok")
    }
    inst CE2_RDHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Hold Width "
        prop JSName :: "emifCe2ReadHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE2_RDHOLD_SETUP = $1, self.CE2_SCR1_VALUE = self.CE2_SCR1_VALUE_update()} else {self.error("Read Hold value exceeds limits")}, "ok")
    }
    inst CE2_WRHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Hold Width "
        prop JSName :: "emifCe2WriteHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE2_WRHOLD_SETUP = $1, self.CE2_SCR2_VALUE = self.CE2_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE2_EXRDHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Read Hold Width "
        prop JSName :: "emifCe2ReadExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE2_EXRDHOLD_SETUP = $1, self.CE2_SCR2_VALUE = self.CE2_SCR2_VALUE_update()} else {self.error("Extended Read Hold value exceeds limits")}, "ok")
    }
    inst CE2_EXWRHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Write Hold Width "
        prop JSName :: "emifCe2WriteExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE2_EXWRHOLD_SETUP = $1, self.CE2_SCR2_VALUE = self.CE2_SCR2_VALUE_update()} else {self.error("Extended Write Setup value exceeds limits")}, "ok")
    }
    inst CE2_TIMEOUT_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Length of Bus Error Timeout "
        prop JSName :: "emifCe2Timeout"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE2_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE2_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE2"
        prop Set :: (if (($1 >= 0) && ($1 <= 255)) {self.CE2_TIMEOUT_SETUP = $1, self.CE2_SCR3_VALUE = $1} else {self.error("Timeout value exceeds limits")}, "ok")
    }
    inst CE3_MTYPE_SETUP :: "32-bit wide Asynchronous" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bit wide Asynchronous,16-bit wide Asynchronous,32-bit wide Asynchronous,32-bit wide SDRAM,32-bit wide SBSRAM"
        prop Label :: "Memory Type "
        prop JSName :: "emifCe3Mtype"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (self.CE3_MTYPE_SETUP = $1, self.CE3_SCR1_VALUE = self.CE3_SCR1_VALUE_update(), self.SYNCH = self.synch_update(), "ok")
    }
    inst CE3_RDSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Setup Width "
        prop JSName :: "emifCe3ReadSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE3_RDSET_SETUP = $1, self.CE3_SCR1_VALUE = self.CE3_SCR1_VALUE_update()} else {self.error("Read Setup value exceeds limits")}, "ok")
    }
    inst CE3_WRSET_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Setup Width "
        prop JSName :: "emifCe3WriteSetup"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE3_WRSET_SETUP = $1, self.CE3_SCR2_VALUE = self.CE3_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE3_RDSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Read Strobe Width "
        prop JSName :: "emifCe3ReadStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE3_RDSTROBE_SETUP = $1, self.CE3_SCR1_VALUE = self.CE3_SCR1_VALUE_update()} else {self.error("Read Strobe value exceeds limits")}, "ok")
    }
    inst CE3_WRSTROBE_SETUP :: 0x3F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Write Strobe Width "
        prop JSName :: "emifCe3WriteStrobe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 63)) {self.CE3_WRSTROBE_SETUP = $1, self.CE3_SCR2_VALUE = self.CE3_SCR2_VALUE_update()} else {self.error("Write Strobe value exceeds limits")}, "ok")
    }
    inst CE3_RDHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Read Hold Width "
        prop JSName :: "emifCe3ReadHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE3_RDHOLD_SETUP = $1, self.CE3_SCR1_VALUE = self.CE3_SCR1_VALUE_update()} else {self.error("Read Hold value exceeds limits")}, "ok")
    }
    inst CE3_WRHOLD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Write Hold Width "
        prop JSName :: "emifCe3WriteHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE3_WRHOLD_SETUP = $1, self.CE3_SCR2_VALUE = self.CE3_SCR2_VALUE_update()} else {self.error("Write Setup value exceeds limits")}, "ok")
    }
    inst CE3_EXRDHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Read Hold Width "
        prop JSName :: "emifCe3ReadExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE3_EXRDHOLD_SETUP = $1, self.CE3_SCR2_VALUE = self.CE3_SCR2_VALUE_update()} else {self.error("Extended Read Hold value exceeds limits")}, "ok")
    }
    inst CE3_EXWRHOLD_SETUP :: 0x1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Extended Write Hold Width "
        prop JSName :: "emifCe3WriteExtHold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.CE3_EXWRHOLD_SETUP = $1, self.CE3_SCR2_VALUE = self.CE3_SCR2_VALUE_update()} else {self.error("Extended Write Setup value exceeds limits")}, "ok")
    }
    inst CE3_TIMEOUT_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Length of Bus Error Timeout "
        prop JSName :: "emifCe3Timeout"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE3_MTYPE_SETUP == "8-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "16-bit wide Asynchronous") || (self.CE3_MTYPE_SETUP == "32-bit wide Asynchronous"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "CE3"
        prop Set :: (if (($1 >= 0) && ($1 <= 255)) {self.CE3_TIMEOUT_SETUP = $1, self.CE3_SCR3_VALUE = $1} else {self.error("Timeout value exceeds limits")}, "ok")
    }
    inst RESET_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reset EMIF State Machine "
        prop JSName :: "emifRst"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Settings"
        prop Set :: (self.RESET_SETUP = $1, if ($1 == 1) {hEMIF.GblEmifReset = 1, self.GRR_VALUE = 0xFFFF} else {hEMIF.GblEmifReset = 0, self.GRR_VALUE = 0x0000}, "ok")
    }
    inst MEMCEN_SETUP :: "CLKMEM Enabled to Clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKMEM Enabled to Clock,CLKMEM Held High"
        prop Label :: "Memory Clock Enable              "
        prop JSName :: "emifGcrMemcen"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE3_MTYPE_SETUP == "32-bit wide SBSRAM"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Settings"
        prop Set :: (self.MEMCEN_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    inst MEMFREQ_SETUP :: "CLKMEM = DSP Clock" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKMEM = DSP Clock,CLKMEM = DSP Clock / 2"
        prop Label :: "Memory Clock Frequency              "
        prop JSName :: "emifGcrMemfreq"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man) && ((self.CE0_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE0_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE1_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE1_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE2_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE2_MTYPE_SETUP == "32-bit wide SBSRAM") || (self.CE3_MTYPE_SETUP == "32-bit wide SDRAM") || (self.CE3_MTYPE_SETUP == "32-bit wide SBSRAM"))
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Settings"
        prop Set :: (self.MEMFREQ_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    inst NOHOLD_SETUP :: "Hold Enabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Hold Enabled,Hold Disabled"
        prop Label :: "External HOLD Disable "
        prop JSName :: "emifGcrNohold"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Settings"
        prop Set :: (self.NOHOLD_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    inst WPE_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Write Posting Enable "
        prop JSName :: "emifGcrWpe"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Global Settings"
        prop Set :: (self.WPE_SETUP = $1, self.GCR_VALUE = self.GCR_VALUE_update(), "ok")
    }
    inst SDINIT_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize SDRAM "
        prop JSName :: "emifSdinit"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (self.SDINIT_SETUP = $1, if ($1 == 1) {self.SDINIT_VALUE = 0x0FFF} else {self.SDINIT_VALUE = 0x0000}, "ok")
    }
    inst SDACC_SETUP :: "16-bits wide (D[15:0])" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "16-bits wide (D[15:0]),32-bits wide (D[31:0])"
        prop Label :: "SDRAM Data Bus Interface Width "
        prop JSName :: "emifSdcr2Sdacc"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (self.SDACC_SETUP = $1, self.SDCR2_VALUE = self.SDCR2_VALUE_update(), "ok")
    }
    inst SDSIZE_SETUP :: "64Mbit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "64Mbit,128Mbit"
        prop Label :: "SDRAM Size Select "
        prop JSName :: "emifSdcr1Sdsize"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (self.SDSIZE_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update(), "ok")
    }
    inst SDWID_SETUP :: "16-bits" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "16-bits,32-bits"
        prop Label :: "SDRAM Width Select "
        prop JSName :: "emifSdcr1Sdwid"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (self.SDWID_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update(), "ok")
    }
    inst RFEN_SETUP :: "Enabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Refresh Enable "
        prop JSName :: "emifSdcr1Rfen"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (self.RFEN_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update(), "ok")
    }
    inst SDPERIOD_SETUP :: 0x080 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%03x"
        prop Label :: "Refresh Period "
        prop JSName :: "emifSdperiod"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 0x0FFF)) {self.SDPERIOD_SETUP = $1, self.SDPERIOD_VALUE = $1} else {self.error("PERIOD value exceeds limits")}, "ok")
    }
    inst TRP_SETUP :: 0x8 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "TRP Value [(Trp /SDCLK) - 1] "
        prop JSName :: "emifSdcr1Trp"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 15)) {self.TRP_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update()} else {self.error("TRP value exceeds limits")}, "ok")
    }
    inst TRC_SETUP :: 0x1F { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "TRC Value [(Trc /SDCLK) - 1] "
        prop JSName :: "emifSdcr1Trc"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 31)) {self.TRC_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update()} else {self.error("TRC value exceeds limits")}, "ok")
    }
    inst TRCD_SETUP :: 0x4 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "TRCD Value [(Trcd /SDCLK) - 1] "
        prop JSName :: "emifSdcr1Trcd"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 15)) {self.TRCD_SETUP = $1, self.SDCR1_VALUE = self.SDCR1_VALUE_update()} else {self.error("TRCD value exceeds limits")}, "ok")
    }
    inst TRAS_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "TRAS Value [(Tras /SDCLK) - 1] "
        prop JSName :: "emifSdcr2Tras"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 15)) {self.TRAS_SETUP = $1, self.SDCR2_VALUE = self.SDCR2_VALUE_update()} else {self.error("TRAS value exceeds limits")}, "ok")
    }
    inst TMRD_SETUP :: 0x3 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "TMRD Value [(Tmrd /SDCLK) - 1] "
        prop JSName :: "emifSdcr2Tmrd"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 3)) {self.TMRD_SETUP = $1, self.SDCR2_VALUE = self.SDCR2_VALUE_update()} else {self.error("TMRD value exceeds limits")}, "ok")
    }
    inst TACTV_SETUP :: 0xF { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Label :: "Delay from ACTV to ACTV Command [(Tactv2actv /SDCLK) - 1] "
        prop JSName :: "emifSdcr2Tactv"
        prop Visible :: 1
        prop Writable :: !(self.EMIF_man)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "SDRAM"
        prop Set :: (if (($1 >= 0) && ($1 <= 15)) {self.TACTV_SETUP = $1, self.SDCR2_VALUE = self.SDCR2_VALUE_update()} else {self.error("TACTV2ACTV value exceeds limits")}, "ok")
    }
    inst EMIF_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure Manually "
        prop JSName :: "emifManualConfigure"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "Advanced"
    }
    inst GCR_VALUE :: self.GCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Global Control Register "
        prop JSName :: "emifGcr"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ((($1 >> 9) && 0x0007) <= 8) {self.GCR_VALUE = $1 & 0x0EAF, self.GCR_SETUP_update($1 & 0x0EAF)} else {self.error("MEMFREQ value is reserved")}, "ok")
    }
    inst GRR_VALUE :: 0x0000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Global Reset Register "
        prop JSName :: "emifGrr"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ($1 != 0x0000) {self.GRR_VALUE = 0xFFFF, self.RESET_SETUP = 1} else {self.GRR_VALUE = 0x0000, self.RESET_SETUP = 0}, "ok")
    }
    inst CE0_SCR1_VALUE :: self.CE0_SCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE0 Space Control Register 1 "
        prop JSName :: "emifCe0scr1"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ((($1 >> 12) & 0x0007) <= 0x004) {self.CE0_SCR1_VALUE = $1 & 0x7FFF, self.CE0_SCR1_SETUP_update($1 & 0x7FFF)} else {self.error("MTYPE Value is reserved")}, "ok")
    }
    inst CE0_SCR2_VALUE :: self.CE0_SCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE0 Space Control Register 2 "
        prop JSName :: "emifCe0scr2"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE0_SCR2_VALUE = $1, self.CE0_SCR2_SETUP_update($1), "ok")
    }
    inst CE0_SCR3_VALUE :: self.CE0_SCR3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE0 Space Control Register 3 "
        prop JSName :: "emifCe0scr3"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE0_SCR3_VALUE = $1 & 0x00FF, self.CE0_TIMEOUT_SETUP = $1 & 0x00FF, "ok")
    }
    inst CE1_SCR1_VALUE :: self.CE1_SCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE1 Space Control Register 1 "
        prop JSName :: "emifCe1scr1"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ((($1 >> 12) & 0x0007) <= 0x004) {self.CE1_SCR1_VALUE = $1 & 0x7FFF, self.CE1_SCR1_SETUP_update($1 & 0x7FFF)} else {self.error("MTYPE Value is reserved")}, "ok")
    }
    inst CE1_SCR2_VALUE :: self.CE1_SCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE1 Space Control Register 2 "
        prop JSName :: "emifCe1scr2"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE1_SCR2_VALUE = $1, self.CE1_SCR2_SETUP_update($1), "ok")
    }
    inst CE1_SCR3_VALUE :: self.CE1_SCR3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE1 Space Control Register 3 "
        prop JSName :: "emifCe1scr3"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE1_SCR3_VALUE = $1 & 0x00FF, self.CE1_TIMEOUT_SETUP = $1 & 0x00FF, "ok")
    }
    inst CE2_SCR1_VALUE :: self.CE2_SCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE2 Space Control Register 1 "
        prop JSName :: "emifCe2scr1"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ((($1 >> 12) & 0x0007) <= 0x004) {self.CE2_SCR1_VALUE = $1 & 0x7FFF, self.CE2_SCR1_SETUP_update($1 & 0x7FFF)} else {self.error("MTYPE Value is reserved")}, "ok")
    }
    inst CE2_SCR2_VALUE :: self.CE2_SCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE2 Space Control Register 2 "
        prop JSName :: "emifCe2scr2"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE2_SCR2_VALUE = $1, self.CE2_SCR2_SETUP_update($1), "ok")
    }
    inst CE2_SCR3_VALUE :: self.CE2_SCR3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE2 Space Control Register 3 "
        prop JSName :: "emifCe2scr3"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE2_SCR3_VALUE = $1 & 0x00FF, self.CE2_TIMEOUT_SETUP = $1 & 0x00FF, "ok")
    }
    inst CE3_SCR1_VALUE :: self.CE3_SCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE3 Space Control Register 1 "
        prop JSName :: "emifCe3scr1"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ((($1 >> 12) & 0x0007) <= 0x004) {self.CE3_SCR1_VALUE = $1 & 0x7FFF, self.CE3_SCR1_SETUP_update($1 & 0x7FFF)} else {self.error("MTYPE Value is reserved")}, "ok")
    }
    inst CE3_SCR2_VALUE :: self.CE3_SCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE3 Space Control Register 2 "
        prop JSName :: "emifCe3scr2"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE3_SCR2_VALUE = $1, self.CE3_SCR2_SETUP_update($1), "ok")
    }
    inst CE3_SCR3_VALUE :: self.CE3_SCR3_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "CE3 Space Control Register 3 "
        prop JSName :: "emifCe3scr3"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.CE3_SCR3_VALUE = $1 & 0x00FF, self.CE3_TIMEOUT_SETUP = $1 & 0x00FF, "ok")
    }
    inst SDCR1_VALUE :: self.SDCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "SDRAM Control Register 1 "
        prop JSName :: "emifSdcr1"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.SDCR1_VALUE = $1, self.SDCR1_SETUP_update($1), "ok")
    }
    inst SDPERIOD_VALUE :: self.SDPERIOD_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "SDRAM Period Register "
        prop JSName :: "emifSdperiodAdv"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.SDPERIOD_VALUE = $1 & 0x0FFF, self.SDPERIOD_SETUP = $1 & 0x0FFF, "ok")
    }
    inst SDINIT_VALUE :: self.SDINIT_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "SDRAM Initialization Register "
        prop JSName :: "emifSdinitAdv"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (if ($1 != 0x0000) {self.SDINIT_SETUP = 1, self.SDINIT_VALUE = 0xFFFF} else {self.SDINIT_SETUP = 0, self.SDINIT_VALUE = 0}, "ok")
    }
    inst SDCR2_VALUE :: self.SDCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "SDRAM Control Register 2 "
        prop JSName :: "emifSdcr2"
        prop Visible :: 1
        prop Writable :: self.EMIF_man
        prop NoGen :: 1
        prop cGen :: 1
        prop TabName :: "Advanced"
        prop Set :: (self.SDCR2_VALUE = $1 & 0x07FF, self.SDCR2_SETUP_update($1 & 0x07FF), "ok")
    }
}

type hEMIF {
    isa ObjectMgr
    prop name :: "hEMIF"
    prop Label :: "EMIF Resource Manager"
    prop JSName :: "HEMIF"
    prop GlobalHelpTopic :: 1042
    prop InstanceHelpTopic :: 1042
    prop GlobalIcon :: 163
    prop InstanceIcon :: 164
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: EMIFFOLDER
    prop maxObjs :: (if (GBL.CHIPTYPE == "5510") {1} else {1})
    prop NoGen :: 1
    prop cGen :: 1
    prop cHandle :: 0
    prop cHeaderName :: if self.c55emif == 1 {"csl_emif.h"} else {""}
    prop cConfigName :: "EMIF_config"
    prop emifRstFxnName :: (if (hEMIF.GblEmifReset) {"EMIF_RSET(EMIRST,0xFFFFu);"} else {""})
    prop cGenFxnEpilogue :: ("\n\t%1S\n\0,emifRstFxnName")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55emif :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x EMIF opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global GblEmifReset :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Global Reset of EMIF"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable pre-initialization "
        prop JSName :: "emifEnablePreInit"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; emifCfg) {$a = 1}, if ($a == 0) {"You must create a configuration object"} else {self.PINIT_ENABLE = $1, self.cConfigArg0 = EMIF_NOTHING}, if ($1 == 1) {self.c55emif = 1} else {self.c55emif = 0}, "ok")
    }
    inst cConfigGen :: = ((self.PINIT_ENABLE == 1) && (self.cConfigArg0 != EMIF_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: EMIF_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: emifCfg
        prop Label :: "Pre-initialize "
        prop JSName :: "emifPreInit"
        prop Visible :: 1
        prop Writable :: (self.PINIT_ENABLE == 1)
        prop NoGen :: 0
        prop cPreVal :: "&"
        prop Set :: (self.cConfigArg0 = $1, "ok")
    }
}

object EMIF_NOTHING :: emifCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param CE0_MTYPE_SETUP :: "32-bit wide Asynchronous"
    param CE0_RDSET_SETUP :: 15
    param CE0_WRSET_SETUP :: 15
    param CE0_RDSTROBE_SETUP :: 63
    param CE0_WRSTROBE_SETUP :: 63
    param CE0_RDHOLD_SETUP :: 3
    param CE0_WRHOLD_SETUP :: 3
    param CE0_EXRDHOLD_SETUP :: 1
    param CE0_EXWRHOLD_SETUP :: 1
    param CE0_TIMEOUT_SETUP :: 0
    param CE1_MTYPE_SETUP :: "32-bit wide Asynchronous"
    param CE1_RDSET_SETUP :: 15
    param CE1_WRSET_SETUP :: 15
    param CE1_RDSTROBE_SETUP :: 63
    param CE1_WRSTROBE_SETUP :: 63
    param CE1_RDHOLD_SETUP :: 3
    param CE1_WRHOLD_SETUP :: 3
    param CE1_EXRDHOLD_SETUP :: 1
    param CE1_EXWRHOLD_SETUP :: 1
    param CE1_TIMEOUT_SETUP :: 0
    param CE2_MTYPE_SETUP :: "32-bit wide Asynchronous"
    param CE2_RDSET_SETUP :: 15
    param CE2_WRSET_SETUP :: 15
    param CE2_RDSTROBE_SETUP :: 63
    param CE2_WRSTROBE_SETUP :: 63
    param CE2_RDHOLD_SETUP :: 3
    param CE2_WRHOLD_SETUP :: 3
    param CE2_EXRDHOLD_SETUP :: 1
    param CE2_EXWRHOLD_SETUP :: 1
    param CE2_TIMEOUT_SETUP :: 0
    param CE3_MTYPE_SETUP :: "32-bit wide Asynchronous"
    param CE3_RDSET_SETUP :: 15
    param CE3_WRSET_SETUP :: 15
    param CE3_RDSTROBE_SETUP :: 63
    param CE3_WRSTROBE_SETUP :: 63
    param CE3_RDHOLD_SETUP :: 3
    param CE3_WRHOLD_SETUP :: 3
    param CE3_EXRDHOLD_SETUP :: 1
    param CE3_EXWRHOLD_SETUP :: 1
    param CE3_TIMEOUT_SETUP :: 0
    param RESET_SETUP :: 0
    param MEMCEN_SETUP :: "CLKMEM Enabled to Clock"
    param MEMFREQ_SETUP :: "CLKMEM = DSP Clock"
    param NOHOLD_SETUP :: "Hold Enabled"
    param WPE_SETUP :: "Disabled"
    param SDINIT_SETUP :: 0
    param SDACC_SETUP :: "16-bits wide (D[15:0])"
    param SDSIZE_SETUP :: "64Mbit"
    param SDWID_SETUP :: "16-bits"
    param RFEN_SETUP :: "Enabled"
    param SDPERIOD_SETUP :: 128
    param TRP_SETUP :: 8
    param TRC_SETUP :: 31
    param TRCD_SETUP :: 4
    param TRAS_SETUP :: 15
    param TMRD_SETUP :: 3
    param TACTV_SETUP :: 15
    param EMIF_man :: 0
    param GCR_VALUE :: 32
    param GRR_VALUE :: 0
    param CE0_SCR1_VALUE :: 12287
    param CE0_SCR2_VALUE :: 24575
    param CE1_SCR1_VALUE :: 12287
    param CE1_SCR2_VALUE :: 24575
    param CE2_SCR1_VALUE :: 12287
    param CE2_SCR2_VALUE :: 24575
    param CE3_SCR1_VALUE :: 12287
    param CE3_SCR2_VALUE :: 24575
    param SDCR1_VALUE :: 63816
    param SDPERIOD_VALUE :: 128
    param SDINIT_VALUE :: 0
    param SDCR2_VALUE :: 1023
}

object hEMIF0 :: hEMIF {
    param iComment :: "EMIF"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hEMIF"
    param iDelMsg :: "EMIF"
    param PINIT_ENABLE :: 1
    param cConfigArg0 :: emifCfg0
}

type GPIOFOLDER {
    prop Label :: "GPIO - General Purpose Input/Output"
    prop GlobalIcon :: 171
    prop GlobalPropertyPage :: "{B976FB91-49A5-11d4-967C-0050048381B7}"
    prop GlobalHelpTopic :: 1050
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type gpioCfg {
    isa ObjectMgr
    prop name :: "gpioCfg"
    prop Label :: "Non-Multiplexed GPIO Configuration "
    prop JSName :: "GPIO"
    prop GlobalHelpTopic :: 1051
    prop InstanceHelpTopic :: 1051
    prop GlobalIcon :: 171
    prop InstanceIcon :: 172
    prop GlobalPropertyPage :: "{C5CB30B4-F115-11d2-84A7-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-840B-11d0-A627-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: GPIOFOLDER
    prop NoGen :: 1
    prop cHandle :: 0
    prop cGen :: 1
    prop cStruct :: 0
    prop cHeaderName :: if self.c55gpio == 1 {"csl_gpio.h"} else {""}
    prop maxObjs :: 0
    prop valueDir :: self.IODIRMSK_VALUE
    prop valueDirStr :: "GPIO_RSET(IODIR, 0x%9x);\n"
    prop valueData :: self.IODATAMSK_VALUE
    prop valueDataStr :: "GPIO_RSET(IODATA, 0x%10x);\n\n"
    prop valueAEn :: self.AIOENMSK_VALUE
    prop valueAEnStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(AGPIOEN, 0x%11x);\n"} else {""}
    prop valueADir :: self.AIODIRMSK_VALUE
    prop valueADirStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(AGPIODIR, 0x%12x);\n"} else {""}
    prop valueAData :: self.AIODATAMSK_VALUE
    prop valueADataStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(AGPIODATA, 0x%13x);\n\n"} else {""}
    prop valueGpioEn :: self.GPIOENMSK_VALUE
    prop valueGpioEnStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(GPIOEN, 0x%14x);\n"} else {""}
    prop valueGpioDir :: self.GPIODIRMSK_VALUE
    prop valueGpioDirStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(GPIODIR, 0x%15x);\n"} else {""}
    prop valueGpioData :: self.GPIODIRMSK_VALUE
    prop valueGpioDataStr :: if (GBL.CHIPTYPE == "5509") {"GPIO_RSET(GPIODATA, 0x%16x);"} else {""}
    prop cGenFxnEpilogue :: (if (self.c55gpio == 1) {"%5t%1S%2S%3S%4S%5S%6S%7S%8S\n%0t\0,valueDirStr,valueDataStr,
						    valueAEnStr,valueADirStr,valueADataStr,
						    valueGpioEnStr,valueGpioDirStr,valueGpioDataStr,
						    valueDir,valueData,
						    valueAEn,valueADir,valueAData,
						    valueGpioEn,valueGpioDir,valueGpioData"} )
    prop ioInclStr :: "#include <_csl_gpiohal.h>\n"
    prop agpioInclStr :: if (GBL.CHIPTYPE == "5509") {"#include <_csl_pgpiohal.h>\n"} else {""}
    prop cGenCPrologue :: (if (self.c55gpio == 1) {"%1S%2S\n\n\0, ioInclStr, agpioInclStr"} )
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55gpio :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x GPIO opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global configGPIO :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-initialization "
        prop JSName :: "gpioConfigure"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "General"
        prop Set :: (self.configGPIO = $1, if ($1 == 1) {self.c55gpio = 1} else {self.c55gpio = 0}, "ok")
    }
    global iodirIOMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "IODIR I/O Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
    }
    global iodataIOMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "IODATA I/O Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
    }
    global IODIR0_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO0 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo0dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR0_IO = $1, if (self.IODIR0_IO == "Output Low") {self.iodirIOMask |= (0x0001), self.iodataIOMask &= (0xFFFE)} else {if (self.IODIR0_IO == "Output High") {self.iodirIOMask |= (0x0001), self.iodataIOMask |= (0x0001)} else {self.iodirIOMask &= (0xFFFE), self.iodataIOMask &= (0xFFFE)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR1_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO1 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo1dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR1_IO = $1, if (self.IODIR1_IO == "Output Low") {self.iodirIOMask |= (0x0002), self.iodataIOMask &= (0xFFFD)} else {if (self.IODIR1_IO == "Output High") {self.iodirIOMask |= (0x0002), self.iodataIOMask |= (0x0002)} else {self.iodirIOMask &= (0xFFFD), self.iodataIOMask &= (0xFFFD)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR2_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO2 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo2dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR2_IO = $1, if (self.IODIR2_IO == "Output Low") {self.iodirIOMask |= (0x0004), self.iodataIOMask &= (0xFFFB)} else {if (self.IODIR2_IO == "Output High") {self.iodirIOMask |= (0x0004), self.iodataIOMask |= (0x0004)} else {self.iodirIOMask &= (0xFFFB), self.iodataIOMask &= (0xFFFB)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR3_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO3 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo3dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR3_IO = $1, if (self.IODIR3_IO == "Output Low") {self.iodirIOMask |= (0x0008), self.iodataIOMask &= (0xFFF7)} else {if (self.IODIR3_IO == "Output High") {self.iodirIOMask |= (0x0008), self.iodataIOMask |= (0x0008)} else {self.iodirIOMask &= (0xFFF7), self.iodataIOMask &= (0xFFF7)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR4_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO4 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo4dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR4_IO = $1, if (self.IODIR4_IO == "Output Low") {self.iodirIOMask |= (0x0010), self.iodataIOMask &= (0xFFEF)} else {if (self.IODIR4_IO == "Output High") {self.iodirIOMask |= (0x0010), self.iodataIOMask |= (0x0010)} else {self.iodirIOMask &= (0xFFEF), self.iodataIOMask &= (0xFFEF)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR5_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO5 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo5dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR5_IO = $1, if (self.IODIR5_IO == "Output Low") {self.iodirIOMask |= (0x0020), self.iodataIOMask &= (0xFFDF)} else {if (self.IODIR5_IO == "Output High") {self.iodirIOMask |= (0x0020), self.iodataIOMask |= (0x0020)} else {self.iodirIOMask &= (0xFFDF), self.iodataIOMask &= (0xFFDF)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR6_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO6 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo6dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR6_IO = $1, if (self.IODIR6_IO == "Output Low") {self.iodirIOMask |= (0x0040), self.iodataIOMask &= (0xFFBF)} else {if (self.IODIR6_IO == "Output High") {self.iodirIOMask |= (0x0040), self.iodataIOMask |= (0x0040)} else {self.iodirIOMask &= (0xFFBF), self.iodataIOMask &= (0xFFBF)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global IODIR7_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "IO7 "
        prop Enum :: "Input,Output Low,Output High"
        prop JSName :: "gpioIo7dir"
        prop Visible :: 1
        prop Writable :: self.configGPIO
        prop NoGen :: 1
        prop TabName :: "Non-Power Down I/O Pins"
        prop Set :: (self.IODIR7_IO = $1, if (self.IODIR7_IO == "Output Low") {self.iodirIOMask |= (0x0080), self.iodataIOMask &= (0xFF7F)} else {if (self.IODIR7_IO == "Output High") {self.iodirIOMask |= (0x0080), self.iodataIOMask |= (0x0080)} else {self.iodirIOMask &= (0xFF7F), self.iodataIOMask &= (0xFF7F)}}, self.IODIRMSK_VALUE = self.iodirIOMask, self.IODATAMSK_VALUE = self.iodataIOMask, "ok")
    }
    global NOTE :: "These pins cannot be configured, via software, to be held active/inactive at CPU power-down" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Non-Power Down I/O Pins"
        prop NoGen :: 1
    }
    global aiodirMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "AIODIR I/O Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: ebselCfg.ADDRESS
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
    }
    global aiodataMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "AIODATA I/O Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: ebselCfg.ADDRESS
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
    }
    global aioenMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "AIOEN I/O Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: ebselCfg.ADDRESS
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
    }
    global AGPIODIR0 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO0 "
        prop JSName :: "gpioAgpio0dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR0 = $1, if (self.AGPIODIR0 == "Disabled") {self.aioenMask &= (0xFFFE), self.aiodirMask &= (0xFFFE), self.aiodataMask &= (0xFFFE)} else {self.aioenMask |= (0x0001), if (self.AGPIODIR0 == "Output Low") {self.aiodirMask |= (0x0001), self.aiodataMask &= (0xFFFE)} else {if (self.AGPIODIR0 == "Output High") {self.aiodirMask |= (0x0001), self.aiodataMask |= (0x0001)} else {self.aiodirMask &= (0xFFFE), self.aiodataMask &= (0xFFFE)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR1 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO1 "
        prop JSName :: "gpioAgpio1dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR1 = $1, if (self.AGPIODIR1 == "Disabled") {self.aioenMask &= (0xFFFD), self.aiodirMask &= (0xFFFD), self.aiodataMask &= (0xFFFD)} else {self.aioenMask |= (0x0002), if (self.AGPIODIR1 == "Output Low") {self.aiodirMask |= (0x0002), self.aiodataMask &= (0xFFFD)} else {if (self.AGPIODIR1 == "Output High") {self.aiodirMask |= (0x0002), self.aiodataMask |= (0x0002)} else {self.aiodirMask &= (0xFFFD), self.aiodataMask &= (0xFFFD)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR2 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO2 "
        prop JSName :: "gpioAgpio2dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR2 = $1, if (self.AGPIODIR2 == "Disabled") {self.aioenMask &= (0xFFFB), self.aiodirMask &= (0xFFFB), self.aiodataMask &= (0xFFFB)} else {self.aioenMask |= (0x0004), if (self.AGPIODIR2 == "Output Low") {self.aiodirMask |= (0x0004), self.aiodataMask &= (0xFFFB)} else {if (self.AGPIODIR2 == "Output High") {self.aiodirMask |= (0x0004), self.aiodataMask |= (0x0004)} else {self.aiodirMask &= (0xFFFB), self.aiodataMask &= (0xFFFB)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR3 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO3 "
        prop JSName :: "gpioAgpio3dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR3 = $1, if (self.AGPIODIR3 == "Disabled") {self.aioenMask &= (0xFFF7), self.aiodirMask &= (0xFFF7), self.aiodataMask &= (0xFFF7)} else {self.aioenMask |= (0x0008), if (self.AGPIODIR3 == "Output Low") {self.aiodirMask |= (0x0008), self.aiodataMask &= (0xFFF7)} else {if (self.AGPIODIR3 == "Output High") {self.aiodirMask |= (0x0008), self.aiodataMask |= (0x0008)} else {self.aiodirMask &= (0xFFF7), self.aiodataMask &= (0xFFF7)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR4 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO4 "
        prop JSName :: "gpioAgpio4dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR4 = $1, if (self.AGPIODIR4 == "Disabled") {self.aioenMask &= (0xFFEF), self.aiodirMask &= (0xFFEF), self.aiodataMask &= (0xFFEF)} else {self.aioenMask |= (0x0010), if (self.AGPIODIR4 == "Output Low") {self.aiodirMask |= (0x0010), self.aiodataMask &= (0xFFEF)} else {if (self.AGPIODIR4 == "Output High") {self.aiodirMask |= (0x0010), self.aiodataMask |= (0x0010)} else {self.aiodirMask &= (0xFFEF), self.aiodataMask &= (0xFFEF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR5 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO5 "
        prop JSName :: "gpioAgpio5dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR5 = $1, if (self.AGPIODIR5 == "Disabled") {self.aioenMask &= (0xFFDF), self.aiodirMask &= (0xFFDF), self.aiodataMask &= (0xFFDF)} else {self.aioenMask |= (0x0020), if (self.AGPIODIR5 == "Output Low") {self.aiodirMask |= (0x0020), self.aiodataMask &= (0xFFDF)} else {if (self.AGPIODIR5 == "Output High") {self.aiodirMask |= (0x0020), self.aiodataMask |= (0x0020)} else {self.aiodirMask &= (0xFFDF), self.aiodataMask &= (0xFFDF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR6 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO6 "
        prop JSName :: "gpioAgpio6dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR6 = $1, if (self.AGPIODIR6 == "Disabled") {self.aioenMask &= (0xFFBF), self.aiodirMask &= (0xFFBF), self.aiodataMask &= (0xFFBF)} else {self.aioenMask |= (0x0040), if (self.AGPIODIR6 == "Output Low") {self.aiodirMask |= (0x0040), self.aiodataMask &= (0xFFBF)} else {if (self.AGPIODIR6 == "Output High") {self.aiodirMask |= (0x0040), self.aiodataMask |= (0x0040)} else {self.aiodirMask &= (0xFFBF), self.aiodataMask &= (0xFFBF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR7 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO7 "
        prop JSName :: "gpioAgpio7dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR7 = $1, if (self.AGPIODIR7 == "Disabled") {self.aioenMask &= (0xFF7F), self.aiodirMask &= (0xFF7F), self.aiodataMask &= (0xFF7F)} else {self.aioenMask |= (0x0080), if (self.AGPIODIR7 == "Output Low") {self.aiodirMask |= (0x0080), self.aiodataMask &= (0xFF7F)} else {if (self.AGPIODIR7 == "Output High") {self.aiodirMask |= (0x0080), self.aiodataMask |= (0x0080)} else {self.aiodirMask &= (0xFF7F), self.aiodataMask &= (0xFF7F)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR8 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO8 "
        prop JSName :: "gpioAgpio8dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR8 = $1, if (self.AGPIODIR8 == "Disabled") {self.aioenMask &= (0xFEFF), self.aiodirMask &= (0xFEFF), self.aiodataMask &= (0xFEFF)} else {self.aioenMask |= (0x0100), if (self.AGPIODIR8 == "Output Low") {self.aiodirMask |= (0x0100), self.aiodataMask &= (0xFEFF)} else {if (self.AGPIODIR8 == "Output High") {self.aiodirMask |= (0x0100), self.aiodataMask |= (0x0100)} else {self.aiodirMask &= (0xFEFF), self.aiodataMask &= (0xFEFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR9 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO9 "
        prop JSName :: "gpioAgpio9dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR9 = $1, if (self.AGPIODIR9 == "Disabled") {self.aioenMask &= (0xFDFF), self.aiodirMask &= (0xFDFF), self.aiodataMask &= (0xFDFF)} else {self.aioenMask |= (0x0200), if (self.AGPIODIR9 == "Output Low") {self.aiodirMask |= (0x0200), self.aiodataMask &= (0xFDFF)} else {if (self.AGPIODIR9 == "Output High") {self.aiodirMask |= (0x0200), self.aiodataMask |= (0x0200)} else {self.aiodirMask &= (0xFDFF), self.aiodataMask &= (0xFDFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR10 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO10 "
        prop JSName :: "gpioAgpio10dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR10 = $1, if (self.AGPIODIR10 == "Disabled") {self.aioenMask &= (0xFBFF), self.aiodirMask &= (0xFBFF), self.aiodataMask &= (0xFBFF)} else {self.aioenMask |= (0x0400), if (self.AGPIODIR10 == "Output Low") {self.aiodirMask |= (0x0400), self.aiodataMask &= (0xFBFF)} else {if (self.AGPIODIR10 == "Output High") {self.aiodirMask |= (0x0400), self.aiodataMask |= (0x0400)} else {self.aiodirMask &= (0xFBFF), self.aiodataMask &= (0xFBFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR11 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO11 "
        prop JSName :: "gpioAgpio11dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR11 = $1, if (self.AGPIODIR11 == "Disabled") {self.aioenMask &= (0xF7FF), self.aiodirMask &= (0xF7FF), self.aiodataMask &= (0xF7FF)} else {self.aioenMask |= (0x0800), if (self.AGPIODIR11 == "Output Low") {self.aiodirMask |= (0x0800), self.aiodataMask &= (0xF7FF)} else {if (self.AGPIODIR11 == "Output High") {self.aiodirMask |= (0x0800), self.aiodataMask |= (0x0800)} else {self.aiodirMask &= (0xF7FF), self.aiodataMask &= (0xF7FF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR12 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO12 "
        prop JSName :: "gpioAgpio12dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR12 = $1, if (self.AGPIODIR12 == "Disabled") {self.aioenMask &= (0xEFFF), self.aiodirMask &= (0xEFFF), self.aiodataMask &= (0xEFFF)} else {self.aioenMask |= (0x1000), if (self.AGPIODIR12 == "Output Low") {self.aiodirMask |= (0x1000), self.aiodataMask &= (0xEFFF)} else {if (self.AGPIODIR12 == "Output High") {self.aiodirMask |= (0x1000), self.aiodataMask |= (0x1000)} else {self.aiodirMask &= (0xEFFF), self.aiodataMask &= (0xEFFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR13 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO13 "
        prop JSName :: "gpioAgpio13dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR13 = $1, if (self.AGPIODIR13 == "Disabled") {self.aioenMask &= (0xDFFF), self.aiodirMask &= (0xDFFF), self.aiodataMask &= (0xDFFF)} else {self.aioenMask |= (0x2000), if (self.AGPIODIR13 == "Output Low") {self.aiodirMask |= (0x2000), self.aiodataMask &= (0xDFFF)} else {if (self.AGPIODIR13 == "Output High") {self.aiodirMask |= (0x2000), self.aiodataMask |= (0x2000)} else {self.aiodirMask &= (0xDFFF), self.aiodataMask &= (0xDFFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR14 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO14 "
        prop JSName :: "gpioAgpio14dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR14 = $1, if (self.AGPIODIR14 == "Disabled") {self.aioenMask &= (0xBFFF), self.aiodirMask &= (0xBFFF), self.aiodataMask &= (0xBFFF)} else {self.aioenMask |= (0x4000), if (self.AGPIODIR14 == "Output Low") {self.aiodirMask |= (0x4000), self.aiodataMask &= (0xBFFF)} else {if (self.AGPIODIR14 == "Output High") {self.aiodirMask |= (0x4000), self.aiodataMask |= (0x4000)} else {self.aiodirMask &= (0xBFFF), self.aiodataMask &= (0xBFFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global AGPIODIR15 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "AGPIO15 "
        prop JSName :: "gpioAgpio15dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO) && (ebselCfg.ADDRESS)
        prop NoGen :: 1
        prop TabName :: "Power Down Address I/O Pins"
        prop Set :: (self.AGPIODIR15 = $1, if (self.AGPIODIR15 == "Disabled") {self.aioenMask &= (0x7FFF), self.aiodirMask &= (0x7FFF), self.aiodataMask &= (0x7FFF)} else {self.aioenMask |= (0x8000), if (self.AGPIODIR15 == "Output Low") {self.aiodirMask |= (0x8000), self.aiodataMask &= (0x7FFF)} else {if (self.AGPIODIR15 == "Output High") {self.aiodirMask |= (0x8000), self.aiodataMask |= (0x8000)} else {self.aiodirMask &= (0x7FFF), self.aiodataMask &= (0x7FFF)}}}, self.AIOENMSK_VALUE = self.aioenMask, self.AIODIRMSK_VALUE = self.aiodirMask, self.AIODATAMSK_VALUE = self.aiodataMask, "ok")
    }
    global WARNING :: "Do not write to A14 - A15 for 5509 QFP packages! " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Power Down Address I/O Pins"
        prop NoGen :: 1
    }
    global gpioenMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "GPIOEN Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
    }
    global gpiodirMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "GPIODIR Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
    }
    global gpiodataMask :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "GPIODATA Mask"
        prop Format :: "0x%04x"
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
    }
    global GPIODIR8 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO8 "
        prop JSName :: "gpioGpio8dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR8 = $1, if (self.GPIODIR8 == "Disabled") {self.gpioenMask &= (0xFFFE), self.gpiodirMask &= (0xFFFE), self.gpiodataMask &= (0xFFFE)} else {self.gpioenMask |= (0x0001), if (self.GPIODIR8 == "Output Low") {self.gpiodirMask |= (0x0001), self.gpiodataMask &= (0xFFFE)} else {if (self.GPIODIR8 == "Output High") {self.gpiodirMask |= (0x0001), self.gpiodataMask |= (0x0001)} else {self.gpiodirMask &= (0xFFFE), self.gpiodataMask &= (0xFFFE)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global GPIODIR9 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO9 "
        prop JSName :: "gpioGpio9dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR9 = $1, if (self.GPIODIR9 == "Disabled") {self.gpioenMask &= (0xFFFD), self.gpiodirMask &= (0xFFFD), self.gpiodataMask &= (0xFFFD)} else {self.gpioenMask |= (0x0002), if (self.GPIODIR9 == "Output Low") {self.gpiodirMask |= (0x0002), self.gpiodataMask &= (0xFFFD)} else {if (self.GPIODIR9 == "Output High") {self.gpiodirMask |= (0x0002), self.gpiodataMask |= (0x0002)} else {self.gpiodirMask &= (0xFFFD), self.gpiodataMask &= (0xFFFD)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global GPIODIR10 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO10 "
        prop JSName :: "gpioGpio10dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR10 = $1, if (self.GPIODIR10 == "Disabled") {self.gpioenMask &= (0xFFFB), self.gpiodirMask &= (0xFFFB), self.gpiodataMask &= (0xFFFB)} else {self.gpioenMask |= (0x0004), if (self.GPIODIR10 == "Output Low") {self.gpiodirMask |= (0x0004), self.gpiodataMask &= (0xFFFB)} else {if (self.GPIODIR10 == "Output High") {self.gpiodirMask |= (0x0004), self.gpiodataMask |= (0x0004)} else {self.gpiodirMask &= (0xFFFB), self.gpiodataMask &= (0xFFFB)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global GPIODIR11 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO11 "
        prop JSName :: "gpioGpio11dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR11 = $1, if (self.GPIODIR11 == "Disabled") {self.gpioenMask &= (0xFFF7), self.gpiodirMask &= (0xFFF7), self.gpiodataMask &= (0xFFF7)} else {self.gpioenMask |= (0x0008), if (self.GPIODIR11 == "Output Low") {self.gpiodirMask |= (0x0008), self.gpiodataMask &= (0xFFF7)} else {if (self.GPIODIR11 == "Output High") {self.gpiodirMask |= (0x0008), self.gpiodataMask |= (0x0008)} else {self.gpiodirMask &= (0xFFF7), self.gpiodataMask &= (0xFFF7)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global GPIODIR12 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO12 "
        prop JSName :: "gpioGpio12dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR12 = $1, if (self.GPIODIR12 == "Disabled") {self.gpioenMask &= (0xFFEF), self.gpiodirMask &= (0xFFEF), self.gpiodataMask &= (0xFFEF)} else {self.gpioenMask |= (0x0010), if (self.GPIODIR12 == "Output Low") {self.gpiodirMask |= (0x0010), self.gpiodataMask &= (0xFFEF)} else {if (self.GPIODIR12 == "Output High") {self.gpiodirMask |= (0x0010), self.gpiodataMask |= (0x0010)} else {self.gpiodirMask &= (0xFFEF), self.gpiodataMask &= (0xFFEF)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global GPIODIR13 :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Input,Output Low,Output High"
        prop Label :: "GPIO13 "
        prop JSName :: "gpioGpio13dir"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.configGPIO)
        prop NoGen :: 1
        prop TabName :: "Power Down I/O Pins"
        prop Set :: (self.GPIODIR13 = $1, if (self.GPIODIR13 == "Disabled") {self.gpioenMask &= (0xFFDF), self.gpiodirMask &= (0xFFDF), self.gpiodataMask &= (0xFFDF)} else {self.gpioenMask |= (0x0020), if (self.GPIODIR13 == "Output Low") {self.gpiodirMask |= (0x0020), self.gpiodataMask &= (0xFFDF)} else {if (self.GPIODIR13 == "Output High") {self.gpiodirMask |= (0x0020), self.gpiodataMask |= (0x0020)} else {self.gpiodirMask &= (0xFFDF), self.gpiodataMask &= (0xFFDF)}}}, self.GPIOENMSK_VALUE = self.gpioenMask, self.GPIODIRMSK_VALUE = self.gpiodirMask, self.GPIODATAMSK_VALUE = self.gpiodataMask, "ok")
    }
    global IODIRMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "IODIR Mask "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global IODATAMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "IODATA Mask "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global AIODIRMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "AGPIODIR Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global AIODATAMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "AGPIODATA Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global AIOENMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "AGPIOEN Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global GPIOENMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "GPIOEN Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global GPIODIRMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "GPIODIR Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global GPIODATAMSK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "GPIODATA Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type ICACHEFOLDER {
    prop Label :: "ICACHE - Instruction Cache"
    prop GlobalIcon :: IDI_ICACHE_GLOBAL
    prop GlobalPropertyPage :: "{B976FB91-49A5-11d4-967C-0050048381B7}"
    prop GlobalHelpTopic :: 1050
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type icacheCfg {
    isa ObjectMgr
    prop name :: "icacheCfg"
    prop Label :: "ICACHE Configuration "
    prop JSName :: "ICACHE"
    prop GlobalHelpTopic :: 1051
    prop InstanceHelpTopic :: 1051
    prop GlobalIcon :: IDI_ICACHE_GLOBAL
    prop InstanceIcon :: 172
    prop GlobalPropertyPage :: "{C5CB30B4-F115-11d2-84A7-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-840B-11d0-A627-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: ICACHEFOLDER
    prop NoGen :: 1
    prop cHandle :: 0
    prop cGen :: 1
    prop cStruct :: 0
    prop cHeaderName :: if self.c55icache == 1 {"csl_icache.h"} else {""}
    prop maxObjs :: 0
    prop ICACHE_SUPPORT :: ((GBL.CHIPTYPE == "5510PG2_0") || (GBL.CHIPTYPE == "5510PG2_1") || (GBL.CHIPTYPE == "5510PG2_2"))
    prop RAMSET_VALUE :: (if (self.RAMSET_SETUP == "No RAM set") {"0RAMSET"} else {if (self.RAMSET_SETUP == "1 RAM set") {"1RAMSET"} else {"2RAMSET"}})
    prop ramsetValue :: self.RAMSET_VALUE
    prop rmodeStr :: "ICACHE_RSET(ICGC, ICACHE_ICGC_RMODE_%5S);\n\n"
    prop icwcStr :: "ICACHE_FSET(ICWC, WINIT, ICACHE_ICWC_WINIT_WINIT);\n"
    prop icrc1Str :: "ICACHE_FSET(ICRC1, R1INIT, ICACHE_ICRC1_R1INIT_INIT);\n"
    prop icrc2Str :: "ICACHE_FSET(ICRC2, R2INIT, ICACHE_ICRC2_R2INIT_INIT);\n"
    prop enableStr :: "ICACHE_enable();\n\n"
    prop r1addrVal :: self.RAMSET1ADDR_SETUP
    prop r2addrVal :: self.RAMSET2ADDR_SETUP
    prop TAGS_VALUE :: (if (self.RAMSET_SETUP == "No RAM set") {""} else {if (self.RAMSET_SETUP == "1 RAM set") {"ICACHE_FSET(ICRTAG1, R1TAG, ((Uint16)((0x%8x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC1, R1TVALID));\n"} else {"ICACHE_FSET(ICRTAG1, R1TAG, ((Uint16)((0x%8x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC1, R1TVALID));\nICACHE_FSET(ICRTAG2, R2TAG, ((Uint16)((0x%9x >> 12) & 0x0FFFu)));\nwhile(!ICACHE_FGET(ICRC2, R2TVALID));\n\n"}})
    prop tagsStr :: self.TAGS_VALUE
    prop cGenFxnEpilogue :: (if ((icacheCfg.ICACHE_SUPPORT) && (self.c55icache == 1)) {"%5t%1S%2S%3S%4S%6S%7S\n%0t\0, rmodeStr,icwcStr,icrc1Str,icrc2Str,ramsetValue, 												enableStr,tagsStr,r1addrVal,r2addrVal"} )
    prop icacheInclStr :: "#include <csl_icache.h>\n"
    prop cGenCPrologue :: (if (self.c55icache == 1) {"%1S\n\n\0, icacheInclStr"} )
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55icache :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x ICACHE opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global configICACHE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Initialization "
        prop Visible :: 1
        prop Writable :: (icacheCfg.ICACHE_SUPPORT)
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "General"
        prop Set :: (self.configICACHE = $1, if ($1 == 1) {self.c55icache = 1} else {self.c55icache = 0}, "ok")
    }
    global RAMSET_SETUP :: "No RAM set" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "RAM Set Mode "
        prop JSName :: "icacheRamsetMode"
        prop Enum :: "No RAM set,1 RAM set,2 RAM sets"
        prop Visible :: 1
        prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (self.c55icache == 1))
        prop NoGen :: 1
        prop TabName :: "5510 Settings"
        prop Set :: (self.RAMSET_SETUP = $1, "ok")
    }
    global RAMSET1ADDR_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "RAM Set 1 Address "
        prop JSName :: "icacheRamset1Addr"
        prop Visible :: 1
        prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (self.c55icache == 1) && (self.RAMSET_SETUP != "No RAM set"))
        prop NoGen :: 1
        prop TabName :: "5510 Settings"
        prop Set :: (self.RAMSET1ADDR_SETUP = $1, "ok")
    }
    global RAMSET2ADDR_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%06x"
        prop Label :: "RAM Set 2 Address "
        prop JSName :: "icacheRamset2Addr"
        prop Visible :: 1
        prop Writable :: ((icacheCfg.ICACHE_SUPPORT) && (self.c55icache == 1) && (self.RAMSET_SETUP == "2 RAM sets"))
        prop NoGen :: 1
        prop TabName :: "5510 Settings"
        prop Set :: (self.RAMSET2ADDR_SETUP = $1, "ok")
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type MCBSPFOLDER {
    prop Label :: "MCBSP - Multichannel Buffered Serial Port"
    prop GlobalIcon :: 159
    prop GlobalPropertyPage :: "{B016FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1060
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type mcbspCfg {
    isa ObjectMgr
    prop name :: "MCBSP"
    prop Label :: "MCBSP Configuration Manager"
    prop JSName :: "MCBSP"
    prop GlobalHelpTopic :: 1061
    prop InstanceHelpTopic :: 1061
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop NoGen :: 1
    prop cStruct :: 1
    prop cStructType :: "MCBSP_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_mcbsp.h"} else {""}
    prop IsContainedIn :: MCBSPFOLDER
    prop IDLE_EN_PCR :: (if (self.IDLE_EN_SETUP == 1) {0x4000} else {0x0000})
    prop XIOEN_PCR :: (if (self.XIOEN_SETUP == 1) {0x0000} else {0x2000})
    prop CLKXM_PCR :: (if (self.CLKSTP_SETUP == "Disable") {if (self.CLKXM1_SETUP == "External") {(self.CLKXM2_SETUP = "Slave", 0x0000)} else {(self.CLKXM2_SETUP = "Master", 0x0200)}} else {if (self.CLKXM2_SETUP == "Slave") {(self.CLKXM1_SETUP = "External", 0x0000)} else {(self.CLKXM1_SETUP = "Internal", 0x0200)}})
    prop CLKXP_PCR :: (if (self.CLKXP_SETUP == "Rising Edge") {0x0000} else {0x0002})
    prop FSXP_PCR :: (if (self.FSXP_SETUP == "Active High") {0x0000} else {0x0008})
    prop DXENA_SUPPORT :: (1)
    prop DXENA_SPCR1 :: (if (self.DXENA_SETUP == "Enable") {0x0080} else {0x0000})
    prop XDATDLY_XCR2 :: (if (self.XDATDLY_SETUP == "0-bit") {0x0000} else {if (self.XDATDLY_SETUP == "1-bit") {0x0001} else {0x0002}})
    prop XPHASE_XCR2 :: (if (self.XPHASE_SETUP == "Single-phase") {0x0000} else {0x8000})
    prop XWDLEN1_XCR1 :: (if (self.XWDLEN1_SETUP == "12-bits") {0x0020} else {if (self.XWDLEN1_SETUP == "16-bits") {0x0040} else {if (self.XWDLEN1_SETUP == "20-bits") {0x0060} else {if (self.XWDLEN1_SETUP == "24-bits") {0x0080} else {if (self.XWDLEN1_SETUP == "32-bits") {0x00A0} else {0x0000}}}}})
    prop XWDLEN2_XCR2 :: (if (self.XWDLEN2_SETUP == "12-bits") {0x0020} else {if (self.XWDLEN2_SETUP == "16-bits") {0x0040} else {if (self.XWDLEN2_SETUP == "20-bits") {0x0060} else {if (self.XWDLEN2_SETUP == "24-bits") {0x0080} else {if (self.XWDLEN2_SETUP == "32-bits") {0x00A0} else {0x0000}}}}})
    prop XFRLEN1_XCR1 :: ((self.XFRLEN1_SETUP - 1) << 8)
    prop XFRLEN2_XCR2 :: ((self.XFRLEN2_SETUP - 1) << 8)
    prop XSYNCERR_SPCR2 :: (if (self.XSYNCERR_SETUP == "Enable") {0x0008} else {0x0000})
    prop XINTM_SPCR2 :: (if (self.XINTM_SETUP == "XRDY") {0x0000} else {if (self.XINTM_SETUP == "End of block/frame") {0x0010} else {if (self.XINTM_SETUP == "New Frame Sync.") {0x0020} else {0x0030}}})
    prop FSXM_PCR :: (if (self.FSXM_SETUP == "External") {0x0000} else {0x0800})
    prop XFIG_XCR2 :: (if (self.XFIG_SETUP == "Restart Transfer") {0x0000} else {0x0004})
    prop XCOMPAND_XCR2 :: (if (self.XCOMPAND_SETUP == "No Companding-MSB First") {0x0000} else {if (self.XCOMPAND_SETUP == "No Companding-LSB First") {0x0008} else {if (self.XCOMPAND_SETUP == "u-Law") {0x0010} else {0x0018}}})
    prop FSXM_FSGM_SETUP_update :: (if ((self.FSXM_SETUP == "External") && (self.FSGM_SETUP == "Disable")) {"External"} else {if ((self.FSXM_SETUP == "Sample Rate Gen") && (self.FSGM_SETUP == "Disable")) {"DXR[1/2]-to-XSR[1/2] Copy"} else {"FSG Signal"}})
    prop RIOEN_PCR :: (if (self.RIOEN_SETUP == 1) {0x0000} else {0x1000})
    prop CLKRM_PCR :: (if (self.DLB_SETUP == "Disable") {if (self.CLKRM1_SETUP == "External") {(self.CLKRM2_SETUP = "CLKX Driven", 0x0000)} else {(self.CLKRM2_SETUP = "CLKR as Output", 0x0100)}} else {if (self.CLKRM2_SETUP == "CLKX Driven") {(self.CLKRM1_SETUP = "External", 0x0000)} else {(self.CLKRM1_SETUP = "Internal", 0x0100)}})
    prop CLKRP_PCR :: (if (self.CLKRP_SETUP == "Rising Edge") {0x0001} else {0x0000})
    prop FSRP_PCR :: (if (self.FSRP_SETUP == "Active High") {0x0000} else {0x0004})
    prop RDATDLY_RCR2 :: (if (self.RDATDLY_SETUP == "0-bit") {0x0000} else {if (self.RDATDLY_SETUP == "1-bit") {0x0001} else {0x0002}})
    prop RPHASE_RCR2 :: (if (self.RPHASE_SETUP == "Single-phase") {0x0000} else {0x8000})
    prop RWDLEN1_RCR1 :: (if (self.RWDLEN1_SETUP == "8-bits") {0x0000} else {if (self.RWDLEN1_SETUP == "12-bits") {0x0020} else {if (self.RWDLEN1_SETUP == "16-bits") {0x0040} else {if (self.RWDLEN1_SETUP == "20-bits") {0x0060} else {if (self.RWDLEN1_SETUP == "24-bits") {0x0080} else {0x00A0}}}}})
    prop RWDLEN2_RCR2 :: (if (self.RWDLEN2_SETUP == "8-bits") {0x0000} else {if (self.RWDLEN2_SETUP == "12-bits") {0x0020} else {if (self.RWDLEN2_SETUP == "16-bits") {0x0040} else {if (self.RWDLEN2_SETUP == "20-bits") {0x0060} else {if (self.RWDLEN2_SETUP == "24-bits") {0x0080} else {0x00A0}}}}})
    prop RFRLEN1_RCR1 :: ((self.RFRLEN1_SETUP - 1) << 8)
    prop RFRLEN2_RCR2 :: ((self.RFRLEN2_SETUP - 1) << 8)
    prop RSYNCERR_SPCR1 :: (if (self.RSYNCERR_SETUP == "Enable") {0x0008} else {0x0000})
    prop RINTM_SPCR1 :: (if (self.RINTM_SETUP == "RRDY") {0x0000} else {if (self.RINTM_SETUP == "End of block/frame") {0x0010} else {if (self.RINTM_SETUP == "New Frame Sync.") {0x0020} else {0x0030}}})
    prop FSRM_PCR :: (if (self.FSRM_SETUP == "External") {0x0000} else {0x0400})
    prop RFIG_RCR2 :: (if (self.RFIG_SETUP == "Restart Transfer") {0x0000} else {0x0004})
    prop RJUST_SPCR1 :: (if (self.RJUST_SETUP == "Right-justify/zero-fill") {0x0000} else {if (self.RJUST_SETUP == "Right-justify/sign-extend") {0x2000} else {0x4000}})
    prop RCOMPAND_RCR2 :: (if (self.RCOMPAND_SETUP == "No Companding-MSB First") {0x0000} else {if (self.RCOMPAND_SETUP == "No Companding-LSB First") {0x0008} else {if (self.RCOMPAND_SETUP == "u-Law") {0x0010} else {0x0018}}})
    prop FREE_SOFT_SPCR2 :: (if (self.FREE_SOFT_SETUP == "Stop Immediately") {0x0000} else {if (self.FREE_SOFT_SETUP == "Stop After Current Word") {0x0100} else {0x0200}})
    prop CLKSTP_SPCR1 :: (if (self.CLKSTP_SETUP == "Disable") {0x0000} else {if (self.CLKSTP_SETUP == "Rising Edge w/o Delay") {(self.CLKXP_SETUP = "Rising Edge", 0x1000)} else {if (self.CLKSTP_SETUP == "Falling Edge w/o Delay") {(self.CLKXP_SETUP = "Falling Edge", 0x1000)} else {if (self.CLKSTP_SETUP == "Rising Edge w/ Delay") {(self.CLKXP_SETUP = "Rising Edge", 0x1800)} else {(self.CLKXP_SETUP = "Falling Edge", 0x1800)}}}})
    prop DLB_SPCR1 :: (if (self.DLB_SETUP == "Enable") {0x8000} else {0x0000})
    prop ABIS_SPCR1 :: (if (self.ABIS_SETUP == "Enable") {0x0040} else {0x0000})
    prop CLKSM_SRGR2 :: (if ((self.CLKSM_SETUP == "CPU Clock") || (self.CLKSM_SETUP == "BCLKX Pin")) {0x2000} else {0x0000})
    prop SCLKME_PCR :: (if (self.SCLKME_SETUP == "BCLKX Pin") {0x0080} else {if (self.SCLKME_SETUP == "BCLKR Pin") {0x0080} else {0x0000}})
    prop GSYNC_SRGR2 :: (if (self.GSYNC_SETUP == "Enable") {0x8000} else {0x0000})
    prop CLKSTP_SETUP_update :: (if ((self.SPCR1_VALUE & 0x1800) == (0x1800)) {(if (self.PCR_VALUE & 0x0002) {"Falling Edge"} else {"Rising Edge w/ Delay"})} else {if (self.SPCR1_VALUE & 0x1000) {(if (self.PCR_VALUE & 0x0002) {"Falling Edge w/o Delay"} else {"Rising Edge w/o Delay"})} else {"Disable"}})
    prop CLKSP_SRGR2 :: (if (self.CLKSP_SETUP == "Rising Edge of CLKS") {0x0000} else {0x4000})
    prop FSGM_SRGR2 :: (if (self.FSGM_SETUP == "Enable") {0x1000} else {0x0000})
    prop FWID_SRGR1 :: ((self.FWID_SETUP - 1) << 8)
    prop CLKGDV_SRGR1 :: (self.CLKGDV_SETUP - 1)
    prop FPER_SRGR2 :: (self.FPER_SETUP - 1)
    prop CLKS_SUPPORT :: (1)
    prop MCR1_VALUE_update :: (self.RPBBLK_MCR1() | self.RPABLK_MCR1() | self.RMCM_MCR1() | self.RMCME_MCR1())
    prop MCR2_VALUE_update :: (self.XPBBLK_MCR2() | self.XPABLK_MCR2() | self.XMCM_MCR2() | self.XMCME_MCR2())
    prop PCR_VALUE_update :: (self.XIOEN_PCR() | self.RIOEN_PCR() | self.FSXM_PCR() | self.FSRM_PCR() | self.CLKXM_PCR() | self.CLKRM_PCR() | self.FSXP_PCR() | self.FSRP_PCR() | self.CLKXP_PCR() | self.CLKRP_PCR() | self.SCLKME_PCR() | self.IDLE_EN_PCR())
    prop RCR1_VALUE_update :: (self.RFRLEN1_RCR1() | self.RWDLEN1_RCR1())
    prop RCR2_VALUE_update :: (self.RDATDLY_RCR2() | self.RPHASE_RCR2() | self.RFRLEN2_RCR2() | self.RWDLEN2_RCR2() | self.RFIG_RCR2() | self.RCOMPAND_RCR2())
    prop SPCR1_VALUE_update :: (self.DLB_SPCR1() | self.RJUST_SPCR1() | self.CLKSTP_SPCR1() | self.DXENA_SPCR1() | self.ABIS_SPCR1() | self.RINTM_SPCR1() | self.RSYNCERR_SPCR1())
    prop SPCR2_VALUE_update :: (self.FREE_SOFT_SPCR2() | self.XSYNCERR_SPCR2() | self.XINTM_SPCR2())
    prop SRGR1_VALUE_update :: (self.FWID_SRGR1() | self.CLKGDV_SRGR1())
    prop SRGR2_VALUE_update :: (self.GSYNC_SRGR2() | self.CLKSP_SRGR2() | self.CLKSM_SRGR2() | self.FSGM_SRGR2() | self.FPER_SRGR2())
    prop XCR1_VALUE_update :: (self.XFRLEN1_XCR1() | self.XWDLEN1_XCR1())
    prop XCR2_VALUE_update :: (self.XPHASE_XCR2() | self.XFRLEN2_XCR2() | self.XWDLEN2_XCR2() | self.XCOMPAND_XCR2() | self.XFIG_XCR2() | self.XDATDLY_XCR2())
    prop PCR_SETUP_update :: (self.IDLE_EN_SETUP = if ($1 & 0x4000) {1} else {0}, self.XIOEN_SETUP = if ($1 & 0x2000) {0} else {1}, self.XIOEN2_SETUP = if ($1 & 0x2000) {0} else {1}, self.RIOEN_SETUP = if ($1 & 0x1000) {0} else {1}, self.RIOEN2_SETUP = if ($1 & 0x1000) {0} else {1}, if (self.XIOEN_SETUP == 0) {self.CLKX_IO = if ($1 & 0x0200) {"Output"} else {"Input"}, self.FSX_IO = if ($1 & 0x0800) {"Output"} else {"Input"}, if (self.RIOEN_SETUP == 0) {self.CLKR_IO = if ($1 & 0x0100) {"Output"} else {"Input"}, self.FSR_IO = if ($1 & 0x0400) {"Output"} else {"Input"}} } else {self.FSXM_SETUP = if ($1 & 0x0800) {"Sample Rate Gen"} else {"External"}, self.FSRM_SETUP = if ($1 & 0x0400) {"Sample Rate Gen"} else {"External"}, self.FSGM_SETUP = if (self.SRGR2_VALUE & 0x1000) {"Enable"} else {"Disable"}, self.FSXM_FSGM_SETUP = self.FSXM_FSGM_SETUP_update(), self.CLKXM1_SETUP = if ($1 & 0x0200) {"Internal"} else {"External"}, self.CLKXM2_SETUP = if ($1 & 0x0200) {"Master"} else {"Slave"}, self.CLKRM1_SETUP = if ($1 & 0x0100) {"Internal"} else {"External"}, self.CLKRM2_SETUP = if ($1 & 0x0100) {"CLKR as Output"} else {"CLKX Driven"}, self.FSXP_SETUP = if ($1 & 0x0008) {"Active Low"} else {"Active High"}, self.FSRP_SETUP = if ($1 & 0x0004) {"Active Low"} else {"Active High"}, self.CLKXP_SETUP = if ($1 & 0x0002) {"Falling Edge"} else {"Rising Edge"}, self.CLKRP_SETUP = if ($1 & 0x0001) {"Rising Edge"} else {"Falling Edge"}, self.CLKSTP_SETUP = self.CLKSTP_SETUP_update(), self.CLKSM_SETUP = ($a = $1 & 0x0080, if (($a == 0x0080) && (!(self.SRGR2_VALUE & 0x2000))) {"BCLKR Pin"} else {if (($a == 0x0080) && (self.SRGR2_VALUE & 0x2000)) {"BCLKX Pin"} else {if (($a == 0x0000) && (!(self.SRGR2_VALUE & 0x2000))) {"CLKS Pin"} else {"CPU Clock"}}})})
    prop RCR1_SETUP_update :: (self.RFRLEN1_SETUP = ((($1 & 0x7F00) >> 8) + 1), self.RWDLEN1_SETUP = ($a = $1 & 0x00E0, if ($a == 0x0000) {"8-bits"} else {if ($a == 0x0020) {"12-bits"} else {if ($a == 0x0040) {"16-bits"} else {if ($a == 0x0060) {"20-bits"} else {if ($a == 0x0080) {"24-bits"} else {"32-bits"}}}}}))
    prop RCR2_SETUP_update :: (self.RPHASE_SETUP = if ($1 & 0x8000) {"Dual-phase"} else {"Single-phase"}, self.RFRLEN2_SETUP = ((($1 & 0x7F00) >> 8) + 1), self.RWDLEN2_SETUP = ($a = $1 & 0x00E0, if ($a == 0x0000) {"8-bits"} else {if ($a == 0x0020) {"12-bits"} else {if ($a == 0x0040) {"16-bits"} else {if ($a == 0x0060) {"20-bits"} else {if ($a == 0x0080) {"24-bits"} else {"32-bits"}}}}}), self.RFIG_SETUP = if ($1 & 0x0004) {"Ignore"} else {"Restart Transfer"}, self.RDATDLY_SETUP = ($a = $1 & 0x0003, if ($a == 0x0000) {"0-bit"} else {if ($a == 0x0001) {"1-bit"} else {"2-bit"}}), self.RCOMPAND_SETUP = ($a = $1 & 0x0018, if ($a == 0x0000) {"No Companding-MSB First"} else {if ($a == 0x0008) {"No Companding-LSB First"} else {if ($a == 0x0010) {"u-Law"} else {"A-Law"}}}))
    prop SPCR1_SETUP_update :: (self.DLB_SETUP = if ($1 & 0x8000) {"Enable"} else {"Disable"}, self.RJUST_SETUP = ($a = $1 & 0x6000, if ($a == 0x0000) {"Right-justify/zero-fill"} else {if ($a == 0x2000) {"Right-justify/sign-extend"} else {"Left-justify/zero-fill"}}), self.DXENA_SETUP = if ($1 & 0x0080) {"Enable"} else {"Disable"}, self.ABIS_SETUP = if ($1 & 0x0040) {"Enable"} else {"Disable"}, self.RINTM_SETUP = ($a = $1 & 0x0030, if ($a == 0x0000) {"RRDY"} else {if ($a == 0x0010) {"End of block/frame"} else {if ($a == 0x0020) {"New Frame Sync."} else {"RSYNCERR"}}}), self.RSYNCERR_SETUP = if ($1 & 0x0008) {"Enable"} else {"Disable"}, self.CLKSTP_SETUP = ($a = $1 & 0x1800, if ($a == 0x0000) {"Disable"} else {if (self.CLKXP_SETUP == "Rising Edge") {if ($a == 0x1000) {"Rising Edge w/o Delay"} else {"Rising Edge w/ Delay"}} else {if ($a == 0x1000) {"Falling Edge w/o Delay"} else {"Falling Edge w/ Delay"}}}))
    prop SPCR2_SETUP_update :: (self.FREE_SOFT_SETUP = ($a = $1 & 0x0300, if ($a == 0x0000) {"Stop Immediately"} else {if ($a == 0x0100) {"Stop After Current Word"} else {if ($a == 0x0200) {"Do Not Stop"} else {"Do Not Stop"}}}), self.XINTM_SETUP = ($a = $1 & 0x0030, if ($a == 0x0000) {"XRDY"} else {if ($a == 0x0010) {"End of block/frame"} else {if ($a == 0x0020) {"New Frame Sync."} else {"XSYNCERR"}}}), self.XSYNCERR_SETUP = if ($1 & 0x0008) {"Enable"} else {"Disable"})
    prop SRGR1_SETUP_update :: (self.FWID_SETUP = ((($1 & 0xFF00) >> 8) + 1), self.CLKGDV_SETUP = (($1 & 0x00FF) + 1))
    prop SRGR2_SETUP_update :: (self.GSYNC_SETUP = if ($1 & 0x8000) {"Enable"} else {"Disable"}, self.CLKSP_SETUP = if ($1 & 0x4000) {"Falling Edge of CLKS"} else {"Rising Edge of CLKS"}, self.CLKSM_SETUP = ($a = $1 & 0x2000, if (($a == 0x2000) && (!(self.PCR_VALUE & 0x0080))) {"CPU Clock"} else {if (($a == 0x2000) && (self.PCR_VALUE & 0x0080)) {"BCLKX Pin"} else {if (($a == 0x0000) && (!(self.PCR_VALUE & 0x0080))) {"CLKS Pin"} else {"BCLKR Pin"}}}), self.FSGM_SETUP = if ($1 & 0x1000) {"Enable"} else {"Disable"}, self.FPER_SETUP = (($1 & 0x0FFF) + 1))
    prop XCR1_SETUP_update :: (self.XFRLEN1_SETUP = ((($1 & 0x7F00) >> 8) + 1), self.XWDLEN1_SETUP = ($a = $1 & 0x00E0, if ($a == 0x0020) {"12-bits"} else {if ($a == 0x0040) {"16-bits"} else {if ($a == 0x0060) {"20-bits"} else {if ($a == 0x0080) {"24-bits"} else {if ($a == 0x00A0) {"32-bits"} else {"8-bits"}}}}}))
    prop XCR2_SETUP_update :: (self.XPHASE_SETUP = if ($1 & 0x8000) {"Dual-phase"} else {"Single-phase"}, self.XFRLEN2_SETUP = ((($1 & 0x7F00) >> 8) + 1), self.XWDLEN2_SETUP = ($a = ($1 & 0x00E0), if ($a == 0x0020) {"12-bits"} else {if ($a == 0x0040) {"16-bits"} else {if ($a == 0x0060) {"20-bits"} else {if ($a == 0x0080) {"24-bits"} else {if ($a == 0x00A0) {"32-bits"} else {"8-bits"}}}}}), self.XCOMPAND_SETUP = ($a = $1 & 0x0018, if ($a == 0x0008) {"No Companding-LSB First"} else {if ($a == 0x0010) {"u-Law"} else {if ($a == 0x0018) {"A-Law"} else {"No Companding-MSB First"}}}), self.XFIG_SETUP = if ($1 & 0x0004) {"Ignore"} else {"Restart Transfer"}, self.XDATDLY_SETUP = ($a = $1 & 0x0003, if ($a == 0x0000) {"0-bit"} else {if ($a == 0x0001) {"1-bit"} else {"2-bit"}}))
    prop MCR1_SETUP_update :: (self.RPBBLK_SETUP = ($a = $1 & 0x0180, if ($a == 0x0000) {"Block 1. Channel 16-31"} else {if ($a == 0x0080) {"Block 3. Channel 48-63"} else {if ($a == 0x0100) {"Block 5. Channel 80-95"} else {"Block 7. Channel 112-127"}}}), self.RPABLK_SETUP = ($a = $1 & 0x0060, if ($a == 0x0000) {"Block 0. Channel 0-15"} else {if ($a == 0x0020) {"Block 2. Channel 32-47"} else {if ($a == 0x0040) {"Block 4. Channel 64-79"} else {"Block 6. Channel 96-111"}}}), self.RMCM_RMCME_SETUP = ($a = $1 & 0x0201, if ($a == 0x0000) {"All 128 Channels"} else {if ($a == 0x0001) {"2 Blocks(Up to 16Ch./Blk.)"} else {"Any of 128 Ch."}}))
    prop MCR2_SETUP_update :: (self.XPABLK_SETUP = ($a = $1 & 0x0180, if ($a == 0x0000) {"Block 0. Channel 0-15"} else {if ($a == 0x0080) {"Block 2. Channel 32-47"} else {if ($a == 0x0100) {"Block 4. Channel 64-79"} else {"Block 6. Channel 96-111"}}}), self.XPBBLK_SETUP = ($a = $1 & 0x0060, if ($a == 0x0000) {"Block 1. Channel 16-31"} else {if ($a == 0x0020) {"Block 3. Channel 48-63"} else {if ($a == 0x0040) {"Block 5. Channel 80-95"} else {"Block 7. Channel 112-127"}}}), self.XMCM_XMCME_SETUP = ($a = $1 & 0x0203, if ($a == 0x0000) {"All 128 Channels"} else {if ($a == 0x0001) {"2 Blocks(Up to 16Ch./Blk. - XMCM=01)"} else {if ($a == 0x0002) {"2 Blocks(Up to 16Ch./Blk. - XMCM=10)"} else {if ($a == 0x0003) {"Symmetric Transmit and Receive"} else {"Any of 128 Ch."}}}}))
    prop RMCM_MCR1 :: (if (self.RMCM_RMCME_SETUP == "All 128 Channels") {0x0000} else {if (self.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") {0x0001} else {0x0000}})
    prop RMCME_MCR1 :: (if (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") {0x0200} else {0x0000})
    prop RPABLK_MCR1 :: (if (self.RPABLK_SETUP == "Block 0. Channel 0-15") {0x0000} else {if (self.RPABLK_SETUP == "Block 2. Channel 32-47") {0x0020} else {if (self.RPABLK_SETUP == "Block 4. Channel 64-79") {0x0040} else {0x0060}}})
    prop RPBBLK_MCR1 :: (if (self.RPBBLK_SETUP == "Block 1. Channel 16-31") {0x0000} else {if (self.RPBBLK_SETUP == "Block 3. Channel 48-63") {0x0080} else {if (self.RPBBLK_SETUP == "Block 5. Channel 80-95") {0x0100} else {0x0180}}})
    prop XMCM_MCR2 :: (if (self.XMCM_XMCME_SETUP == "All 128 Channels") {0x0000} else {if (self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") {0x0001} else {if (self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") {0x0002} else {if (self.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive") {0x0003} else {0x0000}}}})
    prop XMCME_MCR2 :: (if (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") {0x0200} else {0x0000})
    prop XPABLK_MCR2 :: (if (self.XPABLK_SETUP == "Block 0. Channel 0-15") {0x0000} else {if (self.XPABLK_SETUP == "Block 2. Channel 32-47") {0x0080} else {if (self.XPABLK_SETUP == "Block 4. Channel 64-79") {0x0100} else {0x0180}}})
    prop XPBBLK_MCR2 :: (if (self.XPBBLK_SETUP == "Block 1. Channel 16-31") {0x0000} else {if (self.XPBBLK_SETUP == "Block 3. Channel 48-63") {0x0020} else {if (self.XPBBLK_SETUP == "Block 5. Channel 80-95") {0x0040} else {0x0060}}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst IDLE_EN_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stop all clocks in McBSP during Peripheral Idle Mode "
        prop JSName :: "mcbspPcrIdleEn"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.IDLE_EN_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst XIOEN_SETUP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DX, FSX, and CLKX as Serial Port Pins "
        prop JSName :: "mcbspPcrXioen"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.XIOEN_SETUP = $1, self.XIOEN2_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), self.PCR_VALUE &= 0xFAFF, self.FSX_IO = "Input", self.CLKX_IO = "Input", "ok")
    }
    inst XIOEN2_SETUP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DX, FSX, and CLKX as Serial Port Pins "
        prop Visible :: 0
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.XIOEN2_SETUP = $1, self.XIOEN_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKXM1_SETUP :: "External" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Internal"
        prop Label :: "Clock Mode (CLKXM) "
        prop JSName :: "mcbspPcrClkxm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSTP_SETUP == "Disable") && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.CLKXM1_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKXM2_SETUP :: "Slave" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Slave,Master"
        prop Label :: "SPI Clock Mode (CLKXM) "
        prop JSName :: "mcbspPcrClkxmSpi"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSTP_SETUP != "Disable") && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.CLKXM2_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKXP_SETUP :: "Rising Edge" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKXP) "
        prop JSName :: "mcbspPcrClkxp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSTP_SETUP == "Disable") && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.CLKXP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSXP_SETUP :: "Active High" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame-Sync Polarity (FSXP) "
        prop JSName :: "mcbspPcrFsxp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.FSXP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst DXENA_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "DX Pin Delay (DXENA) "
        prop JSName :: "mcbspSpcr1Dxena"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (mcbspCfg.DXENA_SUPPORT))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.DXENA_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst XDATDLY_SETUP :: "0-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bit"
        prop Label :: "Transmit Delay (XDATDLY) "
        prop JSName :: "mcbspXcr2Xdatdly"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.XDATDLY_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok")
    }
    inst XPHASE_SETUP :: "Single-phase" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single-phase,Dual-phase"
        prop Label :: "Phase (XPHASE) "
        prop JSName :: "mcbspXcr2Xphase"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
        prop Set :: (self.XPHASE_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok")
    }
    inst XWDLEN1_SETUP :: "8-bits" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase1 (XWDLEN1) "
        prop JSName :: "mcbspXcr1Xwdlen1"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
        prop Set :: (self.XWDLEN1_SETUP = $1, self.XCR1_VALUE = self.XCR1_VALUE_update(), "ok")
    }
    inst XWDLEN2_SETUP :: "8-bits" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase2 (XWDLEN2) "
        prop JSName :: "mcbspXcr2Xwdlen2"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XPHASE_SETUP == "Dual-phase") && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
        prop Set :: (self.XWDLEN2_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok")
    }
    inst XFRLEN1_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase1 (XFRLEN1) "
        prop JSName :: "mcbspXcr1Xfrlen1"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
        prop Set :: (if (($1 <= 128) && ($1 >= 1)) {self.XFRLEN1_SETUP = $1, self.XCR1_VALUE = self.XCR1_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst XFRLEN2_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase2 (XFRLEN2) "
        prop JSName :: "mcbspXcr2Xfrlen2"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XPHASE_SETUP == "Dual-phase") && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Lengths"
        prop Set :: (if (($1 <= 128) && ($1 >= 1)) {self.XFRLEN2_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst XSYNCERR_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Detect Sync Error (XSYNCERR) "
        prop JSName :: "mcbspSpcr2Xsyncerr"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.XSYNCERR_SETUP = $1, self.SPCR2_VALUE = self.SPCR2_VALUE_update(), "ok")
    }
    inst XINTM_SETUP :: "XRDY" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "XRDY,End of block/frame,New Frame Sync.,XSYNCERR"
        prop Label :: "Interrupt Mode (XINTM) "
        prop JSName :: "mcbspSpcr2Xintm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.XINTM_SETUP = $1, self.SPCR2_VALUE = self.SPCR2_VALUE_update(), "ok")
    }
    inst FSXM_SETUP :: "External" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Sample Rate Gen"
        prop Label :: "Frame-Sync Mode (FSXM) "
        prop Visible :: 0
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.FSXM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst XFIG_SETUP :: "Restart Transfer" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Restart Transfer,Ignore"
        prop Label :: "Early Frame Sync Response (XFIG) "
        prop JSName :: "mcbspXcr2Xfig"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.XIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.XFIG_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok")
    }
    inst XCOMPAND_SETUP :: "No Companding-MSB First" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding-MSB First,No Companding-LSB First,u-Law,A-Law"
        prop Label :: "Companding (XCOMPAND) "
        prop JSName :: "mcbspXcr2Xcompand"
        prop Visible :: 1
        prop Writable :: ((!(self.MCBSP_man)) && (self.XIOEN_SETUP == 1) && (self.XWDLEN1_SETUP == "8-bits") && ((self.XWDLEN2_SETUP == "8-bits") || !(self.XPHASE_SETUP == "Dual-phase")))
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.XCOMPAND_SETUP = $1, self.XCR2_VALUE = self.XCR2_VALUE_update(), "ok")
    }
    inst FSXM_FSGM_SETUP :: "External" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,DXR[1/2]-to-XSR[1/2] Copy,FSG Signal"
        prop Label :: "Transmit Frame-Sync Source "
        prop JSName :: "mcbspPcrFsxm"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Modes"
        prop Set :: (self.FSXM_FSGM_SETUP = $1, if ($1 == "External") {self.FSXM_SETUP = "External", self.FSGM_SETUP = "Disable"} else {if ($1 == "DXR[1/2]-to-XSR[1/2] Copy") {self.FSXM_SETUP = "Sample Rate Gen", self.FSGM_SETUP = "Disable"} else {self.FSXM_SETUP = "Sample Rate Gen", self.FSGM_SETUP = "Enable"}}, self.SRGR2_VALUE = self.SRGR2_VALUE_update(), self.PCR_VALUE = self.PCR_VALUE_update, "ok")
    }
    inst RIOEN_SETUP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DR, FSR, CLKR, and CLKS as Serial Port Pins "
        prop JSName :: "mcbspPcrRioen"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.RIOEN_SETUP = $1, self.RIOEN2_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), self.PCR_VALUE &= 0xF5FF, self.FSR_IO = "Input", self.CLKR_IO = "Input", "ok")
    }
    inst RIOEN2_SETUP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Configure DR, FSR, CLKR, and CLKS as Serial Port Pins "
        prop Visible :: 0
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.RIOEN_SETUP = $1, self.RIOEN2_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKRM1_SETUP :: "External" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Internal"
        prop Label :: "Clock Mode (CLKRM) "
        prop JSName :: "mcbspPcrClkrm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.DLB_SETUP == "Disable") && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.CLKRM1_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKRM2_SETUP :: "CLKX Driven" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKX Driven,CLKR as Output"
        prop Label :: "SPI Clock Mode (CLKRM) "
        prop JSName :: "mcbspPcrClkrmDlb"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.DLB_SETUP == "Enable"))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.CLKRM2_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst CLKRP_SETUP :: "Falling Edge" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge,Falling Edge"
        prop Label :: "Clock Polarity (CLKRP) "
        prop JSName :: "mcbspPcrClkrp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.CLKRP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst FSRP_SETUP :: "Active High" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Active High,Active Low"
        prop Label :: "Frame-Sync Polarity (FSRP) "
        prop JSName :: "mcbspPcrFsrp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.FSRP_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst RDATDLY_SETUP :: "0-bit" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0-bit,1-bit,2-bit"
        prop Label :: "Receive Delay (RDATDLY) "
        prop JSName :: "mcbspRcr2Rdatdly"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RDATDLY_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok")
    }
    inst RPHASE_SETUP :: "Single-phase" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Single-phase,Dual-phase"
        prop Label :: "Phases (RPHASE) "
        prop JSName :: "mcbspRcr2Rphase"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
        prop Set :: (self.RPHASE_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok")
    }
    inst RWDLEN1_SETUP :: "8-bits" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase1 (RWDLEN1) "
        prop JSName :: "mcbspRcr1Rwdlen1"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
        prop Set :: (self.RWDLEN1_SETUP = $1, self.RCR1_VALUE = self.RCR1_VALUE_update(), "ok")
    }
    inst RWDLEN2_SETUP :: "8-bits" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8-bits,12-bits,16-bits,20-bits,24-bits,32-bits"
        prop Label :: "Word Length Phase2 (RWDLEN2) "
        prop JSName :: "mcbspRcr2Rwdlen2"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RPHASE_SETUP == "Dual-phase") && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
        prop Set :: (self.RWDLEN2_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok")
    }
    inst RFRLEN1_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase1 (RFRLEN1) "
        prop JSName :: "mcbspRcr1Rfrlen1"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
        prop Set :: (if (($1 <= 128) && ($1 >= 1)) {self.RFRLEN1_SETUP = $1, self.RCR1_VALUE = self.RCR1_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst RFRLEN2_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Words/Frame Phase2 (RFRLEN2) "
        prop JSName :: "mcbspRcr2Rfrlen2"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RPHASE_SETUP == "Dual-phase") && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Lengths"
        prop Set :: (if (($1 <= 128) && ($1 >= 1)) {self.RFRLEN2_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst RSYNCERR_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Detect Sync Error (RSYNCERR) "
        prop JSName :: "mcbspSpcr1Rsyncerr"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RSYNCERR_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst RINTM_SETUP :: "RRDY" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RRDY,End of block/frame,New Frame Sync.,RSYNCERR"
        prop Label :: "Interrupt Mode (RINTM) "
        prop JSName :: "mcbspSpcr1Rintm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.RIOEN_SETUP == 1))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RINTM_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst FSRM_SETUP :: "External" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "External,Sample Rate Gen"
        prop Label :: "Frame-Sync Mode (FSRM) "
        prop JSName :: "mcbspPcrFsrm"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.FSRM_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst RFIG_SETUP :: "Restart Transfer" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Restart Transfer,Ignore"
        prop Label :: "Early Frame Sync Response (RFIG) "
        prop JSName :: "mcbspRcr2Rfig"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RFIG_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok")
    }
    inst RJUST_SETUP :: "Right-justify/zero-fill" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Right-justify/zero-fill,Right-justify/sign-extend,Left-justify/zero-fill"
        prop Label :: "Sign-Ext and Justification (RJUST) "
        prop JSName :: "mcbspSpcr1Rjust"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RJUST_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst RCOMPAND_SETUP :: "No Companding-MSB First" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "No Companding-MSB First,No Companding-LSB First,u-Law,A-Law"
        prop Label :: "Companding (RCOMPAND) "
        prop JSName :: "mcbspRcr2Rcompand"
        prop Visible :: 1
        prop Writable :: ((!(self.MCBSP_man)) && (self.RIOEN_SETUP == 1) && (self.RWDLEN1_SETUP == "8-bits") && ((self.RWDLEN2_SETUP == "8-bits") || !(self.RPHASE_SETUP == "Dual-phase")))
        prop NoGen :: 1
        prop TabName :: "Receive Modes"
        prop Set :: (self.RCOMPAND_SETUP = $1, self.RCR2_VALUE = self.RCR2_VALUE_update(), "ok")
    }
    inst FREE_SOFT_SETUP :: "Stop Immediately" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Immediately,Stop After Current Word,Do Not Stop"
        prop Label :: "Breakpoint Emulation "
        prop JSName :: "mcbspSpcr2Free"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.FREE_SOFT_SETUP = $1, self.SPCR2_VALUE = self.SPCR2_VALUE_update(), "ok")
    }
    inst CLKSTP_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Rising Edge w/o Delay,Falling Edge w/o Delay,Rising Edge w/ Delay,Falling Edge w/ Delay"
        prop Label :: "SPI Mode (CLKSTP) "
        prop JSName :: "mcbspSpcr1Clkstp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.ABIS_SETUP == "Disable"))
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.CLKSTP_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), self.PCR_VALUE = self.PCR_VALUE_update(), "ok")
    }
    inst DLB_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Digital Loop Back (DLB) "
        prop JSName :: "mcbspSpcr1Dlb"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.DLB_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst ABIS_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "A-Bis (ABIS) "
        prop JSName :: "mcbspSpcr1Abis"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSTP_SETUP == "Disable"))
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.ABIS_SETUP = $1, self.SPCR1_VALUE = self.SPCR1_VALUE_update(), "ok")
    }
    inst GRST_SETUP :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Sample Rate Generator Enable "
        prop Visible :: 0
        prop Writable :: !(self.MCBSP_man)
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (self.GRST_SETUP = $1, "ok")
    }
    inst CLKSM_SETUP :: "CLKS Pin" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKS Pin,CPU Clock,BCLKR Pin,BCLKX Pin"
        prop Label :: "SRG Clock Source (CLKSM) "
        prop JSName :: "mcbspSrgr2Clksm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (self.CLKSM_SETUP = $1, self.SCLKME_SETUP = $1, self.PCR_VALUE = self.PCR_VALUE_update(), self.SRGR2_VALUE = self.SRGR2_VALUE_update(), "ok")
    }
    inst SCLKME_SETUP :: "CLKS Pin" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKS Pin,CPU Clock,BCLKR Pin,BCLKX Pin"
        prop Label :: "SCLKME(NOT visible) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
    }
    inst GSYNC_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Clock Synchronization With CLKS Pin (GSYNC) "
        prop JSName :: "mcbspSrgr2Gsync"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSM_SETUP == "CLKS Pin") && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (self.GSYNC_SETUP = $1, self.SRGR2_VALUE = self.SRGR2_VALUE_update(), "ok")
    }
    inst CLKSP_SETUP :: "Rising Edge of CLKS" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Rising Edge of CLKS,Falling Edge of CLKS"
        prop Label :: "CLKS Polarity Clock Edge (From CLKS Pin) (CLKSP) "
        prop JSName :: "mcbspSrgr2Clksp"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.CLKSM_SETUP == "CLKS Pin") && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (self.CLKSP_SETUP = $1, self.SRGR2_VALUE = self.SRGR2_VALUE_update(), "ok")
    }
    inst FSGM_SETUP :: "Disable" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disable,Enable"
        prop Label :: "Transmit Frame-Sync Mode (FSXM = 1) (FSGM) "
        prop JSName :: "mcbspSrgr2Fsgm"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.FSXM_SETUP == "Sample Rate Gen") && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (self.FSGM_SETUP = $1, self.SRGR2_VALUE = self.SRGR2_VALUE_update(), "ok")
    }
    inst FWID_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame Width (1-256) (FWID) "
        prop JSName :: "mcbspSrgr1Fwid"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (if (($1 <= 256) && ($1 >= 1)) {self.FWID_SETUP = $1, self.SRGR1_VALUE = self.SRGR1_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst CLKGDV_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Clock Divider (1-256) (CLKGDV) "
        prop JSName :: "mcbspSrgr1Clkgdv"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (if (($1 <= 256) && ($1 >= 1)) {self.CLKGDV_SETUP = $1, self.SRGR1_VALUE = self.SRGR1_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst FPER_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Frame Period (1-4096) (FPER) "
        prop JSName :: "mcbspSrgr2Fper"
        prop Visible :: 1
        prop Writable :: (!(self.MCBSP_man) && (self.GRST_SETUP == 1) && ((self.XIOEN_SETUP == 1) || (self.RIOEN_SETUP == 1)))
        prop NoGen :: 1
        prop TabName :: "Sample-Rate Gen"
        prop Set :: (if (($1 <= 4096) && ($1 >= 1)) {self.FPER_SETUP = $1, self.SRGR2_VALUE = self.SRGR2_VALUE_update(), "ok"} else {"Invalid value"})
    }
    inst CLKX_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Select CLKX Pin as "
        prop Enum :: "Input,Output"
        prop JSName :: "mcbspGpioClkx"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 0)
        prop NoGen :: 1
        prop TabName :: "GPIO"
        prop Set :: (self.CLKX_IO = $1, if (self.CLKX_IO == "Output") {self.PCR_VALUE |= (0x0200)} else {self.PCR_VALUE &= (0xFDFF)}, "ok")
    }
    inst FSX_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Select FSX Pin as "
        prop Enum :: "Input,Output"
        prop JSName :: "mcbspGpioFsx"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 0)
        prop NoGen :: 1
        prop TabName :: "GPIO"
        prop Set :: (self.FSX_IO = $1, if (self.FSX_IO == "Output") {self.PCR_VALUE |= (0x0800)} else {self.PCR_VALUE &= (0xF7FF)}, "ok")
    }
    inst CLKR_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Select CLKR Pin as "
        prop Enum :: "Input,Output"
        prop JSName :: "mcbspGpioClkr"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 0)
        prop NoGen :: 1
        prop TabName :: "GPIO"
        prop Set :: (self.CLKR_IO = $1, if (self.CLKR_IO == "Output") {self.PCR_VALUE |= (0x0100)} else {self.PCR_VALUE &= (0xFEFF)}, "ok")
    }
    inst FSR_IO :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Select FSR Pin as "
        prop Enum :: "Input,Output"
        prop JSName :: "mcbspGpioFsr"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 0)
        prop NoGen :: 1
        prop TabName :: "GPIO"
        prop Set :: (self.FSR_IO = $1, if (self.FSR_IO == "Output") {self.PCR_VALUE |= (0x0400)} else {self.PCR_VALUE &= (0xFBFF)}, "ok")
    }
    inst EN_DX :: "Output" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Unused,Output"
        prop Label :: "Select DX Pin as "
        prop JSName :: "mcbspGpioDx"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "GPIO"
    }
    inst EN_DR :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Unused,Input"
        prop Label :: "Select DR Pin as "
        prop JSName :: "mcbspGpioDr"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "GPIO"
    }
    inst EN_CLKS :: "Input" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Unused,Input"
        prop Label :: "Select CLKS Pin as "
        prop JSName :: "mcbspGpioClks"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "GPIO"
    }
    inst MCBSP_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually "
        prop JSName :: "mcbspManualSet"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Advanced A"
    }
    inst SPCR1_VALUE :: self.SPCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Serial Port Control Register 1 "
        prop JSName :: "mcbspSpcr1"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 & 0x6000) == 0x6000) {"Invalid RJUST Value"} else {(self.SPCR1_VALUE = ($1 & 0xF8F9), self.SPCR1_SETUP_update($1), "ok")})
    }
    inst SPCR2_VALUE :: self.SPCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Serial Port Control Register 2 "
        prop JSName :: "mcbspSpcr2"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.SPCR2_VALUE = ($1 & 0x03F9), self.SPCR2_SETUP_update($1), "ok")
    }
    inst RCR1_VALUE :: self.RCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Control Register 1 "
        prop JSName :: "mcbspRcr1"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 & 0x00E0) == 0x00E0) {"Invalid RWDLEN1 Value"} else {if (($1 & 0x00E0) == 0x00C0) {"Invalid RWDLEN1 Value"} else {(self.RCR1_VALUE = ($1 & 0x7FE0), self.RCR1_SETUP_update($1), "ok")}})
    }
    inst RCR2_VALUE :: self.RCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Control Register 2 "
        prop JSName :: "mcbspRcr2"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 & 0x00E0) == 0x00E0) {"Invalid RWDLEN2 Value"} else {if (($1 & 0x00E0) == 0x00C0) {"Invalid RWDLEN2 Value"} else {if (($1 & 0x0003) == 0x0003) {"Invalid RDATDLY Value"} else {(self.RCR2_VALUE = $1, self.RCR2_SETUP_update($1), "ok")}}})
    }
    inst XCR1_VALUE :: self.XCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Control Register 1 "
        prop JSName :: "mcbspXcr1"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 & 0x00E0) == 0x00E0) {"Invalid XWDLEN1 Value"} else {if (($1 & 0x00E0) == 0x00C0) {"Invalid XWDLEN1 Value"} else {(self.XCR1_VALUE = ($1 & 0x7FE0), self.XCR1_SETUP_update($1), "ok")}})
    }
    inst XCR2_VALUE :: self.XCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Control Register 2 "
        prop JSName :: "mcbspXcr2"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 & 0x00E0) == 0x00E0) {"Invalid XWDLEN2 Value"} else {if (($1 & 0x00E0) == 0x00C0) {"Invalid XWDLEN2 Value"} else {if (($1 & 0x0003) == 0x0003) {"Invalid XDATDLY Value"} else {(self.XCR2_VALUE = $1, self.XCR2_SETUP_update($1), "ok")}}})
    }
    inst SRGR1_VALUE :: self.SRGR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Sample Rate Generator Register 1 "
        prop JSName :: "mcbspSrgr1"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.SRGR1_VALUE = $1, self.SRGR1_SETUP_update($1), "ok")
    }
    inst SRGR2_VALUE :: self.SRGR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Sample Rate Generator Register 2 "
        prop JSName :: "mcbspSrgr2"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.SRGR2_VALUE = $1, self.SRGR2_SETUP_update($1), self.FSXM_SETUP = if (self.PCR_VALUE & 0x800) {"Sample Rate Gen"} else {"External"}, self.FSGM_SETUP = if ($1 & 0x1000) {"Enable"} else {"Disable"}, self.FSXM_FSGM_SETUP = self.FSXM_FSGM_SETUP_update(), "ok")
    }
    inst MCR1_VALUE :: self.MCR1_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Multichannel Control Register 1 "
        prop JSName :: "mcbspMcr1"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.MCR1_VALUE = ($1 & 0x03E1), self.MCR1_SETUP_update($1), "ok")
    }
    inst MCR2_VALUE :: self.MCR2_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Multichannel Control Register 2 "
        prop JSName :: "mcbspMcr2"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.MCR2_VALUE = ($1 & 0x03E3), self.MCR2_SETUP_update($1), "ok")
    }
    inst PCR_VALUE :: self.PCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Pin Control Register "
        prop JSName :: "mcbspPcr"
        prop Visible :: 1
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced A"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.PCR_VALUE = ($1 & 0x7F8F), self.PCR_SETUP_update($1), "ok")
    }
    inst RMCM_RMCME_SETUP :: "All 128 Channels" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "All 128 Channels,2 Blocks(Up to 16Ch./Blk.),Any of 128 Ch."
        prop Label :: "RX Channel Enable "
        prop JSName :: "mcbspMcr1RmcmRmcme"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop Set :: (self.RMCM_RMCME_SETUP = $1, self.MCR1_VALUE = self.MCR1_VALUE_update(), "ok")
    }
    inst RPABLK_SETUP :: "Block 0. Channel 0-15" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 0. Channel 0-15,Block 2. Channel 32-47,Block 4. Channel 64-79,Block 6. Channel 96-111"
        prop Label :: "Receive Partition A (RPABLK) "
        prop JSName :: "mcbspMcr1Rpablk"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop Set :: (self.RPABLK_SETUP = $1, self.MCR1_VALUE = self.MCR1_VALUE_update(), "ok")
    }
    inst RPBBLK_SETUP :: "Block 1. Channel 16-31" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 1. Channel 16-31,Block 3. Channel 48-63,Block 5. Channel 80-95,Block 7. Channel 112-127"
        prop Label :: "Receive Partition B (RPBBLK) "
        prop JSName :: "mcbspMcr1Rpbblk"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop Set :: (self.RPBBLK_SETUP = $1, self.MCR1_VALUE = self.MCR1_VALUE_update(), "ok")
    }
    inst RCERA_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition A "
        prop JSName :: "mcbspRcera"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && ((self.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") || (self.RMCM_RMCME_SETUP == "Any of 128 Ch.")) && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERB_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition B "
        prop JSName :: "mcbspRcerb"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && ((self.RMCM_RMCME_SETUP == "2 Blocks(Up to 16Ch./Blk.)") || (self.RMCM_RMCME_SETUP == "Any of 128 Ch.")) && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERC_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition C "
        prop JSName :: "mcbspRcerc"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERD_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition D "
        prop JSName :: "mcbspRcerd"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERE_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition E "
        prop JSName :: "mcbspRcere"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERF_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition F "
        prop JSName :: "mcbspRcerf"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERG_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition G "
        prop JSName :: "mcbspRcerg"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst RCERH_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition H "
        prop JSName :: "mcbspRcerh"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.RIOEN_SETUP == 1) && (self.RMCM_RMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Receive Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XMCM_XMCME_SETUP :: "All 128 Channels" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "All 128 Channels,2 Blocks(Up to 16Ch./Blk. - XMCM=01),2 Blocks(Up to 16Ch./Blk. - XMCM=10),Symmetric Transmit and Receive,Any of 128 Ch."
        prop Label :: "TX Channel Enable "
        prop JSName :: "mcbspMcr2XmcmXmcme"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop Set :: (self.XMCM_XMCME_SETUP = $1, self.MCR2_VALUE = self.MCR2_VALUE_update(), "ok")
    }
    inst XPABLK_SETUP :: "Block 0. Channel 0-15" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 0. Channel 0-15,Block 2. Channel 32-47,Block 4. Channel 64-79,Block 6. Channel 96-111"
        prop Label :: "Transmit Partition A (XPABLK) "
        prop JSName :: "mcbspMcr2Xpablk"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && ((self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") || (self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") || (self.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive"))
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop Set :: (self.XPABLK_SETUP = $1, self.MCR2_VALUE = self.MCR2_VALUE_update(), "ok")
    }
    inst XPBBLK_SETUP :: "Block 1. Channel 16-31" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Block 1. Channel 16-31,Block 3. Channel 48-63,Block 5. Channel 80-95,Block 7. Channel 112-127"
        prop Label :: "Transmit Partition B (XPBBLK) "
        prop JSName :: "mcbspMcr2Xpbblk"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && ((self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=01)") || (self.XMCM_XMCME_SETUP == "2 Blocks(Up to 16Ch./Blk. - XMCM=10)") || (self.XMCM_XMCME_SETUP == "Symmetric Transmit and Receive"))
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop Set :: (self.XPBBLK_SETUP = $1, self.MCR2_VALUE = self.MCR2_VALUE_update(), "ok")
    }
    inst XCERA_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition A "
        prop JSName :: "mcbspXcera"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP != "All 128 Channels") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERB_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition B "
        prop JSName :: "mcbspXcerb"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP != "All 128 Channels") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERC_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition C "
        prop JSName :: "mcbspXcerc"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERD_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition D "
        prop JSName :: "mcbspXcerd"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERE_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition E "
        prop JSName :: "mcbspXcere"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERF_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition F "
        prop JSName :: "mcbspXcerf"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERG_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition G "
        prop JSName :: "mcbspXcerg"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XCERH_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition H "
        prop JSName :: "mcbspXcerh"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.XIOEN_SETUP == 1) && (self.XMCM_XMCME_SETUP == "Any of 128 Ch.") && (self.ABIS_SETUP == "Disable")
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst XMCM_01 :: "DXR written for enabled/unmasked channels,DX driven for enabled/unmasked channels" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
    }
    inst XMCM_10 :: "DXR written for all channels in block,DX driven for unmasked channels" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Transmit Multichannel"
    }
    inst ABIS_RCERA_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "ABIS RX. Bit Enable Register Partition A "
        prop JSName :: "mcbspRceraAbis"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.ABIS_SETUP == "Enable") && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.ABIS_XCERA_VALUE = $1, self.XCERA_VALUE = $1, "ok")
    }
    inst ABIS_RCERB_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "ABIS RX. Bit Enable Register Partition B "
        prop JSName :: "mcbspRcerbAbis"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.ABIS_SETUP == "Enable") && (self.RIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.ABIS_RCERB_VALUE = $1, self.RCERB_VALUE = $1, "ok")
    }
    inst ABIS_XCERA_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "ABIS TX. Bit Enable Register Partition A "
        prop JSName :: "mcbspXceraAbis"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.ABIS_SETUP == "Enable") && (self.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.ABIS_XCERA_VALUE = $1, self.XCERA_VALUE = $1, "ok")
    }
    inst ABIS_XCERB_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "ABIS TX. Bit Enable Register Partition B "
        prop JSName :: "mcbspXcerbAbis"
        prop Visible :: 1
        prop Writable :: !(self.MCBSP_man) && (self.ABIS_SETUP == "Enable") && (self.XIOEN_SETUP == 1)
        prop NoGen :: 1
        prop TabName :: "ABIS"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.ABIS_XCERB_VALUE = $1, self.XCERB_VALUE = $1, "ok")
    }
    inst RCERA :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition A "
        prop JSName :: "mcbspRceraAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERA = $1, self.RCERA_VALUE = $1, "ok")
    }
    inst RCERB :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition B "
        prop JSName :: "mcbspRcerbAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERB = $1, self.RCERB_VALUE = $1, "ok")
    }
    inst RCERC :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition C "
        prop JSName :: "mcbspRcercAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERC = $1, self.RCERC_VALUE = $1, "ok")
    }
    inst RCERD :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition D "
        prop JSName :: "mcbspRcerdAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERD = $1, self.RCERD_VALUE = $1, "ok")
    }
    inst RCERE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition E "
        prop JSName :: "mcbspRcereAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERE = $1, self.RCERE_VALUE = $1, "ok")
    }
    inst RCERF :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition F "
        prop JSName :: "mcbspRcerfAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERF = $1, self.RCERF_VALUE = $1, "ok")
    }
    inst RCERG :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition G "
        prop JSName :: "mcbspRcergAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERG = $1, self.RCERG_VALUE = $1, "ok")
    }
    inst RCERH :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Receive Channel Enable Register Partition H "
        prop JSName :: "mcbspRcerhAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.RCERH = $1, self.RCERH_VALUE = $1, "ok")
    }
    inst XCERA :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition A "
        prop JSName :: "mcbspXceraAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERA = $1, self.XCERA_VALUE = $1, "ok")
    }
    inst XCERB :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition B "
        prop JSName :: "mcbspXcerbAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERB = $1, self.XCERB_VALUE = $1, "ok")
    }
    inst XCERC :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition C "
        prop JSName :: "mcbspXcercAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERC = $1, self.XCERC_VALUE = $1, "ok")
    }
    inst XCERD :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition D "
        prop JSName :: "mcbspXcerdAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERD = $1, self.XCERD_VALUE = $1, "ok")
    }
    inst XCERE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition E "
        prop JSName :: "mcbspXcereAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERE = $1, self.XCERE_VALUE = $1, "ok")
    }
    inst XCERF :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition F "
        prop JSName :: "mcbspXcerfAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERF = $1, self.XCERF_VALUE = $1, "ok")
    }
    inst XCERG :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition G "
        prop JSName :: "mcbspXcergAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERG = $1, self.XCERG_VALUE = $1, "ok")
    }
    inst XCERH :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Transmit Channel Enable Register Partition H "
        prop JSName :: "mcbspXcerhAdv"
        prop Visible :: self.MCBSP_man
        prop Writable :: self.MCBSP_man
        prop NoGen :: 1
        prop TabName :: "Advanced B"
        prop cGen :: 0
        prop cType :: "Uint16"
        prop Set :: (self.XCERH = $1, self.XCERH_VALUE = $1, "ok")
    }
}

type hMCBSP {
    isa ObjectMgr
    prop name :: "hMCBSP"
    prop Label :: "MCBSP Resource Manager"
    prop JSName :: "HMCBSP"
    prop GlobalHelpTopic :: 1062
    prop InstanceHelpTopic :: 1063
    prop GlobalIcon :: 159
    prop InstanceIcon :: 160
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-00105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-0000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: MCBSPFOLDER
    prop maxObjs :: (if (GBL.CHIPTYPE == "5510") {3} else {3})
    prop NoGen :: 1
    prop cGen :: 1
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: if hMCBSP.c55mcbsp == 1 {"csl_mcbsp.h"} else {""}
    prop cHandleType :: "MCBSP_Handle"
    prop cOpenName :: "MCBSP_open"
    prop cConfigName :: "MCBSP_config"
    prop cHandleName :: self.handleName
    prop comment :: "/* You must use MCBSP_start() in your main code to start the MCBSP. */"
    prop cGenFxnEpilogue :: ("%5t\n%1s\n\n%0t\0,comment")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 3 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55mcbsp :: 1 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x McBSP opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Handle to McBSP "
        prop JSName :: "mcbspHandleEnable"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
        prop Set :: (self.cOpenGen = $1, if ($1 == 1) {hMCBSP.c55mcbsp = 1} else {hMCBSP.c55mcbsp = 0}, "ok")
    }
    inst cOpenArg0 :: "MCBSP_DEV0" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "MCBSP_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst handleName :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Handle Name "
        prop JSName :: "mcbspHandleName"
        prop Visible :: 1
        prop Writable :: (self.cOpenGen)
        prop NoGen :: 1
        prop Set :: (self.handleName = $1, self.cConfigArg0 = $1, "ok")
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable pre-initialization"
        prop JSName :: "mcbspEnablePreInit"
        prop Visible :: 1
        prop Writable :: self.cOpenGen
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; MCBSP) {$a = 1}, if ($a == 0) {"You must create a configuration object"} else {self.PINIT_ENABLE = $1, "ok"})
    }
    inst cConfigGen :: = ((self.cOpenGen == 1) && (self.PINIT_ENABLE == 1) && (self.cConfigArg1 != MCBSP_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: self.handleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
        prop Writable :: 1
    }
    inst cConfigArg1 :: MCBSP_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: mcbspCfg
        prop Label :: "Pre-initialize "
        prop JSName :: "mcbspPreInit"
        prop Visible :: 1
        prop Writable :: self.PINIT_ENABLE == 1
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object MCBSP_NOTHING :: mcbspCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param IDLE_EN_SETUP :: 0
    param XIOEN_SETUP :: 1
    param XIOEN2_SETUP :: 1
    param CLKXM1_SETUP :: "External"
    param CLKXM2_SETUP :: "Slave"
    param CLKXP_SETUP :: "Rising Edge"
    param FSXP_SETUP :: "Active High"
    param DXENA_SETUP :: "Disable"
    param XDATDLY_SETUP :: "0-bit"
    param XPHASE_SETUP :: "Single-phase"
    param XWDLEN1_SETUP :: "8-bits"
    param XWDLEN2_SETUP :: "8-bits"
    param XFRLEN1_SETUP :: 1
    param XFRLEN2_SETUP :: 1
    param XSYNCERR_SETUP :: "Disable"
    param XINTM_SETUP :: "XRDY"
    param FSXM_SETUP :: "External"
    param XFIG_SETUP :: "Restart Transfer"
    param XCOMPAND_SETUP :: "No Companding-MSB First"
    param FSXM_FSGM_SETUP :: "External"
    param RIOEN_SETUP :: 1
    param RIOEN2_SETUP :: 1
    param CLKRM1_SETUP :: "External"
    param CLKRM2_SETUP :: "CLKX Driven"
    param CLKRP_SETUP :: "Falling Edge"
    param FSRP_SETUP :: "Active High"
    param RDATDLY_SETUP :: "0-bit"
    param RPHASE_SETUP :: "Single-phase"
    param RWDLEN1_SETUP :: "8-bits"
    param RWDLEN2_SETUP :: "8-bits"
    param RFRLEN1_SETUP :: 1
    param RFRLEN2_SETUP :: 1
    param RSYNCERR_SETUP :: "Disable"
    param RINTM_SETUP :: "RRDY"
    param FSRM_SETUP :: "External"
    param RFIG_SETUP :: "Restart Transfer"
    param RJUST_SETUP :: "Right-justify/zero-fill"
    param RCOMPAND_SETUP :: "No Companding-MSB First"
    param FREE_SOFT_SETUP :: "Stop Immediately"
    param CLKSTP_SETUP :: "Disable"
    param DLB_SETUP :: "Disable"
    param ABIS_SETUP :: "Disable"
    param GRST_SETUP :: 1
    param CLKSM_SETUP :: "CLKS Pin"
    param SCLKME_SETUP :: "CLKS Pin"
    param GSYNC_SETUP :: "Disable"
    param CLKSP_SETUP :: "Rising Edge of CLKS"
    param FSGM_SETUP :: "Disable"
    param FWID_SETUP :: 1
    param CLKGDV_SETUP :: 1
    param FPER_SETUP :: 1
    param CLKX_IO :: "Input"
    param FSX_IO :: "Input"
    param CLKR_IO :: "Input"
    param FSR_IO :: "Input"
    param EN_DX :: "Output"
    param EN_DR :: "Input"
    param EN_CLKS :: "Input"
    param MCBSP_man :: 0
    param SPCR1_VALUE :: 0
    param SPCR2_VALUE :: 0
    param RCR1_VALUE :: 0
    param RCR2_VALUE :: 0
    param XCR1_VALUE :: 0
    param XCR2_VALUE :: 0
    param SRGR1_VALUE :: 0
    param SRGR2_VALUE :: 0
    param MCR1_VALUE :: 0
    param MCR2_VALUE :: 0
    param PCR_VALUE :: 0
    param RMCM_RMCME_SETUP :: "All 128 Channels"
    param RPABLK_SETUP :: "Block 0. Channel 0-15"
    param RPBBLK_SETUP :: "Block 1. Channel 16-31"
    param RCERA_VALUE :: 0
    param RCERB_VALUE :: 0
    param RCERC_VALUE :: 0
    param RCERD_VALUE :: 0
    param RCERE_VALUE :: 0
    param RCERF_VALUE :: 0
    param RCERG_VALUE :: 0
    param RCERH_VALUE :: 0
    param XMCM_XMCME_SETUP :: "All 128 Channels"
    param XPABLK_SETUP :: "Block 0. Channel 0-15"
    param XPBBLK_SETUP :: "Block 1. Channel 16-31"
    param XCERA_VALUE :: 0
    param XCERB_VALUE :: 0
    param XCERC_VALUE :: 0
    param XCERD_VALUE :: 0
    param XCERE_VALUE :: 0
    param XCERF_VALUE :: 0
    param XCERG_VALUE :: 0
    param XCERH_VALUE :: 0
    param XMCM_01 :: "DXR written for enabled/unmasked channels,DX driven for enabled/unmasked channels"
    param XMCM_10 :: "DXR written for all channels in block,DX driven for unmasked channels"
    param ABIS_RCERA_VALUE :: 0
    param ABIS_RCERB_VALUE :: 0
    param ABIS_XCERA_VALUE :: 0
    param ABIS_XCERB_VALUE :: 0
    param RCERA :: 0
    param RCERB :: 0
    param RCERC :: 0
    param RCERD :: 0
    param RCERE :: 0
    param RCERF :: 0
    param RCERG :: 0
    param RCERH :: 0
    param XCERA :: 0
    param XCERB :: 0
    param XCERC :: 0
    param XCERD :: 0
    param XCERE :: 0
    param XCERF :: 0
    param XCERG :: 0
    param XCERH :: 0
}

object hMCBSP0 :: hMCBSP {
    param iComment :: "MCBSP 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMCBSP"
    param iDelMsg :: "MCBSP 0"
    param cOpenGen :: 0
    param cOpenArg0 :: "MCBSP_PORT0"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param handleName :: "hMcbsp0"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hMcbsp0"
    param cConfigArg1 :: MCBSP_NOTHING
}

object hMCBSP1 :: hMCBSP {
    param iComment :: "MCBSP 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMCBSP"
    param iDelMsg :: "MCBSP 1"
    param cOpenGen :: 1
    param cOpenArg0 :: "MCBSP_PORT1"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param handleName :: "C55XX_CONTROLHANDLE_hMcbsp"
    param PINIT_ENABLE :: 1
    param cConfigArg0 :: "C55XX_CONTROLHANDLE_hMcbsp"
    param cConfigArg1 :: mcbspCfg1
}

object hMCBSP2 :: hMCBSP {
    param iComment :: "MCBSP 2"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hMCBSP"
    param iDelMsg :: "MCBSP 2"
    param cOpenGen :: 1
    param cOpenArg0 :: "MCBSP_PORT2"
    param cOpenArg1 :: "MCBSP_OPEN_RESET"
    param handleName :: "C55XX_DMA_MCBSP_hMcbsp"
    param PINIT_ENABLE :: 1
    param cConfigArg0 :: "C55XX_DMA_MCBSP_hMcbsp"
    param cConfigArg1 :: mcbspCfg2
}

type PLLFOLDER {
    prop Label :: "PLL - Clock Generator"
    prop GlobalIcon :: 173
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1070
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type pllCfg {
    isa ObjectMgr
    prop name :: "PLL"
    prop Label :: "PLL Configuration Manager"
    prop JSName :: "PLL"
    prop GlobalHelpTopic :: 1071
    prop InstanceHelpTopic :: 1071
    prop IsContainedIn :: PLLFOLDER
    prop GlobalIcon :: 173
    prop InstanceIcon :: 174
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "PLL_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_pll.h"} else {""}
    prop NoGen :: 1
    prop CLKOUT_update :: (if ((self.PLL_MULT_VALUE == 0) || (self.PLL_MULT_VALUE == 1)) {self.CLKOUT_SETUP = float(1) / float(self.PLL_DIV_VALUE + 1)} else {self.CLKOUT_SETUP = float(self.PLL_MULT_VALUE) / float(self.PLL_DIV_VALUE + 1)})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst IAI_SETUP :: "Use Prior-to-Idle Settings" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Use Prior-to-Idle Settings,Start Entire Locking Sequence"
        prop Label :: "PLL Response After Idle (IAI) "
        prop JSName :: "pllClkmdIai"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (self.IAI_SETUP = $1, if ($1 == "Use Prior-to-Idle Settings") {self.IAI_VALUE = 0} else {self.IAI_VALUE = 1}, "ok")
    }
    inst IOB_SETUP :: "Ignore" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Ignore,Start New Locking Sequence"
        prop Label :: "Response to Loss of PLL Core Lock (IOB)                    "
        prop JSName :: "pllClkmdIob"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (self.IOB_SETUP = $1, if ($1 == "Ignore") {self.IOB_VALUE = 0} else {self.IOB_VALUE = 1}, "ok")
    }
    inst PLL_MULT_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PLL Multiply Value (PLL_MULT) "
        prop JSName :: "pllClkmdPllmult"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (if (($1 >= 0) && ($1 <= 31)) {self.PLL_MULT_SETUP = $1, self.PLL_MULT_VALUE = $1, self.CLKOUT_update()} else {self.error("PLL_MULT value exceeds limits")}, "ok")
    }
    inst PLL_DIV_SETUP :: "CLKOUT = CLKIN" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "CLKOUT = CLKIN,CLKOUT = CLKIN/2,CLKOUT = CLKIN/3,CLKOUT = CLKIN/4"
        prop Label :: "PLL Divide Value (PLL_DIV) "
        prop JSName :: "pllClkmdPlldiv"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop Set :: (self.PLL_DIV_SETUP = $1, if ($1 == "CLKOUT = CLKIN") {self.PLL_DIV_VALUE = 0} else {if ($1 == "CLKOUT = CLKIN/2") {self.PLL_DIV_VALUE = 1} else {if ($1 == "CLKOUT = CLKIN/3") {self.PLL_DIV_VALUE = 2} else {self.PLL_DIV_VALUE = 3}}}, self.CLKOUT_update(), "ok")
    }
    inst CLKOUT_SETUP :: 1.000 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.3f"
        prop Label :: "Output Clock Frequency:  CLKOUT = CLKIN x "
        prop JSName :: "pllClkout"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "Settings"
    }
    inst IAI_VALUE :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Response After Idle (IAI) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst IOB_VALUE :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "Response to Loss of PLL Core Lock (IOB) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst PLL_MULT_VALUE :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Multiply Value (PLL_MULT) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    inst PLL_DIV_VALUE :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Format :: "0x%04x"
        prop Label :: "PLL Divide Value (PLL_DIV) "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Settings"
        prop cGen :: 1
        prop cType :: "Uint16"
    }
}

type hPLL {
    isa ObjectMgr
    prop name :: "hPLL"
    prop Label :: "PLL Resource Manager"
    prop JSName :: "HPLL"
    prop GlobalHelpTopic :: 1072
    prop InstanceHelpTopic :: 1072
    prop GlobalIcon :: 173
    prop InstanceIcon :: 174
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: PLLFOLDER
    prop maxObjs :: (1)
    prop NoGen :: 1
    prop cGen :: 1
    prop cHeaderName :: if self.c55pll == 1 {"csl_pll.h"} else {""}
    prop cConfigName :: "PLL_config"
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55pll :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x PLL configured "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Configuration of PLL "
        prop JSName :: "pllEnablePreInit"
        prop Visible :: 1
        prop Writable :: (CLK.USETIMER == 1)
        prop NoGen :: 1
        prop Set :: (self.PINIT_ENABLE = $1, if ($1 == 1) {self.c55pll = 1} else {self.c55pll = 0}, "ok")
    }
    inst cConfigGen :: = ((self.PINIT_ENABLE == 1) && (self.cConfigArg0 != PLL_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    inst cConfigArg0 :: PLL_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: pllCfg
        prop Label :: "Pre-initialize"
        prop JSName :: "pllPreInit"
        prop Visible :: 1
        prop Writable :: self.PINIT_ENABLE
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object PLL_NOTHING :: pllCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param IAI_SETUP :: "Use Prior-to-Idle Settings"
    param IOB_SETUP :: "Ignore"
    param PLL_MULT_SETUP :: 0
    param PLL_DIV_SETUP :: "CLKOUT = CLKIN"
    param CLKOUT_SETUP :: 1.000000
    param IAI_VALUE :: 0
    param IOB_VALUE :: 0
    param PLL_MULT_VALUE :: 0
    param PLL_DIV_VALUE :: 0
}

object PLL0 :: hPLL {
    param iComment :: "PLL 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hPLL"
    param iDelMsg :: "PLL 0"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: PLL_NOTHING
}

type PWRFOLDER {
    prop Label :: "Power"
    prop GlobalIcon :: 185
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1090
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type pwrCfg {
    isa ObjectMgr
    prop name :: "PWR"
    prop Label :: "Power Configuration Manager"
    prop JSName :: "PWR"
    prop GlobalHelpTopic :: 1091
    prop InstanceHelpTopic :: 1091
    prop IsContainedIn :: PWRFOLDER
    prop GlobalIcon :: 185
    prop InstanceIcon :: 186
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: 0
    prop cHeaderName :: if self.c55pwr == 1 {"csl_pwr.h"} else {""}
    prop NoGen :: 1
    prop maxObjs :: 0
    prop CLOCKGEN_VALUE :: (if (self.CLOCKGEN_SETUP == 1) {0x10} else {0x00})
    prop EMIF_VALUE :: (if (self.EMIF_SETUP == 1) {0x20} else {0x00})
    prop CPU_VALUE :: (if (self.CPU_SETUP == 1) {0x01} else {0x00})
    prop DMA_VALUE :: (if (self.DMA_SETUP == 1) {0x02} else {0x00})
    prop CACHE_VALUE :: (if (self.CACHE_SETUP == 1) {0x04} else {0x00})
    prop PERI_VALUE :: (if ((self.TIMER0_SETUP == 1) || (self.TIMER1_SETUP == 1) || (self.MCBSP0_SETUP == 1) || (self.MCBSP1_SETUP == 1) || (self.MCBSP2_SETUP == 1)) {0x08} else {0x00})
    prop ICR_VALUE_update :: (self.EMIF_VALUE | self.CLOCKGEN_VALUE | self.PERI_VALUE | self.CACHE_VALUE | self.DMA_VALUE | self.CPU_VALUE)
    prop mcBspVal0_update :: if (self.MCBSP0_SETUP == 1) {"MCBSP_FSET(PCR0,IDLEEN,1);\n"} else {""}
    prop mcBspVal1_update :: if (self.MCBSP1_SETUP == 1) {"MCBSP_FSET(PCR1,IDLEEN,1);\n"} else {""}
    prop mcBspVal2_update :: if (self.MCBSP2_SETUP == 1) {"MCBSP_FSET(PCR2,IDLEEN,1);\n"} else {""}
    prop timerVal0_update :: if (self.TIMER0_SETUP == 1) {"TIMER_FSET(TCR0,IDLEEN,1);\n"} else {""}
    prop timerVal1_update :: if (self.TIMER1_SETUP == 1) {"TIMER_FSET(TCR1,IDLEEN,1);\n"} else {""}
    prop i2cVal_update :: if (self.I2C_SETUP == 1) {"I2C_FSET(ICMDR,IDLEEN,1);\n"} else {""}
    prop clockoutVal_update :: (if (GBL.CHIPTYPE == "5509") {if (self.CLOCKOUT_SETUP == 1) {"CHIP_FSET(ST3_55, CLKOFF, 0x04);\nCHIP_FSET(XBSR,CLKOUT, 1);\n"} else {""}} else {if (self.CLOCKOUT_SETUP == 1) {"CHIP_FSET(ST3_55, CLKOFF, 0x04);\n"} else {""}})
    prop oscVal_update :: (if (self.EBSELOSC_SETUP == 1) {"CHIP_FSET(XBSR, OSCDIS, 1);\n"} else {""})
    prop icrValue :: self.ICR_VALUE
    prop icrStr :: "CSL_init();\n"
    prop icrStr1 :: "\nPWR_RSET(ICR, 0x%3d);\n"
    prop mcbspVal0 :: self.MCBSP0_VALUE
    prop mcbspVal1 :: self.MCBSP1_VALUE
    prop mcbspVal2 :: self.MCBSP2_VALUE
    prop timerVal0 :: self.TIMER0_VALUE
    prop timerVal1 :: self.TIMER1_VALUE
    prop i2cVal :: self.I2C_VALUE
    prop clockVal :: self.CLOCKOUT_VALUE
    prop oscVal :: self.EBSELOSC_VALUE
    prop cGenFxnEpilogue :: (if (self.c55pwr == 1) {"%5t%2S%4S%5S%6S%7S%8S%9S%10S%11S%0t\0, 
			icrStr,icrStr1,icrValue,mcbspVal0,mcbspVal1,mcbspVal2,timerVal0,timerVal1,clockVal,i2cVal,oscVal"} )
    prop includeStr :: "#include <csl_pwrhal.h>\n"
    prop inclStr :: if ((self.TIMER0_SETUP == 1) || (self.TIMER1_SETUP == 1)) {"#include <csl_timhal.h>\n"} else {""}
    prop incStr :: if ((self.MCBSP0_SETUP == 1) || (self.MCBSP1_SETUP == 1) || (self.MCBSP2_SETUP == 1)) {"#include <csl_mcbsphal.h>\n"} else {""}
    prop i2cStr :: if (self.I2C_SETUP == 1) {"#include <csl_i2chal.h>\n"} else {""}
    prop oscStr :: if ((self.EBSELOSC_SETUP == 1) || (self.CLOCKOUT_SETUP == 1)) {"#include <csl_chiphal.h>\n"} else {""}
    prop cGenCPrologue :: (if (self.c55pwr == 1) {"%1S%2S%3S%4S%5S\n\n\0, includeStr, inclStr,incStr,i2cStr,oscStr"} )
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55pwr :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x PWR opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global configPwr :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Pre-initialization "
        prop JSName :: "pwrConfigPwr"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "General"
        prop Set :: (self.configPwr = $1, if ($1 == 1) {self.c55pwr = 1} else {self.c55pwr = 0}, "ok")
    }
    global CLOCKGEN_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clock Generator Disable "
        prop JSName :: "pwrClockgenPwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.CLOCKGEN_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), "ok")
    }
    global CACHE_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CACHE Disable "
        prop JSName :: "pwrCachePwrDwnMode"
        prop Visible :: !(GBL.CHIPTYPE == "5509")
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.CACHE_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), "ok")
    }
    global CPU_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CPU Disable "
        prop JSName :: "pwrCpuPwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.CPU_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), "ok")
    }
    global DMA_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DMA Disable "
        prop JSName :: "pwrDmaPwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.DMA_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), "ok")
    }
    global EMIF_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "EMIF Disable "
        prop JSName :: "pwrEmifPwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.EMIF_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), "ok")
    }
    global MCBSP0_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 0 Disable "
        prop JSName :: "pwrMcbsp0PwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.MCBSP0_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), self.MCBSP0_VALUE = self.mcBspVal0_update(), "ok")
    }
    global MCBSP1_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 1 Disable "
        prop JSName :: "pwrMcbsp1PwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.MCBSP1_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), self.MCBSP1_VALUE = self.mcBspVal1_update(), "ok")
    }
    global MCBSP2_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp 2 Disable "
        prop JSName :: "pwrMcbsp2PwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.MCBSP2_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), self.MCBSP2_VALUE = self.mcBspVal2_update(), "ok")
    }
    global TIMER0_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 0 Disable "
        prop JSName :: "pwrTimer0PwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.TIMER0_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), self.TIMER0_VALUE = self.timerVal0_update(), "ok")
    }
    global TIMER1_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer 1 Disable "
        prop JSName :: "pwrTimer1PwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.TIMER1_SETUP = $1, self.ICR_VALUE = self.ICR_VALUE_update(), self.TIMER1_VALUE = self.timerVal1_update(), "ok")
    }
    global I2C_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "I2C Disable "
        prop JSName :: "pwrI2cPwrDwnMode"
        prop Visible :: (GBL.CHIPTYPE == "5509")
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "Power Save During IDLE Instruction"
        prop Set :: (self.I2C_SETUP = $1, self.I2C_VALUE = self.i2cVal_update(), "ok")
    }
    global NOTE :: "     See Spru 317 Ch. 8 for IDLE domain combinations that do not make sense" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Power Save During IDLE Instruction"
        prop NoGen :: 1
    }
    global CLOCKOUT_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clockout Pin Disable "
        prop JSName :: "pwrClockoutPwrDwnMode"
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop NoGen :: 1
        prop TabName :: "General Power Savings"
        prop Set :: (self.CLOCKOUT_SETUP = $1, self.CLOCKOUT_VALUE = self.clockoutVal_update(), "ok")
    }
    global CLKMEM_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Disable CLKMEM "
        prop JSName :: "pwrClkmemPwrDwnMode"
        prop Visible :: 1
        prop Writable :: (self.configPwr) && !(emifCfg.SYNCH)
        prop NoGen :: 1
        prop TabName :: "General Power Savings"
        prop Set :: (self.CLKMEM_SETUP = $1, self.CLKMEM_VALUE = self.clkmemVal_update(), "ok")
    }
    global EBSELOSC_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Oscillator Disable "
        prop JSName :: "pwrOscPwrDwnMode"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: self.configPwr
        prop TabName :: "General Power Savings"
        prop Set :: (self.EBSELOSC_SETUP = $1, self.EBSELOSC_VALUE = self.oscVal_update(), "ok")
    }
    global INFO :: "Additional Power Saving Tips:" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
    }
    global PLL :: "Set your PLL to minimum MIPS required. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
    }
    global GPIO :: "If unused, set all GPIO pins as output high. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
    }
    global EMIF :: "If asynchronous memory is used, disable CLKMEM. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
    }
    global NOTE_ :: "The unused GPIO pins can be disabled (5509 only)" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "General"
        prop NoGen :: 1
    }
    global ICR_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "IDLE Configuration Register "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
        prop cType :: "Uint16"
    }
    global MCBSP0_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global MCBSP1_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global MCBSP2_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "McBsp Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global TIMER0_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global TIMER1_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global I2C_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "I2C Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global CLOCKOUT_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Clockout Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    global EBSELOSC_VALUE :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Oscillator Disable Value"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
}

type RTCFOLDER {
    prop Label :: "Real Time Clock "
    prop GlobalIcon :: 187
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1100
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type rtcCfg {
    isa ObjectMgr
    prop name :: "RTC"
    prop Label :: "Real Time Clock Configuration Manager"
    prop JSName :: "RTC"
    prop GlobalHelpTopic :: 1101
    prop InstanceHelpTopic :: 1101
    prop IsContainedIn :: RTCFOLDER
    prop GlobalIcon :: 187
    prop InstanceIcon :: 188
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: (GBL.CHIPTYPE == "5509")
    prop cStructType :: "RTC_Config"
    prop cHeaderName :: if ((self.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {"csl_rtc.h"} else {""}
    prop NoGen :: 1
    prop AMPM_RTHOUR :: (if (self.AMPM_SETUP == "PM") {0x80} else {0x00})
    prop DAEN_RTDAYW :: (if (self.PERDAYALARM_SETUP == 1) {0x08} else {0x00})
    prop DAR_RTDAYW :: (if (self.DAYWAL_SETUP == "Sunday") {0x18} else {if (self.DAYWAL_SETUP == "Monday") {0x28} else {if (self.DAYWAL_SETUP == "Tuesday") {0x38} else {if (self.DAYWAL_SETUP == "Wednesday") {0x48} else {if (self.DAYWAL_SETUP == "Thursday") {0x58} else {if (self.DAYWAL_SETUP == "Friday") {0x68} else {0x70}}}}}})
    prop MINALARM_RTMINA :: (if (self.PERMINUTEALARM_SETUP == 1) {0xC0} else {0x00})
    prop SECALARM_RTSECA :: (if (self.PERSECONDALARM_SETUP == 1) {0xC0} else {0x00})
    prop HRALARM_RTHOURA :: (if (self.PERHOURALARM_SETUP == 1) {0xC0} else {0x00})
    prop DAYALARM_RTDAYW :: (if (self.PERDAYALARM_SETUP == 1) {0x80} else {0x00})
    prop RTCSECA_VALUE_update :: (self.SECALARM_RTSECA | self.DEC_to_BCD(self.SECONDAL_SETUP))
    prop RTCMINA_VALUE_update :: (self.MINALARM_RTMINA | self.DEC_to_BCD(self.MINUTEAL_SETUP))
    prop RTCHOUR_VALUE_update :: (self.DEC_to_BCD(self.HOUR24_SETUP))
    prop RTCHOURA_VALUE_update :: (self.DEC_to_BCD(self.HOURAL24_SETUP) | self.HRALARM_RTHOURA)
    prop RTCDAYW_VALUE_update :: (self.DAYALARM_RTDAYW | self.DAR_RTDAYW | self.DAEN_RTDAYW | self.DAYW_VALUE_update())
    prop RTCDAYM_VALUE_update :: (self.DEC_to_BCD(self.DAYM_SETUP))
    prop RTCMONTH_VALUE_update :: (self.DEC_to_BCD(self.MONTH_VALUE_update()))
    prop RTCPINTR_VALUE_update :: (if (self.RS_SETUP == "None") {0x00} else {if (self.RS_SETUP == "122us") {0x03} else {if (self.RS_SETUP == "244us") {0x04} else {if (self.RS_SETUP == "488us") {0x05} else {if (self.RS_SETUP == "976us") {0x06} else {if (self.RS_SETUP == "1.95ms") {0x07} else {if (self.RS_SETUP == "3.9ms") {0x08} else {if (self.RS_SETUP == "7.8125ms") {0x09} else {if (self.RS_SETUP == "15.625ms") {0x0A} else {if (self.RS_SETUP == "31.25ms") {0x0B} else {if (self.RS_SETUP == "62.5ms") {0x0C} else {if (self.RS_SETUP == "125ms") {0x0D} else {if (self.RS_SETUP == "250ms") {0x0E} else {if (self.RS_SETUP == "500ms") {0x0F} else {0x1F}}}}}}}}}}}}}})
    prop RTSECA_SETUP_update :: (self.PERSECONDALARM_SETUP = if (self.RTCSECA_VALUE & 0xC0) {1} else {0}, self.SECONDAL_SETUP = self.BCD_to_DEC($1 & 0x7F))
    prop RTMINA_SETUP_update :: (self.PERMINUTEALARM_SETUP = if (self.RTCMINA_VALUE & 0xC0) {1} else {0}, self.MINUTEAL_SETUP = self.BCD_to_DEC(self.RTCMINA_VALUE & 0x7F))
    prop RTDAYW_SETUP_update :: (self.PERDAYALARM_SETUP = if (self.RTCDAYW_VALUE & 0x80) {1} else {0}, self.DAYWAL_SETUP = ($a = ($1 & 0x70), if ($a == 0x10) {"Sunday"} else {if ($a == 0x20) {"Monday"} else {if ($a == 0x30) {"Tuesday"} else {if ($a == 0x40) {"Wednesday"} else {if ($a == 0x50) {"Thursday"} else {if ($a == 0x60) {"Friday"} else {"Saturday"}}}}}}), self.DAYW_SETUP = ($a = ($1 & 0x07), if ($a == 0x01) {"Sunday"} else {if ($a == 0x02) {"Monday"} else {if ($a == 0x03) {"Tuesday"} else {if ($a == 0x04) {"Wednesday"} else {if ($a == 0x05) {"Thursday"} else {if ($a == 0x06) {"Friday"} else {"Saturday"}}}}}}))
    prop RTDAYM_SETUP_update :: (self.DAYM_SETUP = self.BCD_to_DEC($1 & 0x3F))
    prop RTMONTH_SETUP_update :: (self.MONTH_SETUP = ($a = (self.RTCMONTH_VALUE & 0x1f), if ($a == 0x01) {"January"} else {if ($a == 0x02) {"February"} else {if ($a == 0x03) {"March"} else {if ($a == 0x04) {"April"} else {if ($a == 0x05) {"May"} else {if ($a == 0x06) {"June"} else {if ($a == 0x07) {"July"} else {if ($a == 0x08) {"August"} else {if ($a == 0x09) {"September"} else {if ($a == 0x10) {"October"} else {if ($a == 0x11) {"November"} else {"December"}}}}}}}}}}}))
    prop RTPINTR_SETUP_update :: (self.RS_SETUP = ($a = ($1 & 0x1f), if (($a == 0x00) || ($a == 0x01) || ($a == 0x02)) {"None"} else {if ($a == 0x03) {"122us"} else {if ($a == 0x04) {"244us"} else {if ($a == 0x05) {"488us"} else {if ($a == 0x06) {"976us"} else {if ($a == 0x07) {"1.95ms"} else {if ($a == 0x08) {"3.9ms"} else {if ($a == 0x09) {"7.8125ms"} else {if ($a == 0x0A) {"15.625ms"} else {if ($a == 0x0B) {"31.25ms"} else {if ($a == 0x0C) {"62.5ms"} else {if ($a == 0x0D) {"125ms"} else {if ($a == 0x0E) {"250ms"} else {if ($a == 0x0F) {"500ms"} else {"1 minute"}}}}}}}}}}}}}}))
    prop RTHOUR_SETUP_update :: (self.HOUR24_SETUP = self.BCD_to_DEC($1 & 0x3F), if (self.HOUR24_SETUP > 12) {self.HOUR12_SETUP = self.HOUR24_SETUP - 12, self.AMPM_SETUP = "PM"} else {if (self.HOUR24_SETUP == 0) {self.HOUR12_SETUP = 12, self.AMPM_SETUP = "PM"} else {self.HOUR12_SETUP = self.HOUR24_SETUP, self.AMPM_SETUP = "AM"}})
    prop RTHOURA_SETUP_update :: (self.HOURAL24_SETUP = self.BCD_to_DEC($1 & 0x3F), if (self.HOURAL24_SETUP > 12) {self.HOURAL12_SETUP = self.HOURAL24_SETUP - 12, self.AMPMAL_SETUP = "PM"} else {if (self.HOURAL24_SETUP == 0) {self.HOURAL12_SETUP = 12, self.AMPMAL_SETUP = "PM"} else {self.HOURAL12_SETUP = self.HOURAL24_SETUP, self.AMPMAL_SETUP = "AM"}}, self.PERHOURALARM_SETUP = if ((self.RTCHOURA_VALUE & 0xC0) && (self.PERMINUTEALARM_SETUP == 0) && (self.PERSECONDALARM_SETUP == 0)) {1} else {0})
    prop BCD_to_DEC :: (((($1 >> 4) & 0x000F) * 10) + ($1 & 0x000F))
    prop DEC_to_BCD :: ($a = $1, $b = 0, $c = 0, while ($a > 0) {$a -= 10, $b++}, if ($a != 0) {$a += 10, $b--} , $b * 16 + $a)
    prop DAYW_VALUE_update :: (if (self.DAYW_SETUP == "Sunday") {0x01} else {if (self.DAYW_SETUP == "Monday") {0x02} else {if (self.DAYW_SETUP == "Tuesday") {0x03} else {if (self.DAYW_SETUP == "Wednesday") {0x04} else {if (self.DAYW_SETUP == "Thursday") {0x05} else {if (self.DAYW_SETUP == "Friday") {0x06} else {0x07}}}}}})
    prop MONTH_VALUE_update :: (if (self.MONTH_SETUP == "January") {1} else {if (self.MONTH_SETUP == "February") {2} else {if (self.MONTH_SETUP == "March") {3} else {if (self.MONTH_SETUP == "April") {4} else {if (self.MONTH_SETUP == "May") {5} else {if (self.MONTH_SETUP == "June") {6} else {if (self.MONTH_SETUP == "July") {7} else {if (self.MONTH_SETUP == "August") {8} else {if (self.MONTH_SETUP == "September") {9} else {if (self.MONTH_SETUP == "October") {10} else {if (self.MONTH_SETUP == "November") {11} else {12}}}}}}}}}}})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst RS_SETUP :: "None" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Interrupt Rate "
        prop JSName :: "rtcRtcpintrRs"
        prop Enum :: "None,122us,244us,488us,976us,1.95ms,3.9ms,7.8125ms,15.625ms,31.25ms,62.5ms,125ms,250ms,500ms,1 minute"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.RS_SETUP = $1, self.RTCPINTR_VALUE = self.RTCPINTR_VALUE_update(), "ok")
    }
    inst MODE_SETUP :: "12 Hour Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Choose Mode "
        prop JSName :: "rtcRtcintenSet"
        prop Enum :: "12 Hour Mode,24 Hour Mode"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.MODE_SETUP = $1, self.RTCHOUR_VALUE = self.RTCHOUR_VALUE_update(), "ok")
    }
    inst YEAR_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "20%02d"
        prop Label :: "Year      "
        prop JSName :: "rtcRtcyearYear"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (if (($1 >= 1) && ($1 <= 99)) {self.YEAR_SETUP = $1, self.RTCYEAR_VALUE = self.DEC_to_BCD($1), "ok"} else {if (($1 >= 2001) && ($1 <= 2099)) {self.YEAR_SETUP = $1 - 2000, self.RTCYEAR_VALUE = self.DEC_to_BCD($1 - 2000), "ok"} else {self.error("Year entered not supported. Valid range: 2001 - 2099")}})
    }
    inst MONTH_SETUP :: "January" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Month "
        prop JSName :: "rtcRtcmonthMonth"
        prop Enum :: "January,February,March,April,May,June,July,August,September,October,November,December"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.MONTH_SETUP = $1, self.RTCMONTH_VALUE = self.RTCMONTH_VALUE_update(), "ok")
    }
    inst DAYM_SETUP :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Date "
        prop JSName :: "rtcRtcdaymDate"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.DAYM_SETUP = $1, self.RTCDAYM_VALUE = self.RTCDAYM_VALUE_update(), "ok")
    }
    inst DAYW_SETUP :: "Sunday" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Day of the Week"
        prop JSName :: "rtcRtcdaywDay"
        prop Enum :: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.DAYW_SETUP = $1, self.RTCDAYW_VALUE = self.RTCDAYW_VALUE_update(), "ok")
    }
    inst ____________________ :: "" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Set Date/Time"
        prop NoGen :: 1
    }
    inst HOUR24_SETUP :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Hour (24-hour mode) "
        prop JSName :: "rtcRtchourHr24"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "24 Hour Mode")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.HOUR24_SETUP = $1, if ($1 > 12) {self.HOUR12_SETUP = $1 - 12, self.AMPM_SETUP = "PM"} else {if ($1 == 0) {self.HOUR12_SETUP = 12, self.AMPM_SETUP = "PM"} else {self.HOUR12_SETUP = $1, self.AMPM_SETUP = "AM"}}, self.RTCHOUR_VALUE = self.RTCHOUR_VALUE_update(), "ok")
    }
    inst HOUR12_SETUP :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Hour (12-hour mode) "
        prop JSName :: "rtcRtchourHr12"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "12 Hour Mode"))
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.HOUR12_SETUP = $1, if (self.AMPM_SETUP == "AM") {self.HOUR24_SETUP = $1} else {if ($1 == 12) {self.HOUR24_SETUP = 0} else {self.HOUR24_SETUP = $1 + 12}}, self.RTCHOUR_VALUE = self.RTCHOUR_VALUE_update(), "ok")
    }
    inst AMPM_SETUP :: "AM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "AM/PM "
        prop JSName :: "rtcRtchourAmpm"
        prop Enum :: "AM,PM"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "12 Hour Mode"))
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (self.AMPM_SETUP = $1, if ($1 == "AM") {self.HOUR24_SETUP = self.HOUR12_SETUP} else {if (self.HOUR12_SETUP == 12) {self.HOUR24_SETUP = 0} else {self.HOUR24_SETUP = self.HOUR12_SETUP + 12}, self.RTCHOUR_VALUE = self.RTCHOUR_VALUE_update(), "ok"})
    }
    inst MINUTE_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Minute "
        prop JSName :: "rtcRtcminMin"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (if (($1 < 60) && ($1 > 0)) {self.MINUTE_SETUP = $1, self.RTCMIN_VALUE = self.DEC_to_BCD($1), "ok"} else {self.error("Wrong minute. Valid range: 0 - 59")})
    }
    inst SECOND_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Second "
        prop JSName :: "rtcRtcsecSec"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Date/Time"
        prop Set :: (if (($1 < 60) && ($1 >= 0)) {self.SECOND_SETUP = $1, self.RTCSEC_VALUE = self.DEC_to_BCD($1), "ok"} else {self.error("Wrong second. Valid range: 0 - 59")})
    }
    inst HOURAL24_SETUP :: 0 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Alarm Hour (24-hour mode) "
        prop JSName :: "rtcRtchouraHar24"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "24 Hour Mode") && !(self.PERHOURALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.HOURAL24_SETUP = $1, if ($1 > 12) {self.HOURAL12_SETUP = $1 - 12, self.AMPMAL_SETUP = "PM"} else {if ($1 == 0) {self.HOURAL12_SETUP = 12, self.AMPMAL_SETUP = "PM"} else {self.HOURAL12_SETUP = $1, self.AMPMAL_SETUP = "AM"}}, self.RTCHOURA_VALUE = self.RTCHOURA_VALUE_update(), "ok")
    }
    inst HOURAL12_SETUP :: 1 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Alarm Hour (12-hour mode) "
        prop JSName :: "rtcRtchouraHar12"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "12 Hour Mode") && !(self.PERHOURALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.HOURAL12_SETUP = $1, if (self.AMPMAL_SETUP == "AM") {self.HOURAL24_SETUP = $1} else {if ($1 == 12) {self.HOURAL24_SETUP = 0} else {self.HOURAL24_SETUP = $1 + 12}}, self.RTCHOURA_VALUE = self.RTCHOURA_VALUE_update(), "ok")
    }
    inst AMPMAL_SETUP :: "AM" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "AM/PM "
        prop JSName :: "rtcRtchouraAmpm"
        prop Enum :: "AM,PM"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.MODE_SETUP == "12 Hour Mode") && !(self.PERHOURALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.AMPMAL_SETUP = $1, if ($1 == "AM") {self.HOURAL24_SETUP = self.HOURAL12_SETUP} else {if (self.HOURAL12_SETUP == 12) {self.HOURAL24_SETUP = 0} else {self.HOURAL24_SETUP = self.HOURAL12_SETUP + 12}}, self.RTCHOURA_VALUE = self.RTCHOURA_VALUE_update(), "ok")
    }
    inst MINUTEAL_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Minute "
        prop JSName :: "rtcRtcminaMar"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && !(self.PERMINUTEALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (if (($1 < 60) && ($1 >= 0)) {self.MINUTEAL_SETUP = $1, self.RTCMINA_VALUE = self.RTCMINA_VALUE_update(), "ok"} else {self.error("Wrong minute. Valid range: 0 - 59")})
    }
    inst SECONDAL_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Second "
        prop JSName :: "rtcRtcsecaSar"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && !(self.PERSECONDALARM_SETUP))
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (if (($1 < 60) && ($1 >= 0)) {self.SECONDAL_SETUP = $1, self.RTCSECA_VALUE = self.RTCSECA_VALUE_update(), "ok"} else {self.error("Wrong second. Valid range: 0 - 59")})
    }
    inst DAYWAL_SETUP :: "Sunday" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Day of the Week"
        prop JSName :: "rtcRtcdaywDar"
        prop Enum :: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && !(self.PERDAYALARM_SETUP)
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.DAYWAL_SETUP = $1, self.RTCDAYW_VALUE = self.RTCDAYW_VALUE_update(), "ok")
    }
    inst ___________________ :: "" { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Set Alarm"
        prop NoGen :: 1
    }
    inst PERMINUTEALARM_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Minute "
        prop JSName :: "rtcPerminutealarm"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.PERMINUTEALARM_SETUP = $1, self.RTCMINA_VALUE = self.RTCMINA_VALUE_update(), "ok")
    }
    inst PERSECONDALARM_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Second "
        prop JSName :: "rtcPersecondalarm"
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.PERSECONDALARM_SETUP = $1, self.RTCSECA_VALUE = self.RTCSECA_VALUE_update(), "ok")
    }
    inst PERHOURALARM_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Hour "
        prop JSName :: "rtcPerhouralarm"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.PERHOURALARM_SETUP = $1, self.RTCHOURA_VALUE = self.RTCHOURA_VALUE_update(), "ok")
    }
    inst PERDAYALARM_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Periodic Alarm Every Day "
        prop JSName :: "rtcPerweekalarm"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Set Alarm"
        prop Set :: (self.PERDAYALARM_SETUP = $1, self.RTCDAYW_VALUE = self.RTCDAYW_VALUE_update(), "ok")
    }
    inst RTC_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually "
        prop JSName :: "rtcSetManually"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Advanced"
    }
    inst RTCSEC_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Seconds Register (RTCSEC) "
        prop JSName :: "rtcRtcsecAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 <= 0x59) && ($1 >= 0x00)) {self.RTCSEC_VALUE = $1, self.SECOND_SETUP = self.BCD_to_DEC(self.RTCSEC_VALUE), "ok"} else {self.error("Wrong value for second. Valid range: 0 - 59")})
    }
    inst RTCSECA_VALUE :: self.RTCSECA_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Seconds Alarm Register (RTCSECA) "
        prop JSName :: "rtcRtcsecaAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCSECA_VALUE = $1, self.RTSECA_SETUP_update($1), "ok")
    }
    inst RTCMIN_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Minutes Register (RTCMIN) "
        prop JSName :: "rtcRtcminAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (if (($1 <= 0x59) && ($1 >= 0x00)) {self.RTCMIN_VALUE = $1, self.MINUTE_SETUP = self.BCD_to_DEC(self.RTCMIN_VALUE), "ok"} else {self.error("Wrong value for minute. Valid range: 0 - 59")})
    }
    inst RTCMINA_VALUE :: self.RTCMINA_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Minutes Alarm Register (RTCMINA) "
        prop JSName :: "rtcRtcminaAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCMINA_VALUE = $1, self.RTMINA_SETUP_update($1), "ok")
    }
    inst RTCHOUR_VALUE :: self.RTCHOUR_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Hour Register (RTCHOUR) "
        prop JSName :: "rtcRtchourAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCHOUR_VALUE = $1, self.RTHOUR_SETUP_update($1), "ok")
    }
    inst RTCHOURA_VALUE :: self.RTCHOURA_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Hour Alarm Register (RTCHOURA) "
        prop JSName :: "rtcRtchouraAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCHOURA_VALUE = $1, self.RTHOURA_SETUP_update($1), "ok")
    }
    inst RTCDAYW_VALUE :: self.RTCDAYW_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Day of the Week Register (RTCDAYW) "
        prop JSName :: "rtcRtcdaywAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCDAYW_VALUE = $1, self.RTDAYW_SETUP_update($1), "ok")
    }
    inst RTCDAYM_VALUE :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Day of the Month Register (RTCDAYM) "
        prop JSName :: "rtcRtcdaymAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCDAYM_VALUE = $1 & 0xbf, self.RTDAYM_SETUP_update($1 & 0xbf), "ok")
    }
    inst RTCMONTH_VALUE :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Month Register (RTCMONTH) "
        prop JSName :: "rtcRtcmonthAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCMONTH_VALUE = $1 & 0x9f, self.RTMONTH_SETUP_update($1), "ok")
    }
    inst RTCYEAR_VALUE :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Year Register (RTCYEAR) "
        prop JSName :: "rtcRtcyearAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCYEAR_VALUE = $1, self.YEAR_SETUP = self.BCD_to_DEC(self.RTCYEAR_VALUE), "ok")
    }
    inst RTCPINTR_VALUE :: self.RTCPINTR_VALUE_update($1) { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Periodic Interrupt Selection Register (RTCPINTR) "
        prop JSName :: "rtcRtcpintrAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCPINTR_VALUE = ($1 & 0x1F), self.RTPINTR_SETUP_update($1), "ok")
    }
    inst RTCINTEN_VALUE :: 2 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%02x"
        prop Label :: "Interrupt Enable Register (RTCINTEN) "
        prop JSName :: "rtcRtcintenAdv"
        prop Visible :: 1
        prop Writable :: self.RTC_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.RTCINTEN_VALUE = ($1 & 0x82), self.MODE_SETUP = if ($1 & 0x02) {"24 Hour Mode"} else {"12 Hour Mode"}, "ok")
    }
}

type rtcRes {
    isa ObjectMgr
    prop name :: "RTCRes"
    prop Label :: "Real Time Clock Resource Manager"
    prop JSName :: "RTCRES"
    prop GlobalHelpTopic :: 1102
    prop InstanceHelpTopic :: 1103
    prop GlobalIcon :: 187
    prop InstanceIcon :: 188
    prop GlobalPropertyPage :: "{1C8F8861-E550-11d4-9745-00B0D0524DFE}"
    prop InstancePropertyPage :: "{1C8F8862-E550-11d4-9745-00B0D0524DFE}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: RTCFOLDER
    prop maxObjs :: (1)
    prop cHeaderName :: if (GBL.CHIPTYPE == "5509") {"csl_rtc.h"} else {""}
    prop NoGen :: 1
    prop cGen :: 1
    prop cConfigName :: "RTC_config"
    prop comment :: if (GBL.CHIPTYPE == "5509") {"/* You must use RTC_start() in your main code to start the RTC. */"} else {""}
    prop cGenFxnEpilogue :: ("%5t\n%1s\n\n%0t\0,comment")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst configRtc :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable RTC Configuration "
        prop JSName :: "rtcCfgEnable"
        prop NoGen :: 1
        prop Visible :: (GBL.CHIPTYPE == "5509")
        prop Writable :: 1
    }
    inst cConfigGen :: = ((self.configRtc) && (self.cConfigArg0 != RTC_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable RTC Configuration "
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    inst cConfigArg0 :: RTC_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: rtcCfg
        prop Label :: "Pre-initialize"
        prop JSName :: "rtcPreInit"
        prop cPreVal :: "&"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.configRtc))
    }
}

object RTC_NOTHING :: rtcCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param RS_SETUP :: "None"
    param MODE_SETUP :: "12 Hour Mode"
    param YEAR_SETUP :: 1
    param MONTH_SETUP :: "January"
    param DAYM_SETUP :: 1
    param DAYW_SETUP :: "Sunday"
    param ____________________ :: ""
    param HOUR24_SETUP :: 0
    param HOUR12_SETUP :: 1
    param AMPM_SETUP :: "AM"
    param MINUTE_SETUP :: 0
    param SECOND_SETUP :: 0
    param HOURAL24_SETUP :: 0
    param HOURAL12_SETUP :: 1
    param AMPMAL_SETUP :: "AM"
    param MINUTEAL_SETUP :: 0
    param SECONDAL_SETUP :: 0
    param DAYWAL_SETUP :: "Sunday"
    param ___________________ :: ""
    param PERMINUTEALARM_SETUP :: 0
    param PERSECONDALARM_SETUP :: 0
    param PERHOURALARM_SETUP :: 0
    param PERDAYALARM_SETUP :: 0
    param RTC_man :: 0
    param RTCSEC_VALUE :: 0
    param RTCSECA_VALUE :: 0
    param RTCMIN_VALUE :: 0
    param RTCMINA_VALUE :: 0
    param RTCHOUR_VALUE :: 0
    param RTCHOURA_VALUE :: 0
    param RTCDAYW_VALUE :: 25
    param RTCDAYM_VALUE :: 1
    param RTCMONTH_VALUE :: 1
    param RTCYEAR_VALUE :: 1
    param RTCPINTR_VALUE :: 0
    param RTCINTEN_VALUE :: 2
}

object RTC0 :: rtcRes {
    param iComment :: "RTC "
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "rtcRes"
    param iDelMsg :: "RTC "
    param configRtc :: 0
    param cConfigArg0 :: RTC_NOTHING
}

type TIMERFOLDER {
    prop Label :: "TIMER - Timer Device"
    prop GlobalIcon :: 161
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1080
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type timerCfg {
    isa ObjectMgr
    prop name :: "TIMER"
    prop Label :: "Timer Configuration Manager"
    prop JSName :: "TIMER"
    prop IsContainedIn :: TIMERFOLDER
    prop GlobalHelpTopic :: 1081
    prop InstanceHelpTopic :: 1081
    prop GlobalIcon :: 161
    prop InstanceIcon :: 162
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: 1
    prop cStructType :: "TIMER_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_timer.h"} else {""}
    prop NoGen :: 1
    prop FUNC_TCR :: (if (self.FUNC_SETUP == "Internal(TOUT is Input)") {0x0000} else {if (self.FUNC_SETUP == "Internal(TOUT is Output)") {0x0800} else {0x1000}})
    prop FUNC_SETUP_update :: (if (self.TCR_VALUE & 0x1000) {"External"} else {if (self.TCR_VALUE & 0x0800) {"Internal(TOUT is Output)"} else {"Internal(TOUT is Input)"}})
    prop POLAR_TCR :: (if (self.POLAR_SETUP == "TIN/TOUT starts high") {0x0004} else {0x0000})
    prop PWID_TCR :: (if (self.PWID_SETUP == "1 CLKOUT Period") {0x0000} else {if (self.PWID_SETUP == "2 CLKOUT Periods") {0x0040} else {if (self.PWID_SETUP == "4 CLKOUT Periods") {0x0080} else {0x00C0}}})
    prop PWID_SETUP_update :: (if ((self.TCR_VALUE & 0x00C0) == 0x00C0) {"8 CLKOUT Periods"} else {if (self.TCR_VALUE & 0x0080) {"4 CLKOUT Periods"} else {if (self.TCR_VALUE & 0x0040) {"2 CLKOUT Periods"} else {"1 CLKOUT Period"}}})
    prop CP_TCR :: (if (self.CP_SETUP == "Clock Mode") {0x0008} else {0x0000})
    prop FREE_SOFT_TCR :: (if (self.FREE_SOFT_SETUP == "Stop when counter = 0") {0x0200} else {if (self.FREE_SOFT_SETUP == "Stop Immediately") {0x0000} else {0x0100}})
    prop FREE_SOFT_SETUP_update :: (if (self.TCR_VALUE & 0x0200) {"Stop when counter = 0"} else {if (self.TCR_VALUE & 0x0100) {"Do Not Stop"} else {"Stop Immediately"}})
    prop IDLE_EN_TCR :: (if (self.IDLE_EN_SETUP == 1) {0x8000} else {0x0000})
    prop ARB_TCR :: (if (self.ARB_SETUP == "Enabled") {0x0020} else {0x0000})
    prop TSS_TCR :: (0x0010)
    prop TCR_VALUE_update :: (self.POLAR_TCR() | self.CP_TCR() | self.ARB_TCR() | self.PWID_TCR() | self.FREE_SOFT_TCR() | self.FUNC_TCR() | self.TSS_TCR() | self.IDLE_EN_TCR())
    prop PRSC_VALUE_update :: ((self.TDDR_SETUP & 0x000F))
    prop TCR_SETUP_update :: (self.POLAR_SETUP = if ($1 & 0x0004) {"TIN/TOUT starts high"} else {"TIN/TOUT starts low"}, self.CP_SETUP = if ($1 & 0x0008) {"Clock Mode"} else {"Pulse Mode"}, self.ARB_SETUP = if ($1 & 0x0020) {"Enabled"} else {"Disabled"}, self.PWID_SETUP = self.PWID_SETUP_update(), self.FREE_SOFT_SETUP = self.FREE_SOFT_SETUP_update(), self.FUNC_SETUP = self.FUNC_SETUP_update(), self.IDLE_EN_SETUP = if ($1 & 0x8000) {1} else {0})
    prop PRSC_SETUP_update :: (self.TDDR_SETUP = ($1 & 0x000F))
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst FUNC_SETUP :: "Internal(TOUT is Input)" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Internal(TOUT is Input),Internal(TOUT is Output),External"
        prop Label :: "Clock Source "
        prop JSName :: "timerTcrFunc"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Clock Control"
        prop Set :: (self.FUNC_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst POLAR_SETUP :: "TIN/TOUT starts low" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "TIN/TOUT starts low,TIN/TOUT starts high"
        prop Label :: "Polarity (POLAR) "
        prop JSName :: "timerTcrPolar"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man) && (self.FUNC_SETUP == "Internal(TOUT is Output)")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
        prop Set :: (self.POLAR_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst PWID_SETUP :: "1 CLKOUT Period" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1 CLKOUT Period,2 CLKOUT Periods,4 CLKOUT Periods,8 CLKOUT Periods"
        prop Label :: "Pulse Width (PWID) "
        prop JSName :: "timerTcrPwid"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man) && (self.FUNC_SETUP == "Internal(TOUT is Output)") && (self.CP_SETUP == "Pulse Mode")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
        prop Set :: (self.PWID_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst CP_SETUP :: "Pulse Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Pulse Mode,Clock Mode"
        prop Label :: "Clock/Pulse Mode (C/P) "
        prop JSName :: "timerTcrCp"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man) && (self.FUNC_SETUP == "Internal(TOUT is Output)")
        prop NoGen :: 1
        prop TabName :: "Clock Control"
        prop Set :: (self.CP_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst TDDR_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Timer Divide Down Ratio(TDDR) [0 - 15] "
        prop JSName :: "timerPrscTddr"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (self.TDDR_SETUP = $1, self.PRSC_VALUE = self.PRSC_VALUE_update(), "ok")
    }
    inst PRD_SETUP :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Timer Period (PRD) "
        prop JSName :: "timerPrd"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (self.PRD_SETUP = $1, self.PRD_VALUE = $1, "ok")
    }
    inst FREE_SOFT_SETUP :: "Stop Immediately" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Immediately,Stop when counter = 0,Do Not Stop"
        prop Label :: "Breakpoint Emulation Behavior "
        prop JSName :: "timerTcrFreeSoft"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.FREE_SOFT_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst IDLE_EN_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Stop all clocks in Timer during Peripheral Idle Mode "
        prop JSName :: "timerTcrIdleen"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.IDLE_EN_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst ARB_SETUP :: "Disabled" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Disabled,Enabled"
        prop Label :: "Auto Reload (ARB) "
        prop JSName :: "timerTcrArb"
        prop Visible :: 1
        prop Writable :: !(self.TIMER_man)
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (self.ARB_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst TIMER_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually "
        prop JSName :: "timerSetManually"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Advanced"
    }
    inst TCR_VALUE :: self.TCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Timer Control Register (TCR) "
        prop JSName :: "timerTcr"
        prop Visible :: 1
        prop Writable :: self.TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.TCR_VALUE = $1, self.TCR_SETUP_update($1), "ok")
    }
    inst PRD_VALUE :: self.PRD_SETUP { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Timer Period Register (PRD) "
        prop JSName :: "timerPrdAdv"
        prop Visible :: 1
        prop Writable :: self.TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.PRD_VALUE = $1, self.PRD_SETUP = $1, "ok")
    }
    inst PRSC_VALUE :: self.PRSC_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Timer Prescalar Register (PRSC) "
        prop JSName :: "timerPrsc"
        prop Visible :: 1
        prop Writable :: self.TIMER_man
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: 1
        prop cType :: "Uint16"
        prop Set :: (self.PRSC_VALUE = $1, self.PRSC_SETUP_update($1), "ok")
    }
}

type hTIMER {
    isa ObjectMgr
    prop name :: "hTIMER"
    prop Label :: "Timer Resource Manager"
    prop JSName :: "HTIMER"
    prop GlobalHelpTopic :: 1082
    prop InstanceHelpTopic :: 1083
    prop GlobalIcon :: 161
    prop InstanceIcon :: 162
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: TIMERFOLDER
    prop maxObjs :: (if (GBL.CHIPTYPE == "5510") {2} else {2})
    prop NoGen :: 1
    prop cGen :: 1
    prop cHandle :: self.cOpenGen
    prop cHeaderName :: if self.c55timer == 1 {"csl_timer.h"} else {""}
    prop cHandleType :: "TIMER_Handle"
    prop cOpenName :: "TIMER_open"
    prop cConfigName :: "TIMER_config"
    prop cHandleName :: self.handleName
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 2 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55timer :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x Timer opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst cOpenGen :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Handle to Timer "
        prop JSName :: "timerHandleEnable"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 1
        prop Set :: (if ((self.cOpenArg0 == "TIMER_DEV0") && (CLK.USETIMER == 1) && (CLK.TIMERNUM == 0)) {self.cOpenGen = 0, self.error("TIMER0 already used by the CLK module")} else {if ((self.cOpenArg0 == "TIMER_DEV1") && (CLK.USETIMER == 1) && (CLK.TIMERNUM == 1)) {self.cOpenGen = 0, self.error("TIMER1 already used by the CLK module")} else {self.cOpenGen = $1, if ($1 == 1) {self.c55timer = 1, "ok"} else {self.c55timer = 0, "ok"}}})
    }
    inst cOpenArg0 :: "TIMER_DEV0" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 0"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst cOpenArg1 :: "TIMER_OPEN_RESET" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Open Arg 1"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst handleName :: self { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Handle Name "
        prop JSName :: "timerHandleName"
        prop Visible :: 1
        prop Writable :: (self.cOpenGen)
        prop NoGen :: 1
        prop Set :: (self.handleName = $1, self.cConfigArg0 = $1, "ok")
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable pre-initialization "
        prop JSName :: "timerEnablePreInit"
        prop Visible :: 1
        prop Writable :: self.cOpenGen
        prop NoGen :: 1
        prop Set :: ($a = 0, scan ($b; timerCfg) {$a = 1}, if ($a == 0) {"You must create a configuration object"} else {self.PINIT_ENABLE = $1, "ok"})
    }
    inst cConfigGen :: = ((self.cOpenGen == 1) && (self.PINIT_ENABLE == 1) && (self.cConfigArg1 != TIMER_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
    }
    inst cConfigArg0 :: self.handleName { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0"
        prop Visible :: 0
    }
    inst cConfigArg1 :: TIMER_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: timerCfg
        prop Label :: "Pre-initialize "
        prop JSName :: "timerPreInit"
        prop Visible :: 1
        prop Writable :: self.PINIT_ENABLE == 1
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object TIMER_NOTHING :: timerCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param FUNC_SETUP :: "Internal(TOUT is Input)"
    param POLAR_SETUP :: "TIN/TOUT starts low"
    param PWID_SETUP :: "1 CLKOUT Period"
    param CP_SETUP :: "Pulse Mode"
    param TDDR_SETUP :: 0
    param PRD_SETUP :: 0
    param FREE_SOFT_SETUP :: "Stop Immediately"
    param IDLE_EN_SETUP :: 0
    param ARB_SETUP :: "Disabled"
    param TIMER_man :: 0
    param TCR_VALUE :: 16
    param PRD_VALUE :: 0
    param PRSC_VALUE :: 0
}

object TIMER0 :: hTIMER {
    param iComment :: "Timer 0"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hTIMER"
    param iDelMsg :: "Timer 0"
    param cOpenGen :: 0
    param cOpenArg0 :: "TIMER_DEV0"
    param cOpenArg1 :: "TIMER_OPEN_RESET"
    param handleName :: "hTimer0"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hTimer0"
    param cConfigArg1 :: TIMER_NOTHING
}

object TIMER1 :: hTIMER {
    param iComment :: "Timer 1"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hTIMER"
    param iDelMsg :: "Timer 1"
    param cOpenGen :: 0
    param cOpenArg0 :: "TIMER_DEV1"
    param cOpenArg1 :: "TIMER_OPEN_RESET"
    param handleName :: "hTimer1"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: "hTimer1"
    param cConfigArg1 :: TIMER_NOTHING
}

type USBFOLDER {
    prop Label :: "USB"
    prop GlobalIcon :: 191
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381C8}"
    prop GlobalHelpTopic :: 1200
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type endptObj {
    isa ObjectMgr
    prop name :: "USB"
    prop Label :: "USB Endpoint Configuration Manager"
    prop JSName :: "USB"
    prop GlobalHelpTopic :: 1201
    prop InstanceHelpTopic :: 1201
    prop IsContainedIn :: USBFOLDER
    prop GlobalIcon :: 191
    prop InstanceIcon :: 192
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: (GBL.CHIPTYPE == "5509")
    prop cStructType :: "USB_EpObj"
    prop cHeaderName :: if ((self.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {"csl_usb.h"} else {""}
    prop NoGen :: 1
    prop localCreate :: (self.MAX_PKTSIZE = self.MAX_PKTSIZE + 8, self.gPKTSIZE_LEFT = self.gPKTSIZE_LEFT - 64, self.PKTSIZE_LEFT = self.gPKTSIZE_LEFT, "ok")
    prop localDelete :: (self.MAX_PKTSIZE = self.MAX_PKTSIZE - self.PKTSIZE_VALUE, self.gPKTSIZE_LEFT = self.gPKTSIZE_LEFT + self.PKTSIZE_VALUE, "ok")
    prop maxObjs :: (if (self.gPKTSIZE_LEFT >= 8) {1000} else {self.gNumOf})
    prop pllInit_update :: (if (self.pllInit == "3 MHz") {"3"} else {if (self.pllInit == "6 MHz") {"6"} else {if (self.pllInit == "12 MHz") {"12"} else {if (self.pllInit == "24 MHz") {"24"} else {"48"}}}})
    prop NUM_VALUE_update :: (if (self.NUM_SETUP == "Endpoint 0 - OUT") {"USB_OUT_EP0"} else {if (self.NUM_SETUP == "Endpoint 1 - OUT") {"USB_OUT_EP1"} else {if (self.NUM_SETUP == "Endpoint 2 - OUT") {"USB_OUT_EP2"} else {if (self.NUM_SETUP == "Endpoint 3 - OUT") {"USB_OUT_EP3"} else {if (self.NUM_SETUP == "Endpoint 4 - OUT") {"USB_OUT_EP4"} else {if (self.NUM_SETUP == "Endpoint 5 - OUT") {"USB_OUT_EP5"} else {if (self.NUM_SETUP == "Endpoint 6 - OUT") {"USB_OUT_EP6"} else {if (self.NUM_SETUP == "Endpoint 7 - OUT") {"USB_OUT_EP7"} else {if (self.NUM_SETUP == "Endpoint 0 - IN") {"USB_IN_EP0"} else {if (self.NUM_SETUP == "Endpoint 1 - IN") {"USB_IN_EP1"} else {if (self.NUM_SETUP == "Endpoint 2 - IN") {"USB_IN_EP2"} else {if (self.NUM_SETUP == "Endpoint 3 - IN") {"USB_IN_EP3"} else {if (self.NUM_SETUP == "Endpoint 4 - IN") {"USB_IN_EP4"} else {if (self.NUM_SETUP == "Endpoint 5 - IN") {"USB_IN_EP5"} else {if (self.NUM_SETUP == "Endpoint 6 - IN") {"USB_IN_EP6"} else {"USB_IN_EP7"}}}}}}}}}}}}}}})
    prop TRANSFER_VALUE_update :: (if ((self.NUM_SETUP == "Endpoint 0 - OUT") || (self.NUM_SETUP == "Endpoint 0 - IN")) {"USB_CTRL"} else {if (self.TRANSFER_SETUP == "Bulk") {"USB_BULK"} else {if (self.TRANSFER_SETUP == "Interrupt") {"USB_INTR"} else {if (self.TRANSFER_SETUP == "Isochronous") {"USB_ISO"} else {"USB_HPORT"}}}})
    prop ENDPTADDR_VALUE_update :: (if (self.NUM_SETUP == "Endpoint 0 - OUT") {0x6782} else {if (self.NUM_SETUP == "Endpoint 1 - OUT") {0x6708} else {if (self.NUM_SETUP == "Endpoint 2 - OUT") {0x6710} else {if (self.NUM_SETUP == "Endpoint 3 - OUT") {0x6718} else {if (self.NUM_SETUP == "Endpoint 4 - OUT") {0x6720} else {if (self.NUM_SETUP == "Endpoint 5 - OUT") {0x6728} else {if (self.NUM_SETUP == "Endpoint 6 - OUT") {0x6730} else {if (self.NUM_SETUP == "Endpoint 7 - OUT") {0x6738} else {if (self.NUM_SETUP == "Endpoint 0 - IN") {0x6780} else {if (self.NUM_SETUP == "Endpoint 1 - IN") {0x6748} else {if (self.NUM_SETUP == "Endpoint 2 - IN") {0x6750} else {if (self.NUM_SETUP == "Endpoint 3 - IN") {0x6758} else {if (self.NUM_SETUP == "Endpoint 4 - IN") {0x6760} else {if (self.NUM_SETUP == "Endpoint 5 - IN") {0x6768} else {if (self.NUM_SETUP == "Endpoint 6 - IN") {0x6770} else {0x6778}}}}}}}}}}}}}}})
    prop DMAADDR_VALUE_update :: (if (self.NUM_SETUP == "Endpoint 0 - OUT") {0x6680} else {if (self.NUM_SETUP == "Endpoint 1 - OUT") {0x5808} else {if (self.NUM_SETUP == "Endpoint 2 - OUT") {0x5810} else {if (self.NUM_SETUP == "Endpoint 3 - OUT") {0x5818} else {if (self.NUM_SETUP == "Endpoint 4 - OUT") {0x5820} else {if (self.NUM_SETUP == "Endpoint 5 - OUT") {0x5828} else {if (self.NUM_SETUP == "Endpoint 6 - OUT") {0x5830} else {if (self.NUM_SETUP == "Endpoint 7 - OUT") {0x5838} else {if (self.NUM_SETUP == "Endpoint 0 - IN") {0x66C0} else {if (self.NUM_SETUP == "Endpoint 1 - IN") {0x5848} else {if (self.NUM_SETUP == "Endpoint 2 - IN") {0x5850} else {if (self.NUM_SETUP == "Endpoint 3 - IN") {0x5858} else {if (self.NUM_SETUP == "Endpoint 4 - IN") {0x5860} else {if (self.NUM_SETUP == "Endpoint 5 - IN") {0x5868} else {if (self.NUM_SETUP == "Endpoint 6 - IN") {0x5870} else {0x5878}}}}}}}}}}}}}}})
    prop externStr :: if (self.FXN_VALUE != "USB_EvISR_NONE") {"extern void "} else {""}
    prop fxnStr :: if (self.FXN_VALUE != "USB_EvISR_NONE") {self.FXN_VALUE} else {""}
    prop termStr :: if (self.FXN_VALUE != "USB_EvISR_NONE") {"();\n"} else {""}
    prop cGenCInst :: ("%1S%2S%3S\0, externStr,fxnStr,termStr")
    prop nameArray :: if (GBL.CHIPTYPE == "5509") {usbRes.CFGARRAY_NAME_VALUE} else {""}
    prop index :: if (GBL.CHIPTYPE == "5509") {"[_cslUsbIndex_++] = &"} else {""}
    prop array :: if (GBL.CHIPTYPE == "5509") {self} else {""}
    prop term :: if (GBL.CHIPTYPE == "5509") {";"} else {""}
    prop cGenFxnPreInst :: ("%5t%1s%2s%3s%4s\n%0t\0,nameArray,index,array,term")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gPKTSIZE_LEFT :: 3595 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Memory Available for Endpoint Packets "
        prop JSName :: "usbPktsizeLeft"
        prop Visible :: 1
        prop Writable :: 0
        prop NoGen :: 1
    }
    global genPsof :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Generate PreSOF Timer Value "
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
    }
    global psofTimer :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "PreSOF Interrupt Timer Value [0 - 255]: Time ~ 1.33usecs x "
        prop JSName :: "usbPsofTimer"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509") && (self.genPsof != 0)
        prop Set :: (if (($1 <= 255) && ($1 >= 0)) {self.psofTimer = $1, USB.cConfigArg2 = $1, "ok"} else {self.error("Value exceeds Limits")})
    }
    global pllInit :: "3 MHz" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "3 MHz,6 MHz,12 MHz,24 MHz,48 MHz"
        prop Label :: "USB PLL Input Clock Frequency "
        prop JSName :: "usbPllInit"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop Set :: (self.pllInit = $1, self.pllInit_VAL = self.pllInit_update(), "ok")
    }
    global pllInit_VAL :: "3" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "USB PLL Input Clock Frequency "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 0
        prop cStruct :: 0
        prop cType :: "Uint16"
        prop Set :: (self.pllInit_VAL = $1, "ok")
    }
    global INFO :: "USB requires 48 MHz. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MAX_PKTSIZE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Total Packet Size supported by USB "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop cType :: "Uint16"
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst NUM_SETUP :: "Endpoint 0 - OUT" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Endpoint 0 - OUT,Endpoint 1 - OUT,Endpoint 2 - OUT,Endpoint 3 - OUT,Endpoint 4 - OUT,Endpoint 5 - OUT,Endpoint 6 - OUT,Endpoint 7 - OUT,Endpoint 0 - IN,Endpoint 1 - IN,Endpoint 2 - IN,Endpoint 3 - IN,Endpoint 4 - IN,Endpoint 5 - IN,Endpoint 6 - IN,Endpoint 7 - IN"
        prop Label :: "Endpoint Number"
        prop JSName :: "usbEndpointNumber"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop Set :: (self.NUM_SETUP = $1, self.NUM_VALUE = self.NUM_VALUE_update(), self.DMAADDR_VALUE = self.DMAADDR_VALUE_update(), self.ENDPTADDR_VALUE = self.ENDPTADDR_VALUE_update(), self.TRANSFER_VALUE = self.TRANSFER_VALUE_update(), if (($1 == "Endpoint 0 - OUT") || ($1 == "Endpoint 0 - IN")) {self.PKTSIZE_COMBO_SETUP = 64, self.PKTSIZE_VALUE = self.PKTSIZE_COMBO_SETUP, self.MAX_PKTSIZE = self.MAX_PKTSIZE + self.PKTSIZE_COMBO_SETUP - self.LAST_PKTSIZE, self.gPKTSIZE_LEFT = 3595 - self.MAX_PKTSIZE, self.PKTSIZE_LEFT = self.gPKTSIZE_LEFT, self.LAST_PKTSIZE = self.PKTSIZE_VALUE} , if ((self.TRANSFER_SETUP == "Interrupt") && ((self.NUM_SETUP == "Endpoint 1 - OUT") || (self.NUM_SETUP == "Endpoint 2 - OUT") || (self.NUM_SETUP == "Endpoint 3 - OUT") || (self.NUM_SETUP == "Endpoint 4 - OUT") || (self.NUM_SETUP == "Endpoint 5 - OUT") || (self.NUM_SETUP == "Endpoint 6 - OUT") || (self.NUM_SETUP == "Endpoint 7 - OUT"))) {self.TRANSFER_SETUP = "Bulk"} , "ok")
    }
    inst TRANSFER_SETUP :: "Bulk" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Bulk,Interrupt,Isochronous,Host Port"
        prop Label :: "Transfer Type "
        prop JSName :: "usbTransferType"
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.NUM_SETUP != "Endpoint 0 - OUT") && (self.NUM_SETUP != "Endpoint 0 - IN"))
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop Set :: (self.TRANSFER_SETUP = $1, if ($1 == "Host Port") {self.PKTSIZE_COMBO_SETUP = 64, self.PKTSIZE_VALUE = self.PKTSIZE_COMBO_SETUP, self.MAX_PKTSIZE = self.MAX_PKTSIZE + self.PKTSIZE_COMBO_SETUP - self.LAST_PKTSIZE, self.gPKTSIZE_LEFT = 3595 - self.MAX_PKTSIZE, self.PKTSIZE_LEFT = self.gPKTSIZE_LEFT, self.LAST_PKTSIZE = self.PKTSIZE_VALUE} , if (($1 == "Interrupt") && ((self.NUM_SETUP == "Endpoint 1 - OUT") || (self.NUM_SETUP == "Endpoint 2 - OUT") || (self.NUM_SETUP == "Endpoint 3 - OUT") || (self.NUM_SETUP == "Endpoint 4 - OUT") || (self.NUM_SETUP == "Endpoint 5 - OUT") || (self.NUM_SETUP == "Endpoint 6 - OUT") || (self.NUM_SETUP == "Endpoint 7 - OUT"))) {self.TRANSFER_SETUP = "Bulk", self.error("Endpoints 1-7 OUT cannot have Interrupt transfer type")} else {self.TRANSFER_VALUE = self.TRANSFER_VALUE_update(), "ok"})
    }
    inst PKTSIZE_LEFT :: self.gPKTSIZE_LEFT { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Packet size available at instance level "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
    }
    inst PKTSIZE_COMBO_SETUP :: 64 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "8,16,32,64"
        prop Label :: "Maximum Packet Size "
        prop JSName :: "usbPktsize"
        prop Visible :: 1
        prop Writable :: ((self.TRANSFER_SETUP != "Isochronous") && (GBL.CHIPTYPE == "5509") && (self.NUM_SETUP != "Endpoint 0 - OUT") && (self.NUM_SETUP != "Endpoint 0 - IN") && (self.TRANSFER_SETUP != "Host Port"))
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop Set :: (if ($1 <= (self.gPKTSIZE_LEFT + self.LAST_PKTSIZE)) {self.PKTSIZE_COMBO_SETUP = $1, self.PKTSIZE_VALUE = self.PKTSIZE_COMBO_SETUP, self.MAX_PKTSIZE = self.MAX_PKTSIZE + self.PKTSIZE_COMBO_SETUP - self.LAST_PKTSIZE, self.gPKTSIZE_LEFT = 3595 - self.MAX_PKTSIZE, self.PKTSIZE_LEFT = self.gPKTSIZE_LEFT, self.LAST_PKTSIZE = self.PKTSIZE_VALUE, "ok"} else {self.error("Total packet size supported by USB exceeded")})
    }
    inst PKTSIZE_SETUP :: 1 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Maximum Packet Size for Isochronous transfer "
        prop JSName :: "usbPktsizeIso"
        prop Visible :: 1
        prop Writable :: (self.TRANSFER_SETUP == "Isochronous") && (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop Set :: (if (($1 >= 1) && ($1 <= 1023)) {if ($1 <= (self.gPKTSIZE_LEFT + self.LAST_PKTSIZE)) {self.PKTSIZE_SETUP = $1, self.PKTSIZE_VALUE = self.PKTSIZE_SETUP, self.MAX_PKTSIZE = self.MAX_PKTSIZE + self.PKTSIZE_SETUP - self.LAST_PKTSIZE, self.gPKTSIZE_LEFT = 3595 - self.MAX_PKTSIZE, self.PKTSIZE_LEFT = self.gPKTSIZE_LEFT, self.LAST_PKTSIZE = self.PKTSIZE_VALUE, "ok"} else {self.error("Total packet size supported by USB exceeded ")}} else {self.error("Invalid packet size. (Valid Range: 1 - 1023) ")})
    }
    inst FXN_SETUP :: "USB_EvISR_NONE" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "User Interrupt Handle Function "
        prop JSName :: "usbInterruptFxn"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop Set :: (self.FXN_SETUP = $1, self.FXN_VALUE = self.FXN_SETUP, "ok")
    }
    inst NOTE :: "The User Interrupt Handle Function is called only if one or more USB events are selected from USB Events tab. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Endpoints Setting"
        prop NoGen :: 1
    }
    inst NOTE1 :: "For ENDPOINT 0, Transfer type is always Control, and Maximum Packet Size is always 64. " { 
        prop Type :: "{0C355120-70B4-11d1-B3DD-0020AFEAE00F}"
        prop Visible :: 1
        prop Writable :: 0
        prop TabName :: "Endpoints Setting"
        prop NoGen :: 1
    }
    inst MASK :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Mask Value "
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop TabName :: "USB Events"
    }
    inst RESET_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Reset Request (RSTR) "
        prop JSName :: "usbEventReset"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "USB Events"
        prop Set :: (self.RESET_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x0001, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFFE, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst SUSPEND_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Suspend Request (SUSR) "
        prop JSName :: "usbEventSuspend"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.SUSPEND_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x0004, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFFB, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst RESUME_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Resume Request (RESR) "
        prop JSName :: "usbEventResume"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.RESUME_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x0008, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFF7, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst SOF_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Start Of Frame (SOF) "
        prop JSName :: "usbEventSof"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.SOF_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x0002, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFFD, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst SETUP_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Setup Packet Receive (SETUP) "
        prop JSName :: "usbEventSetup"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.SETUP_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00010, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFEF, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst EOT_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "End of Posted Transfer (EOT) "
        prop JSName :: "usbEventEot"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.EOT_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00020, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFDF, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst STPOW_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Setup Packet Overwrite (STPOW) "
        prop JSName :: "usbEventStpow"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.STPOW_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00040, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFFBF, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst PSOF_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pre-Start Of Frame (PSOF) "
        prop JSName :: "usbEventPsof"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.PSOF_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00080, self.MASK = self.EVENTMASK_VALUE, self.genPsof += 1, "ok"} else {self.EVENTMASK_VALUE &= 0xFF7F, self.MASK = self.EVENTMASK_VALUE, self.genPsof -= 1, if (self.genPsof == 0) {self.psofTimer = 0} , "ok"})
    }
    inst HINT_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Host Interrupt (HINT) "
        prop JSName :: "usbEventHint"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.HINT_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00100, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFEFF, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst HERR_SETUP :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Host Error (HERR) "
        prop JSName :: "usbEventHerr"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop TabName :: "USB Events"
        prop Set :: (self.HERR_SETUP = $1, if ($1 == 1) {self.EVENTMASK_VALUE |= 0x00200, self.MASK = self.EVENTMASK_VALUE, "ok"} else {self.EVENTMASK_VALUE &= 0xFDFF, self.MASK = self.EVENTMASK_VALUE, "ok"})
    }
    inst NUM_VALUE :: self.NUM_VALUE_update() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Endpoint Number "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
        prop Set :: (self.NUM_VALUE = $1, "ok")
    }
    inst TRANSFER_VALUE :: self.TRANSFER_VALUE_update() { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Transfer type value "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
        prop Set :: (self.TRANSFER_VALUE = $1, "ok")
    }
    inst PKTSIZE_VALUE :: 64 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Maximum Packet Size Supported by EP "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
        prop Set :: (self.PKTSIZE_VALUE = $1, "ok")
    }
    inst LAST_PKTSIZE :: 8 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Last Packet Size value selected by user "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop cGen :: 0
        prop cType :: "Uint16"
    }
    inst EVENTMASK_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Event Mask "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst FXN_VALUE :: self.FXN_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to USB event ISR "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Endpoints Setting"
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
        prop Set :: (self.FXN_VALUE = $1, "ok")
    }
    inst FLAGS_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Data Flags "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst STATUS_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Status "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst ENDPTADDR_VALUE :: self.ENDPTADDR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Endpoint descriptor reg block start addr "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst DMAADDR_VALUE :: self.DMAADDR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "DMA reg block start addr "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst TOTBYTCNT_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Total byte count "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst BYTINTHISSEG_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Number of bytes in the active node of the linked list "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst XFERBYTCNT_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to store the number of bytes moved in (out) "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst PBUFFER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Active data buffer pointer "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst PNEXTBUFFER_VALUE :: "NULL" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Pointer to NEXT Buffer "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
    inst EVENTFLAG_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "Event Flag "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 1
        prop cStruct :: 1
        prop cType :: "Uint16"
    }
}

type usbRes {
    isa ObjectMgr
    prop name :: "USBRes"
    prop Label :: "USB Resource Manager"
    prop JSName :: "USBRES"
    prop GlobalHelpTopic :: 1202
    prop InstanceHelpTopic :: 1203
    prop GlobalIcon :: 191
    prop InstanceIcon :: 192
    prop GlobalPropertyPage :: "{1C8F8861-E550-11d4-9745-00B0D0524DFE}"
    prop InstancePropertyPage :: "{1C8F8862-E550-11d4-9745-00B0D0524DFE}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: USBFOLDER
    prop maxObjs :: (1)
    prop cHeaderName :: if ((usbRes.c55usb == 1) && (GBL.CHIPTYPE == "5509")) {"csl_usb.h"} else {""}
    prop NoGen :: 1
    prop cGen :: 1
    prop cConfigName :: "USB_init"
    prop epStr :: if ((endptObj.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {"\nUSB_EpObj* "} else {""}
    prop cfgArrayStr :: if ((endptObj.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {usbRes.CFGARRAY_NAME_VALUE} else {""}
    prop range :: if ((endptObj.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {"[N+1]"} else {""}
    prop trmStr :: if ((endptObj.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {";\n"} else {""}
    prop decl :: if ((endptObj.gNumOf > 0) && (GBL.CHIPTYPE == "5509")) {"\nstatic int _cslUsbIndex_ = 0;\n"} else {""}
    prop cGenCInst :: ("%1S%2S%3S%4S%5S\0, epStr,cfgArrayStr,range,trmStr,decl")
    prop defStr :: if (GBL.CHIPTYPE == "5509") {"#define N     %2d"} else {""}
    prop nrCfg :: if (GBL.CHIPTYPE == "5509") {endptObj.gNumOf} else {""}
    prop cGenCPrologue :: (if ((GBL.CHIPTYPE == "5509") && (endptObj.gNumOf > 0)) {"%1S\n\n\0, defStr,nrCfg"} else {""})
    prop arr :: if ((usbRes.c55usb) && (GBL.CHIPTYPE == "5509")) {usbRes.CFGARRAY_NAME_VALUE} else {" "}
    prop idx :: if ((usbRes.c55usb) && (GBL.CHIPTYPE == "5509")) {"[_cslUsbIndex_] = NULL; "} else {" "}
    prop funcStr :: if ((usbRes.c55usb) && (GBL.CHIPTYPE == "5509")) {"\n\nUSB_setAPIVectorAddress();\n"} else {" "}
    prop pllStr :: if ((usbRes.c55usb) && (GBL.CHIPTYPE == "5509")) {"USB_initPLL(%5S, 48, 0);\n"} else {" "}
    prop pllInitStr :: if ((usbRes.c55usb) && (GBL.CHIPTYPE == "5509")) {endptObj.pllInit_VAL} else {" "}
    prop cGenFxnPreInst :: ("%5t%1s%2s%3S%4S\n%0t\0,arr,idx,funcStr,pllStr,pllInitStr")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55usb :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x USB configured "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    global CFGARRAY_NAME_VALUE :: "cfgArray" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst USB_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable USB Configuration "
        prop JSName :: "usbCfgEnable"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop Set :: (self.USB_ENABLE = $1, if ($1 == 1) {self.c55usb = 1} else {self.c55usb = 0}, "ok")
    }
    inst cConfigGen :: = (self.USB_ENABLE == 1) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    inst CFGARRAY_SETUP :: "cfgArray" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Name of configuration array "
        prop JSName :: "usbCfgName"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop cGen :: 0
        prop TabName :: "General"
        prop Set :: (self.CFGARRAY_SETUP = $1, self.cConfigArg1 = $1, usbRes.CFGARRAY_NAME_VALUE = $1, "ok")
    }
    inst cConfigArg0 :: "USB0" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 0 "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
    }
    inst cConfigArg1 :: self.CFGARRAY_SETUP { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Config argument 1 "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
    }
    inst cConfigArg2 :: endptObj.psofTimer { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "Config argument 3 "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
    }
}

object USB0 :: usbRes {
    param iComment :: "USB "
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "usbRes"
    param iDelMsg :: "USB "
    param USB_ENABLE :: 0
    param CFGARRAY_SETUP :: "cfgArray"
    param cConfigArg0 :: "USB0"
    param cConfigArg1 :: "cfgArray"
    param cConfigArg2 :: 0
}

type WDTIMERFOLDER {
    prop Label :: "WDTIMER - Watchdog Timer Device"
    prop GlobalIcon :: 193
    prop GlobalPropertyPage :: "{B916FB95-52A5-11d4-967C-0750048381B7}"
    prop GlobalHelpTopic :: 1300
    prop IsContainedIn :: CSL
    prop NoGen :: 1
}

type wdtimCfg {
    isa ObjectMgr
    prop name :: "WDTIM"
    prop Label :: "Watchdog Timer Configuration Manager"
    prop JSName :: "WDTIM"
    prop GlobalHelpTopic :: 1301
    prop InstanceHelpTopic :: 1301
    prop IsContainedIn :: WDTIMERFOLDER
    prop GlobalIcon :: 193
    prop InstanceIcon :: 194
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop cGen :: 1
    prop cStruct :: (GBL.CHIPTYPE == "5509")
    prop cStructType :: "WDTIM_Config"
    prop cHeaderName :: if self.gNumOf > 0 {"csl_wdtim.h"} else {""}
    prop NoGen :: 1
    prop TDDR_TCR :: (self.TDDR_SETUP)
    prop FREE_SOFT_TCR :: (if (self.FREE_SOFT_SETUP == "Stop when counter = 0") {0x0800} else {if (self.FREE_SOFT_SETUP == "Stop Immediately") {0x0000} else {0x0400}})
    prop TCR_VALUE_update :: (self.TDDR_TCR | self.FREE_SOFT_TCR)
    prop TCR_SETUP_update :: (self.FREE_SOFT_SETUP = ($a = ($1 & 0x0C00), if ($a == 0x0000) {"Stop Immediately"} else {if ($a == 0x0800) {"Stop when counter = 0"} else {"Do Not Stop"}}), self.TDDR_SETUP = ($1 & 0x000f))
    prop PRD_VALUE_update :: (self.PRD_SETUP)
    prop PRD_SETUP_update :: (self.PRD_SETUP = self.PRD_VALUE)
    prop PREMD_TCR2 :: (if (self.PREMD_SETUP == "Indirect Mode") {0x1000} else {0x0000})
    prop TCR2_VALUE_update :: (self.PREMD_TCR2)
    prop PRESC_SETUP_update :: (self.PRESC_SETUP = (if ($1 == 0x0000) {0x0001} else {if ($1 == 0x0001) {0x0003} else {if ($1 == 0x0002) {0x0007} else {if ($1 == 0x0003) {0x000F} else {if ($1 == 0x0004) {0x001F} else {if ($1 == 0x0005) {0x003F} else {if ($1 == 0x0006) {0x007F} else {if ($1 == 0x0007) {0x00FF} else {if ($1 == 0x0008) {0x01FF} else {if ($1 == 0x0009) {0x03FF} else {if ($1 == 0x000A) {0x07FF} else {if ($1 == 0x000B) {0x0FFF} else {if ($1 == 0x000C) {0x1FFF} else {if ($1 == 0x000D) {0x3FFF} else {if ($1 == 0x000E) {0x7FFF} else {0xFFFF}}}}}}}}}}}}}}}))
    prop TDDR_SETUP_update :: (self.TDDR_SETUP = (if ($1 == 0x0001) {0x0000} else {if ($1 == 0x0003) {0x0001} else {if ($1 == 0x0007) {0x0002} else {if ($1 == 0x000F) {0x0003} else {if ($1 == 0x001F) {0x0004} else {if ($1 == 0x003F) {0x0005} else {if ($1 == 0x007F) {0x0006} else {if ($1 == 0x00FF) {0x0007} else {if ($1 == 0x01FF) {0x0008} else {if ($1 == 0x03FF) {0x0009} else {if ($1 == 0x07FF) {0x000A} else {if ($1 == 0x0FFF) {0x000B} else {if ($1 == 0x1FFF) {0x000C} else {if ($1 == 0x3FFF) {0x000D} else {if ($1 == 0x7FFF) {0x000E} else {0x000F}}}}}}}}}}}}}}}))
    prop TCR2_SETUP_update :: (self.PREMD_SETUP = if ($1 & 0x1000) {"Indirect Mode"} else {"Direct Mode"})
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst TDDR_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Timer Divide-Down Ratio (TDDR) "
        prop Visible :: 1
        prop JSName :: "wdtimTcrTddrSetup"
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.PREMD_SETUP == "Direct Mode"))
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (if (($1 >= 0) && ($1 < 16)) {self.TDDR_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok"} else {"Number Out of Bounds"})
    }
    inst FREE_SOFT_SETUP :: "Stop Immediately" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Stop Immediately,Stop when counter = 0,Do Not Stop"
        prop Label :: "Breakpt. Emulation Behavior "
        prop JSName :: "wdtimTcrFreeSoftSetup"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "General"
        prop Set :: (self.FREE_SOFT_SETUP = $1, self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst PRD_SETUP :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Period Value "
        prop JSName :: "wdtimPrdSetup"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (if (($1 >= 0) && ($1 < 65536)) {self.PRD_SETUP = $1, self.PRD_VALUE = self.PRD_VALUE_update(), "ok"} else {"Value out of Bounds"})
    }
    inst PREMD_SETUP :: "Direct Mode" { 
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Direct Mode,Indirect Mode"
        prop Label :: "Prescalar Mode "
        prop JSName :: "wdtimTcr2PremdSetup"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (self.PREMD_SETUP = $1, self.TCR2_VALUE = self.TCR2_VALUE_update(), "ok")
    }
    inst PRESC_SETUP :: 0x0001 { 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,0x01FF,0x03FF,0x07FF,0x0FFF,0x1FFF,0x3FFF,0x7FFF,0xFFFF"
        prop JSName :: "wdtimTcrPrescSetup"
        prop Label :: "Prescalar Value "
        prop Visible :: 1
        prop Writable :: ((GBL.CHIPTYPE == "5509") && (self.PREMD_SETUP == "Indirect Mode"))
        prop NoGen :: 1
        prop TabName :: "Counter Control"
        prop Set :: (self.PRESC_SETUP = $1, self.TDDR_SETUP_update($1), self.TCR_VALUE = self.TCR_VALUE_update(), "ok")
    }
    inst TIMER_man :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Set Manually "
        prop Visible :: 0
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Advanced"
    }
    inst PRD_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "WD Timer Period Register (WDPRD)"
        prop JSName :: "wdtimWdprdAdv"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (GBL.CHIPTYPE == "5509")
        prop cType :: "Uint16"
        prop Set :: (self.PRD_VALUE = $1, self.PRD_SETUP_update($1), "ok")
    }
    inst TCR_VALUE :: self.TCR_VALUE_update() { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "WD Timer Control Register (WDTCR)"
        prop JSName :: "wdtimWdtcrAdv"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (GBL.CHIPTYPE == "5509")
        prop cType :: "Uint16"
        prop Set :: (self.TCR_VALUE = ($1 & 0x0FFF), self.TCR_SETUP_update($1), "ok")
    }
    inst TCR2_VALUE :: 0 { 
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Label :: "WD Timer Secondary Control Register (WDTCR2) "
        prop JSName :: "wdtimWdtcr2Adv"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop TabName :: "Advanced"
        prop cGen :: (GBL.CHIPTYPE == "5509")
        prop cType :: "Uint16"
        prop Set :: (self.TCR2_VALUE = ($1 & 0x1000), self.TCR2_SETUP_update($1), "ok")
    }
}

type hWDTIM {
    isa ObjectMgr
    prop name :: "hWDTIM"
    prop Label :: "Watchdog Timer Resource Manager"
    prop JSName :: "HWDTIM"
    prop GlobalHelpTopic :: 1302
    prop InstanceHelpTopic :: 1303
    prop GlobalIcon :: 193
    prop InstanceIcon :: 194
    prop GlobalPropertyPage :: "{C5CB30B4-F113-11d2-84A5-10105A98CA0B}"
    prop InstancePropertyPage :: "{AC0C36D1-890B-11d0-A621-1000C070F3E9}"
    prop Vendor :: "vendor1"
    prop Version :: "1.00.00"
    prop IsContainedIn :: WDTIMERFOLDER
    prop maxObjs :: (if (GBL.CHIPTYPE == "5509") {1} else {0})
    prop NoGen :: 1
    prop cGen :: (GBL.CHIPTYPE == "5509")
    prop cHeaderName :: if self.c55wdtimer == 1 {"csl_wdtim.h"} else {""}
    prop cConfigName :: "WDTIM_config"
    prop comment :: if (GBL.CHIPTYPE == "5509") {"/* You must use WDTIM_start() in your main code to start the WDTIM. */"} else {""}
    prop cGenFxnEpilogue :: ("%5t\n%1s\n\n%0t\0,comment")
    global gUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gSetOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumOf :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gDirty :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInitFlag :: 1 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gInit :: = ($a = 0, $b = 0, scan ($i; self) {if ($i.IsConfObj()) {$a += 1, if (self.isFinite) {$b |= 1 << $i.iId} } }, self.gNumOf = $a, self.gSetOf = $b, if (self.gInitFlag == 0) {self.localInit()} , self.gInitFlag = 1) { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global c55wdtimer :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "C55x Watchdog Timer opened "
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
        prop cGen :: 0
    }
    inst iComment :: if self.iDelUser == "USER" {"<add comments here>"} else {self.iDelMsg} { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "comment"
        prop JSName :: "comment"
        prop Visible :: 1
        prop Writable :: if self.iDelUser == "USER" {1} else {0}
        prop NoGen :: 1
    }
    inst iIsUsed :: 0 { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iId :: 0 { 
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iDelUser :: "USER" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst iDelMsg :: "ok" { 
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst PINIT_ENABLE :: 0 { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Configuration of Watchdog Timer "
        prop JSName :: "wdtimEnablePreInit"
        prop Visible :: 1
        prop Writable :: (GBL.CHIPTYPE == "5509")
        prop NoGen :: 1
        prop Set :: (self.PINIT_ENABLE = $1, if ($1 == 1) {self.c55wdtimer = 1} else {self.c55wdtimer = 0}, "ok")
    }
    inst cConfigGen :: = ((self.PINIT_ENABLE == 1) && (self.cConfigArg0 != WDTIM_NOTHING)) { 
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
    }
    inst cConfigArg0 :: WDTIM_NOTHING { 
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: wdtimCfg
        prop Label :: "Pre-initialize"
        prop JSName :: "wdtimPreInit"
        prop Visible :: 1
        prop Writable :: (self.PINIT_ENABLE) && (GBL.CHIPTYPE == "5509")
        prop NoGen :: 0
        prop cPreVal :: "&"
    }
}

object WDTIM_NOTHING :: wdtimCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 0
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param TDDR_SETUP :: 0
    param FREE_SOFT_SETUP :: "Stop Immediately"
    param PRD_SETUP :: 0
    param PREMD_SETUP :: "Direct Mode"
    param PRESC_SETUP :: 1
    param TIMER_man :: 0
    param PRD_VALUE :: 0
    param TCR_VALUE :: 0
    param TCR2_VALUE :: 0
}

object WDTim0 :: hWDTIM {
    param iComment :: "Watchdog Timer"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "hWDTIM"
    param iDelMsg :: "Watchdog Timer"
    param PINIT_ENABLE :: 0
    param cConfigArg0 :: WDTIM_NOTHING
}

object SARAM_A :: MEM {
    param iComment :: "32K block to insure next 64K block is aligned on 64K boundary"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 32768
    param len :: 32768
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object SARAM_B :: MEM {
    param iComment :: "32K block to finish allocating balance of internal memory"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 131072
    param len :: 32768
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object SDRAM :: MEM {
    param iComment :: "Synch DRAM MT48LC2M32B2-7, CE0 space limits size to 2M words"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 163840
    param len :: 1933312
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object FLASH :: MEM {
    param iComment :: "Flash Re-programable EEPROM 29LV400"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param base :: 2097152
    param len :: 262144
    param iAllocHeap :: 0
    param iHeapSize :: 16256
    param iUserHeapId :: 0
    param iHeapId :: @segment_name
    param iReqHeapCount :: 0
    param space :: "code/data"
    param iIsModifiable :: 1
}

object emifCfg0 :: emifCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param CE0_MTYPE_SETUP :: "32-bit wide SDRAM"
    param CE0_RDSET_SETUP :: 15
    param CE0_WRSET_SETUP :: 15
    param CE0_RDSTROBE_SETUP :: 63
    param CE0_WRSTROBE_SETUP :: 63
    param CE0_RDHOLD_SETUP :: 3
    param CE0_WRHOLD_SETUP :: 3
    param CE0_EXRDHOLD_SETUP :: 1
    param CE0_EXWRHOLD_SETUP :: 1
    param CE0_TIMEOUT_SETUP :: 0
    param CE1_MTYPE_SETUP :: "16-bit wide Asynchronous"
    param CE1_RDSET_SETUP :: 0
    param CE1_WRSET_SETUP :: 0
    param CE1_RDSTROBE_SETUP :: 14
    param CE1_WRSTROBE_SETUP :: 14
    param CE1_RDHOLD_SETUP :: 0
    param CE1_WRHOLD_SETUP :: 0
    param CE1_EXRDHOLD_SETUP :: 0
    param CE1_EXWRHOLD_SETUP :: 0
    param CE1_TIMEOUT_SETUP :: 0
    param CE2_MTYPE_SETUP :: "16-bit wide Asynchronous"
    param CE2_RDSET_SETUP :: 0
    param CE2_WRSET_SETUP :: 0
    param CE2_RDSTROBE_SETUP :: 20
    param CE2_WRSTROBE_SETUP :: 20
    param CE2_RDHOLD_SETUP :: 0
    param CE2_WRHOLD_SETUP :: 0
    param CE2_EXRDHOLD_SETUP :: 0
    param CE2_EXWRHOLD_SETUP :: 0
    param CE2_TIMEOUT_SETUP :: 0
    param CE3_MTYPE_SETUP :: "16-bit wide Asynchronous"
    param CE3_RDSET_SETUP :: 0
    param CE3_WRSET_SETUP :: 0
    param CE3_RDSTROBE_SETUP :: 20
    param CE3_WRSTROBE_SETUP :: 20
    param CE3_RDHOLD_SETUP :: 0
    param CE3_WRHOLD_SETUP :: 0
    param CE3_EXRDHOLD_SETUP :: 0
    param CE3_EXWRHOLD_SETUP :: 0
    param CE3_TIMEOUT_SETUP :: 0
    param RESET_SETUP :: 1
    param MEMCEN_SETUP :: "CLKMEM Enabled to Clock"
    param MEMFREQ_SETUP :: "CLKMEM = DSP Clock / 2"
    param NOHOLD_SETUP :: "Hold Disabled"
    param WPE_SETUP :: "Disabled"
    param SDINIT_SETUP :: 1
    param SDACC_SETUP :: "32-bits wide (D[31:0])"
    param SDSIZE_SETUP :: "64Mbit"
    param SDWID_SETUP :: "32-bits"
    param RFEN_SETUP :: "Enabled"
    param SDPERIOD_SETUP :: 1400
    param TRP_SETUP :: 1
    param TRC_SETUP :: 5
    param TRCD_SETUP :: 1
    param TRAS_SETUP :: 3
    param TMRD_SETUP :: 1
    param TACTV_SETUP :: 5
    param EMIF_man :: 0
    param GCR_VALUE :: 545
    param GRR_VALUE :: 65535
    param CE0_SCR1_VALUE :: 16383
    param CE0_SCR2_VALUE :: 24575
    param CE0_SCR3_VALUE :: 0
    param CE1_SCR1_VALUE :: 4152
    param CE1_SCR2_VALUE :: 56
    param CE1_SCR3_VALUE :: 0
    param CE2_SCR1_VALUE :: 4176
    param CE2_SCR2_VALUE :: 80
    param CE2_SCR3_VALUE :: 0
    param CE3_SCR1_VALUE :: 4176
    param CE3_SCR2_VALUE :: 80
    param CE3_SCR3_VALUE :: 0
    param SDCR1_VALUE :: 11025
    param SDPERIOD_VALUE :: 1400
    param SDINIT_VALUE :: 65535
    param SDCR2_VALUE :: 1333
}

object mcbspCfg1 :: mcbspCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 0
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param IDLE_EN_SETUP :: 0
    param XIOEN_SETUP :: 1
    param XIOEN2_SETUP :: 1
    param CLKXM1_SETUP :: "Internal"
    param CLKXM2_SETUP :: "Master"
    param CLKXP_SETUP :: "Falling Edge"
    param FSXP_SETUP :: "Active Low"
    param DXENA_SETUP :: "Disable"
    param XDATDLY_SETUP :: "0-bit"
    param XPHASE_SETUP :: "Single-phase"
    param XWDLEN1_SETUP :: "16-bits"
    param XWDLEN2_SETUP :: "8-bits"
    param XFRLEN1_SETUP :: 1
    param XFRLEN2_SETUP :: 1
    param XSYNCERR_SETUP :: "Disable"
    param XINTM_SETUP :: "XRDY"
    param FSXM_SETUP :: "Sample Rate Gen"
    param XFIG_SETUP :: "Restart Transfer"
    param XCOMPAND_SETUP :: "No Companding-MSB First"
    param FSXM_FSGM_SETUP :: "DXR[1/2]-to-XSR[1/2] Copy"
    param RIOEN_SETUP :: 0
    param RIOEN2_SETUP :: 0
    param CLKRM1_SETUP :: "External"
    param CLKRM2_SETUP :: "CLKX Driven"
    param CLKRP_SETUP :: "Falling Edge"
    param FSRP_SETUP :: "Active High"
    param RDATDLY_SETUP :: "0-bit"
    param RPHASE_SETUP :: "Single-phase"
    param RWDLEN1_SETUP :: "8-bits"
    param RWDLEN2_SETUP :: "8-bits"
    param RFRLEN1_SETUP :: 1
    param RFRLEN2_SETUP :: 1
    param RSYNCERR_SETUP :: "Disable"
    param RINTM_SETUP :: "RRDY"
    param FSRM_SETUP :: "External"
    param RFIG_SETUP :: "Restart Transfer"
    param RJUST_SETUP :: "Right-justify/zero-fill"
    param RCOMPAND_SETUP :: "No Companding-MSB First"
    param FREE_SOFT_SETUP :: "Stop After Current Word"
    param CLKSTP_SETUP :: "Falling Edge w/o Delay"
    param DLB_SETUP :: "Disable"
    param ABIS_SETUP :: "Disable"
    param GRST_SETUP :: 1
    param CLKSM_SETUP :: "CPU Clock"
    param SCLKME_SETUP :: "CLKS Pin"
    param GSYNC_SETUP :: "Disable"
    param CLKSP_SETUP :: "Rising Edge of CLKS"
    param FSGM_SETUP :: "Disable"
    param FWID_SETUP :: 1
    param CLKGDV_SETUP :: 100
    param FPER_SETUP :: 20
    param CLKX_IO :: "Input"
    param FSX_IO :: "Input"
    param CLKR_IO :: "Input"
    param FSR_IO :: "Input"
    param EN_DX :: "Output"
    param EN_DR :: "Input"
    param EN_CLKS :: "Input"
    param MCBSP_man :: 0
    param SPCR1_VALUE :: 4096
    param SPCR2_VALUE :: 256
    param RCR1_VALUE :: 0
    param RCR2_VALUE :: 0
    param XCR1_VALUE :: 64
    param XCR2_VALUE :: 0
    param SRGR1_VALUE :: 99
    param SRGR2_VALUE :: 8211
    param MCR1_VALUE :: 0
    param MCR2_VALUE :: 0
    param PCR_VALUE :: 6666
    param RMCM_RMCME_SETUP :: "All 128 Channels"
    param RPABLK_SETUP :: "Block 0. Channel 0-15"
    param RPBBLK_SETUP :: "Block 1. Channel 16-31"
    param RCERA_VALUE :: 0
    param RCERB_VALUE :: 0
    param RCERC_VALUE :: 0
    param RCERD_VALUE :: 0
    param RCERE_VALUE :: 0
    param RCERF_VALUE :: 0
    param RCERG_VALUE :: 0
    param RCERH_VALUE :: 0
    param XMCM_XMCME_SETUP :: "All 128 Channels"
    param XPABLK_SETUP :: "Block 0. Channel 0-15"
    param XPBBLK_SETUP :: "Block 1. Channel 16-31"
    param XCERA_VALUE :: 0
    param XCERB_VALUE :: 0
    param XCERC_VALUE :: 0
    param XCERD_VALUE :: 0
    param XCERE_VALUE :: 0
    param XCERF_VALUE :: 0
    param XCERG_VALUE :: 0
    param XCERH_VALUE :: 0
    param XMCM_01 :: "DXR written for enabled/unmasked channels,DX driven for enabled/unmasked channels"
    param XMCM_10 :: "DXR written for all channels in block,DX driven for unmasked channels"
    param ABIS_RCERA_VALUE :: 0
    param ABIS_RCERB_VALUE :: 0
    param ABIS_XCERA_VALUE :: 0
    param ABIS_XCERB_VALUE :: 0
    param RCERA :: 0
    param RCERB :: 0
    param RCERC :: 0
    param RCERD :: 0
    param RCERE :: 0
    param RCERF :: 0
    param RCERG :: 0
    param RCERH :: 0
    param XCERA :: 0
    param XCERB :: 0
    param XCERC :: 0
    param XCERD :: 0
    param XCERE :: 0
    param XCERF :: 0
    param XCERG :: 0
    param XCERH :: 0
}

object mcbspCfg2 :: mcbspCfg {
    param iComment :: "<add comments here>"
    param iIsUsed :: 1
    param iId :: 1
    param iDelUser :: "USER"
    param iDelMsg :: "ok"
    param IDLE_EN_SETUP :: 0
    param XIOEN_SETUP :: 1
    param XIOEN2_SETUP :: 1
    param CLKXM1_SETUP :: "External"
    param CLKXM2_SETUP :: "Slave"
    param CLKXP_SETUP :: "Falling Edge"
    param FSXP_SETUP :: "Active High"
    param DXENA_SETUP :: "Disable"
    param XDATDLY_SETUP :: "0-bit"
    param XPHASE_SETUP :: "Single-phase"
    param XWDLEN1_SETUP :: "16-bits"
    param XWDLEN2_SETUP :: "8-bits"
    param XFRLEN1_SETUP :: 2
    param XFRLEN2_SETUP :: 1
    param XSYNCERR_SETUP :: "Disable"
    param XINTM_SETUP :: "XRDY"
    param FSXM_SETUP :: "External"
    param XFIG_SETUP :: "Restart Transfer"
    param XCOMPAND_SETUP :: "No Companding-MSB First"
    param FSXM_FSGM_SETUP :: "External"
    param RIOEN_SETUP :: 1
    param RIOEN2_SETUP :: 1
    param CLKRM1_SETUP :: "External"
    param CLKRM2_SETUP :: "CLKX Driven"
    param CLKRP_SETUP :: "Rising Edge"
    param FSRP_SETUP :: "Active High"
    param RDATDLY_SETUP :: "0-bit"
    param RPHASE_SETUP :: "Single-phase"
    param RWDLEN1_SETUP :: "16-bits"
    param RWDLEN2_SETUP :: "8-bits"
    param RFRLEN1_SETUP :: 2
    param RFRLEN2_SETUP :: 1
    param RSYNCERR_SETUP :: "Disable"
    param RINTM_SETUP :: "RRDY"
    param FSRM_SETUP :: "External"
    param RFIG_SETUP :: "Restart Transfer"
    param RJUST_SETUP :: "Right-justify/zero-fill"
    param RCOMPAND_SETUP :: "No Companding-MSB First"
    param FREE_SOFT_SETUP :: "Stop After Current Word"
    param CLKSTP_SETUP :: "Disable"
    param DLB_SETUP :: "Disable"
    param ABIS_SETUP :: "Disable"
    param GRST_SETUP :: 1
    param CLKSM_SETUP :: "CLKS Pin"
    param SCLKME_SETUP :: "CLKS Pin"
    param GSYNC_SETUP :: "Disable"
    param CLKSP_SETUP :: "Rising Edge of CLKS"
    param FSGM_SETUP :: "Disable"
    param FWID_SETUP :: 1
    param CLKGDV_SETUP :: 1
    param FPER_SETUP :: 1
    param CLKX_IO :: "Input"
    param FSX_IO :: "Input"
    param CLKR_IO :: "Input"
    param FSR_IO :: "Input"
    param EN_DX :: "Output"
    param EN_DR :: "Input"
    param EN_CLKS :: "Input"
    param MCBSP_man :: 0
    param SPCR1_VALUE :: 0
    param SPCR2_VALUE :: 256
    param RCR1_VALUE :: 320
    param RCR2_VALUE :: 0
    param XCR1_VALUE :: 320
    param XCR2_VALUE :: 0
    param SRGR1_VALUE :: 0
    param SRGR2_VALUE :: 0
    param MCR1_VALUE :: 0
    param MCR2_VALUE :: 0
    param PCR_VALUE :: 3
    param RMCM_RMCME_SETUP :: "All 128 Channels"
    param RPABLK_SETUP :: "Block 0. Channel 0-15"
    param RPBBLK_SETUP :: "Block 1. Channel 16-31"
    param RCERA_VALUE :: 0
    param RCERB_VALUE :: 0
    param RCERC_VALUE :: 0
    param RCERD_VALUE :: 0
    param RCERE_VALUE :: 0
    param RCERF_VALUE :: 0
    param RCERG_VALUE :: 0
    param RCERH_VALUE :: 0
    param XMCM_XMCME_SETUP :: "All 128 Channels"
    param XPABLK_SETUP :: "Block 0. Channel 0-15"
    param XPBBLK_SETUP :: "Block 1. Channel 16-31"
    param XCERA_VALUE :: 0
    param XCERB_VALUE :: 0
    param XCERC_VALUE :: 0
    param XCERD_VALUE :: 0
    param XCERE_VALUE :: 0
    param XCERF_VALUE :: 0
    param XCERG_VALUE :: 0
    param XCERH_VALUE :: 0
    param XMCM_01 :: "DXR written for enabled/unmasked channels,DX driven for enabled/unmasked channels"
    param XMCM_10 :: "DXR written for all channels in block,DX driven for unmasked channels"
    param ABIS_RCERA_VALUE :: 0
    param ABIS_RCERB_VALUE :: 0
    param ABIS_XCERA_VALUE :: 0
    param ABIS_XCERB_VALUE :: 0
    param RCERA :: 0
    param RCERB :: 0
    param RCERC :: 0
    param RCERD :: 0
    param RCERE :: 0
    param RCERF :: 0
    param RCERG :: 0
    param RCERH :: 0
    param XCERA :: 0
    param XCERB :: 0
    param XCERC :: 0
    param XCERD :: 0
    param XCERE :: 0
    param XCERF :: 0
    param XCERG :: 0
    param XCERH :: 0
}

