\section{System Design} \label{sec:systemDesign}
This appendix will go through the design of the system using a feedforward topology. The ANC system will be placed in a headphone with the microphones placed as seen on \autoref{fig:SystemHeadphone}. A B\&K TYPE 4128-C will be used as the HATS during tests. This means that the cancellation path will have a linear time invariant (LTI) impulse response. 


\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Articleillustrations/SystemOverview}
	\caption{Illustration of the HATS wearing a headphone fitted with a ANC solution.}
	\label{fig:SystemHeadphone}
\end{figure}  

Because the cancellation path is LTI, the adaptive algorithm adjusting the cancellation path (CP) estimate will not be in the system. This means that the copy of the CP estimate will be a constant impulse response. The CP has been found as described in \autoref{sec:CPjournal}. The used feedforward control system is shown in \autoref{fig:BasicSystem} and is described in \autoref{sec:BasicSystem}. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{ArticleIllustrations/ANCFeedForward}
	\caption{Block diagram of basic system without adaptive CP.}
	\label{fig:BasicSystem}
\end{figure}   




\subsection{FXLMS algorithm for FIR filters}\label{subsec:fxlms}
The FXLMS is a gradient descent algorithm which iteratively changes the coefficients of the control filter by adding a calculated step to the current coefficients which should converge to a global minimum of the error criterion. The derivation of the FXLMS algorithm is given below. 
\begin{equation}\label{eq:FXLMSNewCoef}
\bar{b}(k+1) = \bar{b}(k) - \mu\nabla \bar{J}(k)
\end{equation}
Where:
\begin{description}
	\item[\text{$\nabla \bar{J}$}] is the gradient of the error surface at the location given by the current weight coefficient.
	\item[\text{$\mu$}] is a convergence factor.
	\item[\text{$\bar{b}(k)$}] is the weight coefficients of the control filter written as  $\bar{b}(k)=[b_0(k),b_1(k) ,\cdots, b_{L-1}(k)]^T$.
\end{description}
The error is defined as:
\begin{equation}\label{eq:FXLMSError}
e(k) = p(k) + s(k)
\end{equation}
Where:
\begin{description}
	\item[\text{$p(k)$}] is the primary noise source.
	\item[\text{$s(k)$}] is the counterphase signal.
\end{description}

The error criterion as a function of the filter weights is to be minimized, therefore the gradient of the error surface ($\nabla \bar{J}$) is calculated by differentiating the squared error, as shown in equation \ref{eq:FXLMSGradient}.
\begin{equation}\label{eq:FXLMSGradient}
\bar{J}(k) = e^2(k)
\end{equation}

Differentiating equation \ref{eq:FXLMSGradient} with respect to $b(k)$ yields equation \ref{eq:FXLMSGradientW(k)}. The last substitution can be made because $p(k)$ does not depend on $b(k)$. So the term $p(k)$ from equation \ref{eq:FXLMSError} does not influence the gradient of $e(k)$:

\begin{equation}\label{eq:FXLMSGradientW(k)}
\Delta \bar{b}(k) = \frac{\partial e^2(k)}{\partial \bar{b}(k)} = 2e(k)\frac{\partial e(k)}{\partial \bar{b}(k)} = 2e(k)\frac{\partial s(k)}{\partial \bar{b}(k)}
\end{equation}
$e(k)$ can be sampled. How to obtain s(k) is described below. \\
The controller output signal y(k) is given by equation \ref{eq:FXLMSOutput}.

\begin{equation}\label{eq:FXLMSOutput}
y(k) = \bar{b}^T(k)*\bar{x}(k) = \sum_{j=0}^{L-1} b_j(k)x(k-j)
\end{equation}
Where:
\begin{description}
	\item[\text{$\bar{x}(k)$}] = $[x(k) x(k-1) \cdots x(k-L+1)]^T $
\end{description}
$s(k)$ can be formulated as equation \ref{eq:FXLMSs(k)}.

\begin{equation}\label{eq:FXLMSs(k)}
s(k) = [\bar{b}^T(k)\bar{x}(k)]*\bar{c}(k)\approx \bar{y}(k)*\bar{\hat{c}}(k) = \sum_{j=0}^{M-1}\hat{c}_j(k)y(k-j)
\end{equation}
Where:
\begin{description}
	\item[\text{$\bar{y}(k)$}] = $[ y(k), y(k-1), \cdots, y(k-M+1)]$
	\item[\text{$\bar{c}(k)$}] is the impulse response of the cancellation path (filter taps)
\end{description}

Equation \ref{eq:FXLMSs(k)} can be rewritten to equation \ref{eq:FXLMSs(k)2}.

\begin{equation}\label{eq:FXLMSs(k)2}
s(k) = [\bar{b}^T(k)\bar{x}(k)]*\bar{c}(k)\approx \bar{b}^T(k)*\bar{f}(k)
\end{equation}
Where:
\begin{description}
	\item[\text{$\bar{f}(k)$}] is the filtered reference signal $f(k)=\bar{x}^T(k)\bar{c}(k)$
	\item[\text{$\bar{f}(k-j)$})] = $\sum_{i=0}^{M-1}\hat{c}_i(k)x(k-i-j)$
\end{description}

By using equation \ref{eq:FXLMSs(k)2} substituted into equation \ref{eq:FXLMSGradientW(k)}, the error of the surface gradient can be written as equation \ref{eq:FXLMSNablaJ}:

\begin{equation}\label{eq:FXLMSNablaJ}
\nabla \bar{J} = 2e(k)\frac{\partial s(k)}{\partial \bar{b}(k)} = 2e(k)f(k)
\end{equation}

Which yields equation \ref{eq:FXLMSw(k+1)}:

\begin{equation}\label{eq:FXLMSw(k+1)}
\bar{b}(k+1) = \bar{b}(k) - 2\mu e(k)\bar{f}(k)
\end{equation}

Which is the standard FXLMS algorithm when using an adaptive FIR filter.
\begin{equation}\label{eq:FXLMSw_j(k+1)}
b_j(k+1) = b_j(k) - 2\mu e(k)f(k-j)
\end{equation}

With the definition of the FXLMS given, the system in \autoref{fig:BasicSystem}, can be simulated.



\subsection{Simulation} 
The system shown in \autoref{fig:BasicSystem} has been setup in Simulink\textsuperscript{\textregistered}, as shown in \autoref{fig:SimulinkRealWorld} and \autoref{fig:SimulinkANC} showing the "real world"-simulation and the alogrithm-simulation, respectively.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figures/BasicSystem/SimulinkRealWorld}
	\caption{Simulink of "real world".}
	\label{fig:SimulinkRealWorld}
\end{figure}    

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{figures/BasicSystem/SimulinkANC}
	\caption{Simulink of "ANC algorithm".}
	\label{fig:SimulinkANC}
\end{figure} 

The functions for the different impulse responses and the control filter is a standard sample-by-sample FIR filter, while the FXLMS algorithm is \autoref{eq:FXLMSw_j(k+1)} implemented with a convergence factor of 0.001. This convergence factor is chosen to by experiment to be as large as possible, without getting an unstable system as described by Hansen \cite{Hansen2}. The delay of the ADC and DAC is set to 0 samples.\fxnote{Which results do we need}



